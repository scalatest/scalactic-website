<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Scalactic 3.1.4  - org.scalactic</title><meta content="Scalactic 3.1.4 - org.scalactic" name="description"/><meta content="Scalactic 3.1.4 org.scalactic" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script>

<!-- gtag [javascript] -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-71294502-2"></script>

<script defer>

window.dataLayer = window.dataLayer || [];

function gtag(){dataLayer.push(arguments);}

gtag('js', new Date());

gtag('config', 'UA-71294502-2');

</script>
</head><body><div id="search"><span id="doc-title">Scalactic 3.1.4<span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.org" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="org"></a><a id="org:org"></a> <span class="permalink"><a href="../../org/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">org</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 current" name="org.scalactic" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scalactic"></a><a id="scalactic:scalactic"></a> <span class="permalink"><a href="../../org/scalactic/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">scalactic</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="org" id="org" class="extype">org</a></dd></dl></div></li><li class="indented3 " name="org.scalactic.anyvals" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="anyvals"></a><a id="anyvals:anyvals"></a> <span class="permalink"><a href="../../org/scalactic/anyvals/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="anyvals/index.html" title=""><span class="name">anyvals</span></a></span></li><li class="indented3 " name="org.scalactic.exceptions" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="exceptions"></a><a id="exceptions:exceptions"></a> <span class="permalink"><a href="../../org/scalactic/exceptions/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="exceptions/index.html" title=""><span class="name">exceptions</span></a></span></li><li class="indented3 " name="org.scalactic.source" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="source"></a><a id="source:source"></a> <span class="permalink"><a href="../../org/scalactic/source/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="source/index.html" title=""><span class="name">source</span></a></span></li><li class="current-entities indented2"><span class="separator"></span> <a href="AbstractStringUniformity.html" title="Convenience base trait for string Uniformitys." class="trait"></a><a href="AbstractStringUniformity.html" title="Convenience base trait for string Uniformitys.">AbstractStringUniformity</a></li><li class="current-entities indented2"><a href="Accumulation$.html" title="Companion object to trait Accumulation that allows Accumulation's members to be imported rather than mixed in, and also contains nested traits used by implicit conversions declared in trait Accumulations." class="object"></a> <a href="Accumulation.html" title="Provides mechanisms that enable errors to be accumulated in &amp;ldquo;accumulating Ors,&amp;rdquo; Ors whose Bad type is an Every." class="trait"></a><a href="Accumulation.html" title="Provides mechanisms that enable errors to be accumulated in &amp;ldquo;accumulating Ors,&amp;rdquo; Ors whose Bad type is an Every.">Accumulation</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="AccumulationLowPriorityImplicits.html" title="" class="trait"></a><a href="AccumulationLowPriorityImplicits.html" title="">AccumulationLowPriorityImplicits</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Bad.html" title="Contains a &amp;ldquo;bad&amp;rdquo; value." class="class"></a><a href="Bad.html" title="Contains a &amp;ldquo;bad&amp;rdquo; value.">Bad</a></li><li class="current-entities indented2"><a href="Bool$.html" title="Bool companion object that provides factory methods to create different sub types of Bool" class="object"></a> <a href="Bool.html" title="A trait that represent a rich-featured boolean value, which includes the following members:" class="trait"></a><a href="Bool.html" title="A trait that represent a rich-featured boolean value, which includes the following members:">Bool</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="CanEqual.html" title="Abstract class used to enforce type constraints for equality checks." class="class"></a><a href="CanEqual.html" title="Abstract class used to enforce type constraints for equality checks.">CanEqual</a></li><li class="current-entities indented2"><a href="Catcher$.html" title="Companion object for Catcher that provides a factory method for creating Throwable extractors." class="object"></a> <a href="Catcher.html" title="Convenience class for extractors that match and return Throwables based on a type and Boolean condition." class="class"></a><a href="Catcher.html" title="Convenience class for extractors that match and return Throwables based on a type and Boolean condition.">Catcher</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="DefaultEquality$.html" title="" class="object"></a><a href="DefaultEquality$.html" title="">DefaultEquality</a></li><li class="current-entities indented2"><a href="Equality$.html" title="Companion object for trait Equality that provides factory methods for producing Equality instances." class="object"></a> <a href="Equality.html" title="Defines a custom way to determine equality for a type when compared with another value of type Any." class="trait"></a><a href="Equality.html" title="Defines a custom way to determine equality for a type when compared with another value of type Any.">Equality</a></li><li class="current-entities indented2"><a href="Equivalence$.html" title="Companion object for trait Equivalence that provides a factory method for producing default Equivalence instances." class="object"></a> <a href="Equivalence.html" title="Defines a custom way to determine equality for a type when compared with another value of the same type." class="trait"></a><a href="Equivalence.html" title="Defines a custom way to determine equality for a type when compared with another value of the same type.">Equivalence</a></li><li class="current-entities indented2"><a href="Every$.html" title="Companion object for abstract class Every." class="object"></a> <a href="Every.html" title="An ordered, immutable, non-empty collection of elements." class="class"></a><a href="Every.html" title="An ordered, immutable, non-empty collection of elements.">Every</a></li><li class="current-entities indented2"><a href="Explicitly$.html" title="Companion object for Explicitly, which enables the Scalactic explicitly DSL to be imported rather than mixed in, like this:" class="object"></a> <a href="Explicitly.html" title="Provides ScalaTest's &amp;ldquo;explicitly DSL,&amp;rdquo; which facilitates the explicit specification of an Equality[T] or a Uniformity[T] where Equality[T] is taken implicitly." class="trait"></a><a href="Explicitly.html" title="Provides ScalaTest's &amp;ldquo;explicitly DSL,&amp;rdquo; which facilitates the explicit specification of an Equality[T] or a Uniformity[T] where Equality[T] is taken implicitly.">Explicitly</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Fail.html" title="Indicates a validation failed, describing the failure with a contained error value." class="class"></a><a href="Fail.html" title="Indicates a validation failed, describing the failure with a contained error value.">Fail</a></li><li class="current-entities indented2"><a href="FutureSugar$.html" title="Companion object for FutureSugar enabling its members to be imported as an alternative to mixing them in." class="object"></a> <a href="FutureSugar.html" title="Trait providing an implicit class that adds a validating method to Future, which takes one or more validation functions and returns either the same Future if either the Future had already failed or its value passes all the functions, or ValidationFailedException containing an error message describing the first validation that failed." class="trait"></a><a href="FutureSugar.html" title="Trait providing an implicit class that adds a validating method to Future, which takes one or more validation functions and returns either the same Future if either the Future had already failed or its value passes all the functions, or ValidationFailedException containing an error message describing the first validation that failed.">FutureSugar</a></li><li class="current-entities indented2"><a href="Good$.html" title="Companion object for Good that offers, in addition to the standard factory method for Good that takes single &amp;ldquo;good&amp;rdquo; type, an parameterless apply used to narrow the Good type when creating a Bad." class="object"></a> <a href="Good.html" title="Contains a &amp;ldquo;good&amp;rdquo; value." class="class"></a><a href="Good.html" title="Contains a &amp;ldquo;good&amp;rdquo; value.">Good</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="LowPriorityTypeCheckedConstraint.html" title="Provides an implicit conversion that will be applied only if a higher-priority implicit conversion declared a subtrait is not applicable." class="trait"></a><a href="LowPriorityTypeCheckedConstraint.html" title="Provides an implicit conversion that will be applied only if a higher-priority implicit conversion declared a subtrait is not applicable.">LowPriorityTypeCheckedConstraint</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Many.html" title="An Every that contains two or more elements." class="class"></a><a href="Many.html" title="An Every that contains two or more elements.">Many</a></li><li class="current-entities indented2"><a href="MapEqualityConstraints$.html" title="Companion object that facilitates the importing of MapEqualityConstraints members as an alternative to mixing it in." class="object"></a> <a href="MapEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Maps to one that more closely matches Scala's approach to Map equality." class="trait"></a><a href="MapEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Maps to one that more closely matches Scala's approach to Map equality.">MapEqualityConstraints</a></li><li class="current-entities indented2"><a href="NormMethods$.html" title="Companion object for NormMethods enabling its members to be imported as an alternative to mixing them in." class="object"></a> <a href="NormMethods.html" title="Provides an implicit conversion that allows norm to be invoked on any value of type T for which an implicit Normalization[T] exists." class="trait"></a><a href="NormMethods.html" title="Provides an implicit conversion that allows norm to be invoked on any value of type T for which an implicit Normalization[T] exists.">NormMethods</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Normalization.html" title="Defines a custom way to normalize instances of a type." class="trait"></a><a href="Normalization.html" title="Defines a custom way to normalize instances of a type.">Normalization</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="NormalizingEquality.html" title="An Equality[A] implementation that determines the equality of two objects by normalizing one or both objects, then comparing the results using an &amp;ldquo;after normalization&amp;rdquo; equality referenced from the afterNormalizationEquality  member." class="trait"></a><a href="NormalizingEquality.html" title="An Equality[A] implementation that determines the equality of two objects by normalizing one or both objects, then comparing the results using an &amp;ldquo;after normalization&amp;rdquo; equality referenced from the afterNormalizationEquality  member.">NormalizingEquality</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="NormalizingEquivalence.html" title="An Equivalence[A] implementation that determines the equality of two objects by normalizing one or both objects, then comparing the results using an &amp;ldquo;after normalization&amp;rdquo; Equivalence referenced from the afterNormalizationEquivalence  member." class="trait"></a><a href="NormalizingEquivalence.html" title="An Equivalence[A] implementation that determines the equality of two objects by normalizing one or both objects, then comparing the results using an &amp;ldquo;after normalization&amp;rdquo; Equivalence referenced from the afterNormalizationEquivalence  member.">NormalizingEquivalence</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="One.html" title="An Every that contains exactly one element." class="class"></a><a href="One.html" title="An Every that contains exactly one element.">One</a></li><li class="current-entities indented2"><a href="OptionSugar$.html" title="Companion object for OptionSugar enabling its members to be imported as an alternative to mixing them in." class="object"></a> <a href="OptionSugar.html" title="Trait providing an implicit class that adds a toOr method to Option, which converts Some to Good, None to Bad." class="trait"></a><a href="OptionSugar.html" title="Trait providing an implicit class that adds a toOr method to Option, which converts Some to Good, None to Bad.">OptionSugar</a></li><li class="current-entities indented2"><a href="Or$.html" title="The companion object for Or providing factory methods for creating Ors from Eithers and Trys." class="object"></a> <a href="Or.html" title="Represents a value that is one of two possible types, with one type being &amp;ldquo;good&amp;rdquo; and the other &amp;ldquo;bad.&amp;rdquo;" class="class"></a><a href="Or.html" title="Represents a value that is one of two possible types, with one type being &amp;ldquo;good&amp;rdquo; and the other &amp;ldquo;bad.&amp;rdquo;">Or</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Pass$.html" title="Indicates a validation succeeded." class="object"></a><a href="Pass$.html" title="Indicates a validation succeeded.">Pass</a></li><li class="current-entities indented2"><a href="Prettifier$.html" title="Companion object for Prettifier that provides a default Prettifier implementation." class="object"></a> <a href="Prettifier.html" title="A function that given any object will produce a &amp;ldquo;pretty&amp;rdquo; string representation of that object, where &amp;ldquo;pretty&amp;rdquo; is in the eye of the implementer." class="trait"></a><a href="Prettifier.html" title="A function that given any object will produce a &amp;ldquo;pretty&amp;rdquo; string representation of that object, where &amp;ldquo;pretty&amp;rdquo; is in the eye of the implementer.">Prettifier</a></li><li class="current-entities indented2"><a href="PrettyMethods$.html" title="Companion object for trait PrettyMethods enabling its members to be imported as an alternative to mixing them in." class="object"></a> <a href="PrettyMethods.html" title="Provides an implicit conversion that enables pretty to be invoked on any object, to transform that object into a String representation." class="trait"></a><a href="PrettyMethods.html" title="Provides an implicit conversion that enables pretty to be invoked on any object, to transform that object into a String representation.">PrettyMethods</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="PrettyPair.html" title="" class="class"></a><a href="PrettyPair.html" title="">PrettyPair</a></li><li class="current-entities indented2"><a href="Requirements$.html" title="Companion object that facilitates the importing of Requirements members as an alternative to mixing it in." class="object"></a> <a href="Requirements.html" title="Trait that contains require, and requireState, and requireNonNull methods for checking pre-conditions that give descriptive error messages extracted via a macro." class="trait"></a><a href="Requirements.html" title="Trait that contains require, and requireState, and requireNonNull methods for checking pre-conditions that give descriptive error messages extracted via a macro.">Requirements</a></li><li class="current-entities indented2"><a href="SeqEqualityConstraints$.html" title="Companion object that facilitates the importing of SeqEqualityConstraints members as an alternative to mixing it in." class="object"></a> <a href="SeqEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Seqs to one that more closely matches Scala's approach to Seq equality." class="trait"></a><a href="SeqEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Seqs to one that more closely matches Scala's approach to Seq equality.">SeqEqualityConstraints</a></li><li class="current-entities indented2"><a href="SetEqualityConstraints$.html" title="Companion object that facilitates the importing of SetEqualityConstraints members as an alternative to mixing it in." class="object"></a> <a href="SetEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Sets to one that more closely matches Scala's approach to Set equality." class="trait"></a><a href="SetEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Sets to one that more closely matches Scala's approach to Set equality.">SetEqualityConstraints</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Snapshot.html" title="Case class that stores the name and value of a variable or expression." class="class"></a><a href="Snapshot.html" title="Case class that stores the name and value of a variable or expression.">Snapshot</a></li><li class="current-entities indented2"><a href="SnapshotSeq$.html" title="" class="object"></a> <a href="SnapshotSeq.html" title="An IndexedSeq[Snapshot] providing toString and lines methods that can be useful for debug and log messages about program state." class="class"></a><a href="SnapshotSeq.html" title="An IndexedSeq[Snapshot] providing toString and lines methods that can be useful for debug and log messages about program state.">SnapshotSeq</a></li><li class="current-entities indented2"><a href="Snapshots$.html" title="Companion object that facilitates the importing of Snapshots members as an alternative to mixing it in." class="object"></a> <a href="Snapshots.html" title="Trait that provides a snap method that takes one or more arguments and results in a SnapshotSeq, whose toString lists the names and values of each argument." class="trait"></a><a href="Snapshots.html" title="Trait that provides a snap method that takes one or more arguments and results in a SnapshotSeq, whose toString lists the names and values of each argument.">Snapshots</a></li><li class="current-entities indented2"><a href="StringNormalizations$.html" title="Companion object to trait StringNormalizations that provides an alternative to mixing it in." class="object"></a> <a href="StringNormalizations.html" title="Provides methods that produce Uniformity[String] instances for various ways to normalize strings for equality comparisons." class="trait"></a><a href="StringNormalizations.html" title="Provides methods that produce Uniformity[String] instances for various ways to normalize strings for equality comparisons.">StringNormalizations</a></li><li class="current-entities indented2"><a href="TimesOnInt$.html" title="Companion object that facilitates the importing of TimesOnInt members as an alternative to mixing it in." class="object"></a> <a href="TimesOnInt.html" title="Trait providing an implicit conversion that adds a times method to Ints that will repeat a given side-effecting operation multiple times." class="trait"></a><a href="TimesOnInt.html" title="Trait providing an implicit conversion that adds a times method to Ints that will repeat a given side-effecting operation multiple times.">TimesOnInt</a></li><li class="current-entities indented2"><a href="Tolerance$.html" title="Companion object to trait Tolerance that facilitates the importing of Tolerance members as an alternative to mixing it in." class="object"></a> <a href="Tolerance.html" title="Trait containing an implicit conversion that adds a +- method to Numeric types, which enables spreads to be expressed in terms of a pivot and tolerance." class="trait"></a><a href="Tolerance.html" title="Trait containing an implicit conversion that adds a +- method to Numeric types, which enables spreads to be expressed in terms of a pivot and tolerance.">Tolerance</a></li><li class="current-entities indented2"><a href="TolerantNumerics$.html" title="Companion object for TolerantNumerics that enables its members to be imported as an alternative to mixing them in." class="object"></a> <a href="TolerantNumerics.html" title="Provides Equality and Equivalence instances for Numeric types that compare for equality with a given tolerance." class="trait"></a><a href="TolerantNumerics.html" title="Provides Equality and Equivalence instances for Numeric types that compare for equality with a given tolerance.">TolerantNumerics</a></li><li class="current-entities indented2"><a href="TraversableEqualityConstraints$.html" title="Companion object that facilitates the importing of TraversableEqualityConstraints members as an alternative to mixing it in." class="object"></a> <a href="TraversableEqualityConstraints.html" title="Provides three implicit methods that loosen the equality constraint defined by TypeCheckedTripleEquals for Scala Traversables to one that more closely matches Scala's approach to Traversable equality." class="trait"></a><a href="TraversableEqualityConstraints.html" title="Provides three implicit methods that loosen the equality constraint defined by TypeCheckedTripleEquals for Scala Traversables to one that more closely matches Scala's approach to Traversable equality.">TraversableEqualityConstraints</a></li><li class="current-entities indented2"><a href="TripleEquals$.html" title="Companion object to trait TripleEquals that facilitates the importing of TripleEquals members as an alternative to mixing it in." class="object"></a> <a href="TripleEquals.html" title="Provides === and !== operators that return Boolean, delegate the equality determination to an Equality type class, and require no relationship between the types of the two values compared." class="trait"></a><a href="TripleEquals.html" title="Provides === and !== operators that return Boolean, delegate the equality determination to an Equality type class, and require no relationship between the types of the two values compared.">TripleEquals</a></li><li class="current-entities indented2"><a href="TripleEqualsSupport$.html" title="" class="object"></a> <a href="TripleEqualsSupport.html" title="Trait that defines abstract methods used to enforce compile-time type constraints for equality comparisons, and defines === and !== operators used by matchers." class="trait"></a><a href="TripleEqualsSupport.html" title="Trait that defines abstract methods used to enforce compile-time type constraints for equality comparisons, and defines === and !== operators used by matchers.">TripleEqualsSupport</a></li><li class="current-entities indented2"><a href="TrySugar$.html" title="Companion object for TrySugar enabling its members to be imported as an alternative to mixing them in." class="object"></a> <a href="TrySugar.html" title="Trait providing an implicit class that adds a toOr method to Try, which converts Success to Good, and Failure to Bad, as well as a validating method, which takes one or more validation functions and returns either the same Try if either the Try had already failed or its value passes all the functions, or ValidationFailedException containing an error message describing the first validation that failed." class="trait"></a><a href="TrySugar.html" title="Trait providing an implicit class that adds a toOr method to Try, which converts Success to Good, and Failure to Bad, as well as a validating method, which takes one or more validation functions and returns either the same Try if either the Try had already failed or its value passes all the functions, or ValidationFailedException containing an error message describing the first validation that failed.">TrySugar</a></li><li class="current-entities indented2"><a href="TypeCheckedTripleEquals$.html" title="Companion object to trait TypeCheckedTripleEquals that facilitates the importing of TypeCheckedTripleEquals members as an alternative to mixing it in." class="object"></a> <a href="TypeCheckedTripleEquals.html" title="Provides === and !== operators that return Boolean, delegate the equality determination to an Equality type class, and require the types of the two values compared to be in a subtype/supertype relationship." class="trait"></a><a href="TypeCheckedTripleEquals.html" title="Provides === and !== operators that return Boolean, delegate the equality determination to an Equality type class, and require the types of the two values compared to be in a subtype/supertype relationship.">TypeCheckedTripleEquals</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Uniformity.html" title="Defines a custom way to normalize instances of a type that can also handle normalization of that type when passed as Any." class="trait"></a><a href="Uniformity.html" title="Defines a custom way to normalize instances of a type that can also handle normalization of that type when passed as Any.">Uniformity</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Validation.html" title="Represents the result of a validation, either the object Pass if the validation succeeded, else an instance of Fail containing an error value describing the validation failure." class="trait"></a><a href="Validation.html" title="Represents the result of a validation, either the object Pass if the validation succeeded, else an instance of Fail containing an error value describing the validation failure.">Validation</a></li></ul></div></div><div id="content"><body class="package value">

<!-- Top of doc.scalactic.org [javascript] -->

<script id="adsArtimaScript" type="text/javascript" src="https://www.artima.com/assets/javascripts/4ca150665e51d0b1c3890ca1b891c507-ads.js?product=Scalactic"></script>
<div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../index.html" name="org" id="org" class="extype">org</a></p><h1>scalactic<span class="permalink"><a href="../../org/scalactic/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">scalactic</span></span></h4><div id="comment" class="fullcommenttop"><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/scalatest/scalatest/tree/release-3.1.4/scalactic//src/main/scala/org/scalactic/package.scala" target="_blank">package.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="org.scalactic"><span>scalactic</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="packages" class="package members"><h3>Package Members</h3><ol><li class="indented0 " name="org.scalactic.anyvals" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="anyvals"></a><a id="anyvals:anyvals"></a> <span class="permalink"><a href="../../org/scalactic/anyvals/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="anyvals/index.html" title=""><span class="name">anyvals</span></a></span></li><li class="indented0 " name="org.scalactic.exceptions" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="exceptions"></a><a id="exceptions:exceptions"></a> <span class="permalink"><a href="../../org/scalactic/exceptions/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="exceptions/index.html" title=""><span class="name">exceptions</span></a></span></li><li class="indented0 " name="org.scalactic.source" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="source"></a><a id="source:source"></a> <span class="permalink"><a href="../../org/scalactic/source/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="source/index.html" title=""><span class="name">source</span></a></span></li></ol></div><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="org.scalactic.AbstractStringUniformity" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="AbstractStringUniformityextendsUniformity[String]"></a><a id="AbstractStringUniformity:AbstractStringUniformity"></a> <span class="permalink"><a href="../../org/scalactic/AbstractStringUniformity.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="AbstractStringUniformity.html" title="Convenience base trait for string Uniformitys."><span class="name">AbstractStringUniformity</span></a><span class="result"> extends <a href="Uniformity.html" name="org.scalactic.Uniformity" id="org.scalactic.Uniformity" class="extype">Uniformity</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">Convenience base trait for string <a href="Uniformity.html"><code>Uniformity</code></a>s.</p><div class="fullcomment"><div class="comment cmt"><p>Convenience base trait for string <a href="Uniformity.html"><code>Uniformity</code></a>s.</p><p>This trait defines a <code>normalizedCanHandle</code> method that returns true if the passed
<code>Any</code> is a <code>String</code> and a <code>normalizedOrSame</code> method that
normalizes any passed <code>String</code>s via the <code>normalized</code> method, which is
left abstract for subclasses to fill in.</p><p>Here's an example in which <code>AbstractStringUniformity</code> is used to normalize strings
by ensuring the first character, if any, is capitalized:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> capitalized: <span class="stType">Uniformity[String]</span> =
  <span class="stReserved">new</span> <span class="stType">AbstractStringUniformity</span> {
    <span class="stReserved">def</span> normalized(s: <span class="stType">String</span>): <span class="stType">String</span> =
      <span class="stReserved">if</span> (s.isEmpty) <span class="stQuotedString">""</span> <span class="stReserved">else</span> s.charAt(<span class="stLiteral">0</span>).toUpper + s.substring(<span class="stLiteral">1</span>)
  }
</pre></p><p>Here's an example of using the <code>capitalized</code> <code>Uniformity</code> with a <code>Matcher</code> expression:</p><p><pre class="stREPL">
scala&gt; import org.scalatest._
import org.scalatest._

scala&gt; import Matchers._
import Matchers._

scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; val capitalized: Uniformity[String] =
     |   new AbstractStringUniformity {
     |     def normalized(s: String): String =
     |       if (s.isEmpty) "" else s.charAt(0).toUpper + s.substring(1)
     |   }
capitalized: org.scalactic.Uniformity[String] = $anon$1@65601e00

scala&gt; "Hello" should equal ("hello") (after being capitalized)
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.Accumulation" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="AccumulationextendsAccumulationLowPriorityImplicits"></a><a id="Accumulation:Accumulation"></a> <span class="permalink"><a href="../../org/scalactic/Accumulation.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Accumulation.html" title="Provides mechanisms that enable errors to be accumulated in &amp;ldquo;accumulating Ors,&amp;rdquo; Ors whose Bad type is an Every."><span class="name">Accumulation</span></a><span class="result"> extends <a href="AccumulationLowPriorityImplicits.html" name="org.scalactic.AccumulationLowPriorityImplicits" id="org.scalactic.AccumulationLowPriorityImplicits" class="extype">AccumulationLowPriorityImplicits</a></span></span><p class="shortcomment cmt">Provides mechanisms that enable errors to be accumulated in &ldquo;accumulating <a href="Or.html"><code>Or</code></a>s,&rdquo; <code>Or</code>s whose
<a href="Bad.html"><code>Bad</code></a> type is an <a href="Every.html"><code>Every</code></a>.</p><div class="fullcomment"><div class="comment cmt"><p>Provides mechanisms that enable errors to be accumulated in &ldquo;accumulating <a href="Or.html"><code>Or</code></a>s,&rdquo; <code>Or</code>s whose
<a href="Bad.html"><code>Bad</code></a> type is an <a href="Every.html"><code>Every</code></a>.</p><p>The mechanisms are:</p><ul><li>Passing accumulating <code>Or</code>s to <code>withGood</code> methods</li><li>Invoking <code>combined</code> on a container of accumulating <code>Or</code>s</li><li>Invoking <code>validatedBy</code> on a container of any type, passing in a function from that type to an accumulating <code>Or</code></li><li>Invoking <code>zip</code> on an accumulating <code>Or</code></li><li>Invoking <code>when</code> on an accumulating <code>Or</code></li></ul><p>For more information and examples, see the <a href="Or.html#accumulatingErrors">Accumulating errors with <code>Or</code></a> section
of the main documentation for class <code>Or</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.AccumulationLowPriorityImplicits" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="AccumulationLowPriorityImplicitsextendsAnyRef"></a><a id="AccumulationLowPriorityImplicits:AccumulationLowPriorityImplicits"></a> <span class="permalink"><a href="../../org/scalactic/AccumulationLowPriorityImplicits.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="AccumulationLowPriorityImplicits.html" title=""><span class="name">AccumulationLowPriorityImplicits</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span></li><li class="indented0 " name="org.scalactic.Bad" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Bad[+B]extendsOr[Nothing,B]withProductwithSerializable"></a><a id="Bad[+B]:Bad[B]"></a> <span class="permalink"><a href="../../org/scalactic/Bad.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">case class</span></span> <span class="symbol"><a href="Bad.html" title="Contains a &amp;ldquo;bad&amp;rdquo; value."><span class="name">Bad</span></a><span class="tparams">[<span name="B">+B</span>]</span><span class="params">(<span name="b">b: <span name="org.scalactic.Bad.B" class="extype">B</span></span>)</span><span class="result"> extends <a href="Or.html" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="scala.Nothing" class="extype">Nothing</span>, <span name="org.scalactic.Bad.B" class="extype">B</span>] with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Contains a &ldquo;bad&rdquo; value.</p><div class="fullcomment"><div class="comment cmt"><p>Contains a &ldquo;bad&rdquo; value.</p><p>You can decide what &ldquo;bad&rdquo; means, but it is expected <code>Bad</code> will be commonly used
to hold descriptions of an error (or several, accumulated errors). Some examples of possible error descriptions
are <code>String</code> error messages, <code>Int</code> error codes, <code>Throwable</code> exceptions,
or instances of a case class hierarchy designed to describe errors.</p></div><dl class="paramcmts block"><dt class="param">b</dt><dd class="cmt"><p>the &ldquo;bad&rdquo; value</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Bool" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="BoolextendsAnyRef"></a><a id="Bool:Bool"></a> <span class="permalink"><a href="../../org/scalactic/Bool.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Bool.html" title="A trait that represent a rich-featured boolean value, which includes the following members:"><span class="name">Bool</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">A trait that represent a rich-featured boolean value, which includes the following members:</p><div class="fullcomment"><div class="comment cmt"><p>A trait that represent a rich-featured boolean value, which includes the following members:</p><ul><li>a boolean value</li><li>methods useful for failure messages construction</li><li>logical expression methods that makes <code>Bool</code> composable</li></ul><p><code>Bool</code> is used by code generated from <code>BooleanMacro</code> (which <code>AssertionsMacro</code> and <code>RequirementsMacro</code> uses),
it needs to be public so that the generated code can be compiled.  It is expected that ScalaTest users would ever need to use <code>Bool</code> directly.
</p></div></div></li><li class="indented0 " name="org.scalactic.CanEqual" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="CanEqual[A,B]extendsAnyRef"></a><a id="CanEqual[A,B]:CanEqual[A,B]"></a> <span class="permalink"><a href="../../org/scalactic/CanEqual.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="CanEqual.html" title="Abstract class used to enforce type constraints for equality checks."><span class="name">CanEqual</span></a><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Abstract class used to enforce type constraints for equality checks.</p><div class="fullcomment"><div class="comment cmt"><p>Abstract class used to enforce type constraints for equality checks.</p><p>For more information on how this class is used, see the documentation of <a href="TripleEqualsSupport.html"><code>TripleEqualsSupport</code></a>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@implicitNotFound</span><span class="args">(<span><span class="defval">"types ${A} and ${B} do not adhere to the type constraint selected for the === and !== operators; the missing implicit parameter is of type org.scalactic.CanEqual[${A},${B}]"</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="org.scalactic.Catcher" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="CatcherextendsAnyRef"></a><a id="Catcher:Catcher"></a> <span class="permalink"><a href="../../org/scalactic/Catcher.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="Catcher.html" title="Convenience class for extractors that match and return Throwables based on a type and Boolean condition."><span class="name">Catcher</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Convenience class for extractors that match and return <code>Throwable</code>s based on a type and <code>Boolean</code> condition.</p><div class="fullcomment"><div class="comment cmt"><p>Convenience class for extractors that match and return <code>Throwable</code>s based on a type and <code>Boolean</code> condition.</p><p>Class <code>Catcher</code> was motivated by the need to catch
and handle exceptions based on more than just the exception's type as a strategy for dealing with
"flickering" tests&#8212;tests that usually pass, but occasionally fail. The best strategy for dealing with
flickers is to fix the test such that they stop flickering, but sometimes that is not practical. In
such cases allowing the test to continue flickering can distract the team by requiring them to
spend time inspecting failures to determine whether or not they are flickers or real failures that need
attention. Worse, with enough flickers, team members can stop checking all failures and not notice real ones.</p><p>One strategy for dealing with flickers you can't practically fix is to catch exceptions that are causing individual flickers
and cancel the test when you detect them. Often this means you will need to insert a catch clause in a particular spot, or a pattern
match if in a <code>withFixture</code>, looking for a particular exception with a particular message or other identifying attribute. If
the same problem is causing flickers in many places,
it is handy to create an extractor to detect the problem. This <code>Catcher</code> class provides
a factory method that takes a partial function from <code>Throwable</code> to <code>Boolean</code> and produces such an extractor.
Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">val</span> <span class="stType">InternalServerError</span> =
  <span class="stType">Catcher</span> { <span class="stReserved">case</span> e: <span class="stType">DBAccessException</span> =&gt;
    e.getMessage == <span class="stQuotedString">"500:Internal Server Error"</span>
  }
</pre></p><p>Using this <code>Catcher</code> in a ScalaTest <code>withFixture</code> method would look like:</p><p><pre class="stHighlighted">
<span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) = {
  <span class="stReserved">super</span>.withFixture(test) <span class="stReserved">match</span> {
     <span class="stReserved">case</span> <span class="stType">Failed</span>(<span class="stType">InternalServerError</span>(ex)) =&gt;
       <span class="stType">Canceled</span>(<span class="stQuotedString">"Canceled because likely a flicker caused by intermittently flaky DB"</span>, ex)
     <span class="stReserved">case</span> other =&gt; other
  }
}
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.Equality" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="Equality[A]extendsEquivalence[A]"></a><a id="Equality[A]:Equality[A]"></a> <span class="permalink"><a href="../../org/scalactic/Equality.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Equality.html" title="Defines a custom way to determine equality for a type when compared with another value of type Any."><span class="name">Equality</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <a href="Equivalence.html" name="org.scalactic.Equivalence" id="org.scalactic.Equivalence" class="extype">Equivalence</a>[<span name="org.scalactic.Equality.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Defines a custom way to determine equality for a type when compared with another value of type <code>Any</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Defines a custom way to determine equality for a type when compared with another value of type <code>Any</code>.</p><p><code>Equality</code> enables you to define alternate notions of equality for types that can be used
with ScalaUtil's <code>===</code> and <code>!==</code> syntax and ScalaTest's matcher syntax.</p><p>For example, say you have a case class that includes a <code>Double</code> value:</p><p><pre class="stREPL">
scala&gt; case class Person(name: String, age: Double)
defined class Person
</pre></p><p>Imagine you are calculating the <code>age</code> values in such as way that occasionally tests
are failing because of rounding differences that you actually don't care about. For example, you
expect an age of 29.0, but you're sometimes seeing 29.0001:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TripleEquals._
import TripleEquals._

scala&gt; Person("Joe", 29.0001) === Person("Joe", 29.0)
res0: Boolean = false
</pre></p><p>The <code>===</code> operator looks for an implicit <code>Equality[L]</code>, where <code>L</code> is the left-hand type: in this
case, <code>Person</code>. Because you didn't specifically provide an implicit <code>Equality[Person]</code>, <code>===</code> will fall back on
<a href="#defaultEquality">default equality</a>, which will call <code>Person</code>'s <code>equals</code> method. That <code>equals</code> method, provided by the Scala compiler
because <code>Person</code> is a case class, will declare these two objects unequal because 29.001 does not exactly equal 29.0.</p><p>To make the equality check more forgiving, you could define an implicit <code>Equality[Person]</code> that compares
the <code>age</code> <code>Double</code>s with a tolerance, like this:</p><p><pre class="stREPL">
scala&gt; import Tolerance._
import Tolerance._

scala&gt; implicit val personEq =
     |   new Equality[Person] {
     |     def areEqual(a: Person, b: Any): Boolean =
     |       b match {
     |         case p: Person =&gt; a.name == p.name &amp;&amp; a.age === p.age +- 0.0002
     |         case _ =&gt; false
     |       }
     |   }
personEq: org.scalactic.Equality[Person] = $anon$1@2b29f6e7
</pre></p><p>Now the <code>===</code> operator will use your more forgiving <code>Equality[Person]</code> for the equality check instead
of default equality:</p><p><pre class="stREPL">
scala&gt; Person("Joe", 29.0001) === Person("Joe", 29.0)
res1: Boolean = true
</pre></p><p><a name="defaultEquality"></a></p><h4> Default equality </h4><p>Scalactic defines a default <code>Equality[T]</code> for all types <code>T</code> whose <code>areEqual</code> method works by first
calling <code>.deep</code> on any passed array, then calling <code>==</code> on the left-hand object, passing in the right-hand object.
You can obtain a default equality via the <code>default</code> method of the <a href="Equality$.html">Equality companion object</a>,
or from the <code>defaultEquality</code> method defined in <a href="TripleEqualsSupport.html"><code>TripleEqualsSupport</code></a>.</p><p><a name="aboutEquality"></a></p><h4> About equality and equivalence </h4><p>The <code>Equality</code> trait represents the Java Platform's native notion of equality, as expressed in the signature and contract of
the <code>equals</code> method of <code>java.lang.Object</code>. Essentially, trait <code>Equality</code> enables you to write alternate
<code>equals</code> method implementations for a type outside its defining class.</p><p>In an <code>equals</code> method, the left-hand type is known to be the type of <code>this</code>, but
the right-hand type is <code>Any</code>.
As a result, you would normally perform a runtime type test to determine whether the right-hand object is of an appropriate type for equality,
and if so, compare it structurally for equality with the left-hand (<code>this</code>) object.
An an illustration, here's a possible <code>equals</code>
implementation for the <code>Person</code> case class shown in the earlier example:</p><p><pre class="stHighlighted">
<span class="stReserved">override</span> <span class="stReserved">def</span> equals(other: <span class="stType">Any</span>): <span class="stType">Boolean</span> =
  other <span class="stReserved">match</span> {
    <span class="stReserved">case</span> p: <span class="stType">Person</span> =&gt; name = p.name &amp;&amp; age = p.age
    <span class="stReserved">case</span> _ =&gt; <span class="stReserved">false</span>
  }
</pre></p><p>The <code>areEquals</code> method of <code>Equality[T]</code> is similar. The left-hand type is known to be <code>T</code>, but the right-hand type is <code>Any</code>, so
normally you'd need to do a runtime type test in your <code>areEqual</code> implementation.
Here's the <code>areEqual</code> method implementation from the earlier <code>Equality[Person]</code> example:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> areEqual(a: <span class="stType">Person</span>, b: <span class="stType">Any</span>): <span class="stType">Boolean</span> =
  b <span class="stReserved">match</span> {
    <span class="stReserved">case</span> p: <span class="stType">Person</span> =&gt; a.name == p.name &amp;&amp; a.age === p.age +- <span class="stLiteral">0.0002</span>
    <span class="stReserved">case</span> _ =&gt; <span class="stReserved">false</span>
  }
</pre></p><p><code>Equality</code> is used by <a href="TripleEquals.html"><code>TripleEquals</code></a>, which enforces no type constraint between the left and right values, and the
<code>equal</code>, <code>be</code>, and <code>contain</code> syntax of ScalaTest Matchers.</p><p>By contrast, <a href="TypeCheckedTripleEquals.html"><code>TypeCheckedTripleEquals</code></a>
and <a href="ConversionCheckedTripleEquals.html"><code>ConversionCheckedTripleEquals</code></a> use an <a href="Equivalence.html"><code>Equivalence</code></a>.
<code>Equivalence</code> differs from <code>Equality</code> in that both the left and right values are of the same type. <code>Equivalence</code> works for
<code>TypeCheckedTripleEquals</code> because the type constraint enforces that the left type is a subtype or supertype of (or the same type as) the right
type, and it <em>widens</em> the subtype to the supertype. So ultimately, both left and right sides are of the supertype type. Similarly, <code>Equivalence</code>
works for <code>ConversionCheckedTripleEquals</code> because the type constraint enforces that an implicit conversion
exists from either the left type to the right type, or the right type to the left type, and it always converts one
type to the other using the implicit conversion. (If both types are the same type, the identity implicit conversion
from <code>Predef</code> is used.) Because of the conversion, both left and right sides are ultimately of the
converted-to type. Here's an example of how writing an <code>Equivalence</code>'s <code>areEquivalent</code>
method might look:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> areEquivalent(a: <span class="stType">Person</span>, b: <span class="stType">Person</span>): <span class="stType">Boolean</span> =
     a.name == b.name &amp;&amp; a.age === b.age +- <span class="stLiteral">0.0002</span>
</pre></p><p>Scalactic provides both <code>Equality</code> and <code>Equivalence</code> because the <code>Any</code> in
<code>Equality</code> can sometimes make things painful. For example, in trait
<a href="TolerantNumerics.html"><code>TolerantNumerics</code></a>,
a single generic factory method can produce <code>Equivalence</code>s for any <code>Numeric</code> type,
but because of the <code>Any</code>, a separate factory method must be defined to produce an <code>Equality</code>
for each <code>Numeric</code> type.</p><p>If you just want to customize the notion of equality for <code>===</code>
used in <code>Boolean</code> expressions, you can work with <code>Equivalence</code>s instead of <code>Equality</code>s.
If you do chose to write the more general <code>Equality</code>s, they can be used wherever an <code>Equivalence</code>
is required, because <code>Equality</code> extends <code>Equivalence</code>, defining a final implementation of
<code>areEquivalent</code> that invokes <code>areEqual</code>.</p><p><em>Note: The <code>Equality</code> type class was inspired in part by the <code>Equal</code> type class of the
<a href="http://github.com/scalaz/scalaz" target="_blank"><code>scalaz</code></a> project.</em></p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>the type whose equality is being customized</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Equivalence" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="Equivalence[T]extendsAnyRef"></a><a id="Equivalence[T]:Equivalence[T]"></a> <span class="permalink"><a href="../../org/scalactic/Equivalence.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Equivalence.html" title="Defines a custom way to determine equality for a type when compared with another value of the same type."><span class="name">Equivalence</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Defines a custom way to determine equality for a type when compared with another value of the same type.</p><div class="fullcomment"><div class="comment cmt"><p>Defines a custom way to determine equality for a type when compared with another value of the same type.</p><p><code>Equivalence</code> enables you to define alternate notions of equality for types that can be used
with ScalaUtil's <a href="TypeCheckedTripleEquals.html"><code>TypeCheckedTripleEquals</code></a> and
<a href="ConversionCheckedTripleEquals.html"><code>ConversionCheckedTripleEquals</code></a>
traits. These traits can be used to perform equality comparisons with type constraints enforced at
compile time using ScalaUtil's <code>===</code> and <code>!==</code> syntax
and ScalaTest's <code>should</code> <code>===</code> syntax of <code>Matchers</code> trait.</p><p>Because <a href="Equality.html"><code>Equality</code></a> extends <code>Equivalence</code>, you automatically
define an <code>Equivalence[T]</code> when you define an <code>Equality[T]</code>. Most often you will usually
want to define custom <code>Equality</code>s, because they will be more generally useful: they are also
used by Scalactic's <a href="TripleEquals.html"><code>TripleEquals</code></a> trait and ScalaTest's
<code>equal</code>, <code>be</code>, and <code>contain</code> matcher syntax. However, if you really want
just an <code>Equivalence</code>, and writing an <code>Equality</code> is inconvenient, you can write
an <code>Equivalence</code> directly for a type.</p><p>For example, say you have a case class that includes a <code>Double</code> value:</p><p><pre class="stREPL">
scala&gt; case class Person(name: String, age: Double)
defined class Person
</pre></p><p>Imagine you are calculating the <code>age</code> values in such as way that occasionally tests
are failing because of rounding differences that you actually don't care about. For example, you
expect an age of 29.0, but you're sometimes seeing 29.0001:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TypeCheckedTripleEquals._
import TypeCheckedTripleEquals._

scala&gt; Person("Joe", 29.0001) === Person("Joe", 29.0)
res0: Boolean = false
</pre></p><p>The <code>===</code> operator of <code>TypeCheckedTripleEquals</code> looks for an implicit
<code>Equivalence[SUPER]</code>, where <code>SUPER</code> is either the left-hand or right-hand type, whichever
one is a supertype of the other. In this case, both sides are <code>Person</code> (which is considered a supertype of
itself), so the compiler will look for an <code>Equivalence[Person]</code>.
Because you didn't specifically provide an implicit <code>Equivalence[Person]</code>, <code>===</code> will fall back on
<a href="Equality.html#defaultEquality">default equality</a>, because an <code>Equality[Person]</code> <em>is-an</em>
<code>Equivalence[Person]</code>. The default <code>Equality[Person]</code> will call <code>Person</code>'s
<code>equals</code> method. That <code>equals</code> method, provided by the Scala compiler
because <code>Person</code> is a case class, will declare these two objects unequal because 29.001 does not
exactly equal 29.0.</p><p>To make the equality check more forgiving, you could define an implicit <code>Equivalence[Person]</code> that compares
the <code>age</code> <code>Double</code>s with a tolerance, like this:</p><p><pre class="stREPL">
scala&gt; import Tolerance._
import Tolerance._

scala&gt; implicit val personEq =
     |   new Equivalence[Person] {
     |     def areEquivalent(a: Person, b: Person): Boolean =
     |       a.name == b.name &amp;&amp; a.age === b.age +- 0.0002
     |   }
personEq: org.scalactic.Equivalence[Person] = $anon$1@7892bd8
</pre></p><p>Now the <code>===</code> operator will use your more forgiving <code>Equivalence[Person]</code> for the
equality check instead of default equality:</p><p><pre class="stREPL">
scala&gt; Person("Joe", 29.0001) === Person("Joe", 29.0)
res1: Boolean = true
</pre></p></div></div></li><li class="indented0 " name="org.scalactic.ErrorMessage" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ErrorMessage=String"></a><a id="ErrorMessage:ErrorMessage"></a> <span class="permalink"><a href="../../org/scalactic/index.html#ErrorMessage=String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">type</span></span> <span class="symbol"><span class="name">ErrorMessage</span><span class="result alias"> = <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span></span><p class="shortcomment cmt">Type alias for <code>String</code>.</p></li><li class="indented0 " name="org.scalactic.Every" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="Every[+T]extendsPartialFunction[Int,T]withProductwithSerializable"></a><a id="Every[+T]:Every[T]"></a> <span class="permalink"><a href="../../org/scalactic/Every.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">sealed abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="Every.html" title="An ordered, immutable, non-empty collection of elements."><span class="name">Every</span></a><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span name="scala.PartialFunction" class="extype">PartialFunction</span>[<span name="scala.Int" class="extype">Int</span>, <span name="org.scalactic.Every.T" class="extype">T</span>] with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">An ordered, immutable, non-empty collection of elements.</p><div class="fullcomment"><div class="comment cmt"><p>An ordered, immutable, non-empty collection of elements.</p><p>Class <code>Every</code> has two and only two subtypes: <a href="One.html"><code>One</code></a> and <a href="Many.html"><code>Many</code></a>.
A <code>One</code> contains exactly one element. A <code>Many</code> contains two or more elements. Thus no way exists for an
<code>Every</code> to contain zero elements.</p><h4> Constructing <code>Every</code>s </h4><p>You can construct an <code>Every</code> by passing one or more elements to the <code>Every.apply</code> factory method:</p><p><pre class="stHighlight">
Every(1)
Every(1, 2)
Every(1, 2, 3)
</pre></p><p>Alternatively you can pass one element to the <code>One.apply</code> factory method, or two or more elements to
<code>Many.apply</code>:</p><p><pre class="stHighlight">
One(1)
Many(1, 3)
Many(1, 2, 3)
</pre></p><h4> Working with <code>Every</code>s </h4><p><code>Every</code> does not extend Scala's <code>Seq</code> or <code>Traversable</code> traits because these require that
implementations may be empty. For example, if you invoke <code>tail</code> on a <code>Seq</code> that contains just one element,
you'll get an empty <code>Seq</code>:</p><p><pre class="stREPL">
scala&gt; List(1).tail
res6: List[Int] = List()
</pre></p><p>On the other hand, many useful methods exist on <code>Seq</code> that when invoked on a non-empty <code>Seq</code> are guaranteed
to not result in an empty <code>Seq</code>. For convenience, <code>Every</code> defines a method corresponding to every such <code>Seq</code>
method. Here are some examples:</p><p><pre class="stHighlight">
Many(1, 2, 3).map(_ + 1)                  // Result: Many(2, 3, 4)
One(1).map(_ + 1)                         // Result: One(2)
Every(1, 2, 3).containsSlice(Every(2, 3)) // Result: true
Every(1, 2, 3).containsSlice(Every(3, 4)) // Result: false
Every(-1, -2, 3, 4, 5).minBy(_.abs)       // Result: -1
</pre></p><p><code>Every</code> does <em>not</em> currently define any methods corresponding to <code>Seq</code> methods that could result in
an empty <code>Seq</code>. However, an implicit converison from <code>Every</code> to <code>collection.immutable.IndexedSeq</code>
is defined in the <code>Every</code> companion object that will be applied if you attempt to call one of the missing methods. As a
result, you can invoke <code>filter</code> on an <code>Every</code>, even though <code>filter</code> could result
in an empty sequence&mdash;but the result type will be <code>collection.immutable.IndexedSeq</code> instead of <code>Every</code>:</p><p><pre class="stHighlight">
Every(1, 2, 3).filter(_ &lt; 10) // Result: Vector(1, 2, 3)
Every(1, 2, 3).filter(_ &gt; 10) // Result: Vector()
</pre></p><p>You can use <code>Every</code>s in <code>for</code> expressions. The result will be an <code>Every</code> unless
you use a filter (an <code>if</code> clause). Because filters are desugared to invocations of <code>filter</code>, the
result type will switch to a <code>collection.immutable.IndexedSeq</code> at that point. Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; for (i &lt;- Every(1, 2, 3)) yield i + 1
res0: org.scalactic.Every[Int] = Many(2, 3, 4)

scala&gt; for (i &lt;- Every(1, 2, 3) if i &lt; 10) yield i + 1
res1: scala.collection.immutable.IndexedSeq[Int] = Vector(2, 3, 4)

scala&gt; for {
     |   i &lt;- Every(1, 2, 3)
     |   j &lt;- Every('a', 'b', 'c')
     | } yield (i, j)
res3: org.scalactic.Every[(Int, Char)] =
        Many((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))

scala&gt; for {
     |   i &lt;- Every(1, 2, 3) if i &lt; 10
     |   j &lt;- Every('a', 'b', 'c')
     | } yield (i, j)
res6: scala.collection.immutable.IndexedSeq[(Int, Char)] =
        Vector((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))
</pre></p><h4> Motivation for <code>Every</code>s </h4><p>Although <code>Every</code> is a general-purpose, non-empty ordered collection, it was motivated by the desire to enable easy
accumulation of errors in <a href="Or.html"><code>Or</code></a>s. For examples of <code>Every</code> used in that use case, see the
<a href="Or.html#accumulatingErrors">Accumulating errors with <code>Or</code></a> section in the main documentation for <code>Or</code>.</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the type of elements contained in this <code>Every</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Explicitly" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="ExplicitlyextendsAnyRef"></a><a id="Explicitly:Explicitly"></a> <span class="permalink"><a href="../../org/scalactic/Explicitly.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Explicitly.html" title="Provides ScalaTest's &amp;ldquo;explicitly DSL,&amp;rdquo; which facilitates the explicit specification of an Equality[T] or a Uniformity[T] where Equality[T] is taken implicitly."><span class="name">Explicitly</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Provides ScalaTest's &ldquo;explicitly DSL,&rdquo; which facilitates the
explicit specification of an <code>Equality[T]</code> or a <code>Uniformity[T]</code> where
<code>Equality[T]</code> is taken implicitly.</p><div class="fullcomment"><div class="comment cmt"><p>Provides ScalaTest's &ldquo;explicitly DSL,&rdquo; which facilitates the
explicit specification of an <code>Equality[T]</code> or a <code>Uniformity[T]</code> where
<code>Equality[T]</code> is taken implicitly.</p><p>The Explicitly DSL can be used with the <code>===</code> and <code>!==</code> operators of Scalactic
as well as the <code>should</code> <code>equal</code>, <code>be</code>, <code>contain</code>, and
<code>===</code> syntax of ScalaTest matchers.</p><p>If you want to customize equality for a type in general, you would likely want to place an
implicit <code>Equality[T]</code> for that type in scope (or in <code>T</code>'s companion object). That implicit
equality definition will then be picked
up and used when that type is compared for equality with the <code>equal</code>, <code>be</code>, and
<code>contain</code> matchers in ScalaTest tests and with
<code>===</code> in both tests and production code.
If you just want to use a custom equality for a single comparison, however, you may prefer to pass it explicitly. For
example, if you have an implicit
<code>Equality[String]</code> in scope, you can force a comparison to use the default equality with this syntax:</p><p><pre class="stHighlighted">
<span class="stLineComment">// In production code:</span>
<span class="stReserved">if</span> ((result === <span class="stQuotedString">"hello"</span>)(decided by defaultEquality)) <span class="stReserved">true</span> <span class="stReserved">else</span> <span class="stReserved">false</span>
<br/><span class="stLineComment">// In tests:</span>
result should equal (<span class="stQuotedString">"hello"</span>) (decided by defaultEquality)
</pre></p><p>The explicitly DSL also provides support for specifying a one-off equality that is based on a normalization. For
example, Scalactic offers a <a href="StringNormalizations.html"><code>StringNormalizations</code></a> trait that
provides methods such as <code>trimmed</code> and <code>lowerCased</code> that return
<code>Normalization[String]</code> instances that normalize by trimming and lower-casing, respectively. If you bring
those into scope by mixing in or importing the members of <code>StringNormalizations</code>, you could use the
explicitly DSL like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// In production code:</span>
<span class="stReserved">if</span> ((result === <span class="stQuotedString">"hello"</span>)(after being lowerCased)) <span class="stReserved">true</span> <span class="stReserved">else</span> <span class="stReserved">false</span>
<br/><span class="stLineComment">// In tests:</span>
result should equal (<span class="stQuotedString">"hello"</span>) (after being lowerCased and trimmed)
</pre></p><p>If you prefer not to use English-like DSLs in your production code, you can alternatively
not use the <code>Explicitly</code> trait and instead write:</p><p><pre class="stHighlighted">
<span class="stLineComment">// To explicitly specify an Equality instance, just specify it:</span>
<span class="stReserved">if</span> ((result === <span class="stQuotedString">"hello"</span>)(Equality.default)) <span class="stReserved">true</span> <span class="stReserved">else</span> <span class="stReserved">false</span>
<br/><span class="stLineComment">// To base an Equality instance on a Uniformity, just</span>
<span class="stLineComment">// call toEquality on it:</span>
<span class="stReserved">if</span> ((result === <span class="stQuotedString">"hello"</span>)(lowerCased.toEquality)) <span class="stReserved">true</span> <span class="stReserved">else</span> <span class="stReserved">false</span>
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.Fail" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Fail[E]extendsValidation[E]withProductwithSerializable"></a><a id="Fail[E]:Fail[E]"></a> <span class="permalink"><a href="../../org/scalactic/Fail.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="Fail.html" title="Indicates a validation failed, describing the failure with a contained error value."><span class="name">Fail</span></a><span class="tparams">[<span name="E">E</span>]</span><span class="params">(<span name="error">error: <span name="org.scalactic.Fail.E" class="extype">E</span></span>)</span><span class="result"> extends <a href="Validation.html" name="org.scalactic.Validation" id="org.scalactic.Validation" class="extype">Validation</a>[<span name="org.scalactic.Fail.E" class="extype">E</span>] with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Indicates a validation failed, describing the failure with a contained error value.</p><div class="fullcomment"><div class="comment cmt"><p>Indicates a validation failed, describing the failure with a contained error value.
</p></div><dl class="paramcmts block"><dt class="tparam">E</dt><dd class="cmt"><p>the type of value describing a validation failure for this <code>Fail</code></p></dd><dt class="param">error</dt><dd class="cmt"><p>an error value describing the validation failure</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.FutureSugar" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="FutureSugarextendsAnyRef"></a><a id="FutureSugar:FutureSugar"></a> <span class="permalink"><a href="../../org/scalactic/FutureSugar.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="FutureSugar.html" title="Trait providing an implicit class that adds a validating method to Future, which takes one or more validation functions and returns either the same Future if either the Future had already failed or its value passes all the functions, or ValidationFailedException containing an error message describing the first validation that failed."><span class="name">FutureSugar</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Trait providing an implicit class that adds a <code>validating</code> method to
<code>Future</code>, which takes one or more validation functions and returns either the
same <code>Future</code> if either the <code>Future</code> had already failed or its value
passes all the functions, or <a href="exceptions/ValidationFailedException.html" name="org.scalactic.exceptions.ValidationFailedException" id="org.scalactic.exceptions.ValidationFailedException" class="extype"><code>ValidationFailedException</code></a> containing an error message
describing the first validation that failed.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing an implicit class that adds a <code>validating</code> method to
<code>Future</code>, which takes one or more validation functions and returns either the
same <code>Future</code> if either the <code>Future</code> had already failed or its value
passes all the functions, or <a href="exceptions/ValidationFailedException.html" name="org.scalactic.exceptions.ValidationFailedException" id="org.scalactic.exceptions.ValidationFailedException" class="extype"><code>ValidationFailedException</code></a> containing an error message
describing the first validation that failed.</p><p>Here's an example validation method, which passes if the given <code>Int</code> is evenly
divisible by 10 (<em>i.e.</em>, the result will be <a href="Pass$.html" name="org.scalactic.Pass" id="org.scalactic.Pass" class="extype"><code>Pass</code></a>). If the value does not pass
this test, the result is a <a href="Fail.html" name="org.scalactic.Fail" id="org.scalactic.Fail" class="extype"><code>Fail</code></a> containing a helpful error message string.</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import FutureSugar._
import org.scalactic.FutureSugar._

scala&gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&gt; import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.ExecutionContext.Implicits.global

scala&gt; def isRound(i: Int): Validation[ErrorMessage] =
     |   if (i % 10 == 0) Pass else Fail(i + " was not a round number")
isRound: (i: Int)org.scalactic.Validation[org.scalactic.ErrorMessage]
</pre></p><p>Validation will be attempted on a successful <code>Try</code>. If the validation succeeds, the
resulting <code>Future</code> will be the same successful <code>Future</code> with the same value. (A
"validation" only transforms the <code>Future</code> if the validation fails, otherwise it is the
same <code>Future</code>. The only difference is its value has now been proven <em>valid</em>.)
In the following example, a successful <code>Future[Int]</code> with the value 100
passes the validation (which checks whether 100 is evenly divisible by 10), therefore
the result of the <code>validating</code> call is the same successful <code>Future</code>
with the same value.</p><p><pre class="stREPL">
scala&gt; val fut100 = Future(100)
fut100: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@67f9c9c6

scala&gt; fut100.value
res0: Option[scala.util.Try[Int]] = Some(Success(100))

scala&gt; val round100 = fut100.validating(isRound)
round100: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@1ac2f0d1

scala&gt; round100.value
res1: Option[scala.util.Try[Int]] = Some(Success(100))
</pre></p><p>If validation fails, the successful <code>Future</code> will be transformed into a failed one, with
a <code>ValidationFailedException</code> that contains the error message
returned by the validation function. In the following example, 42 fails the validation because it
is not evenly divisible by 10:</p><p><pre class="stREPL">
scala&gt; val fut42 = Future(42)
fut42: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@19c6e4d1

scala&gt; fut42.value
res2: Option[scala.util.Try[Int]] = Some(Success(42))

scala&gt; val round42 = fut42.validating(isRound)
round42: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@b5175d

scala&gt; round42.value
res3: Option[scala.util.Try[Int]] = Some(Failure(org.scalactic.exceptions.ValidationFailedException: 42 was not a round number))
</pre></p><p>If <code>validating</code> is called on a failed <code>Future</code>, it just returns the same failed <code>Future</code>:</p><p><pre class="stREPL">
scala&gt; val futEx = Future[Int] { throw new Exception("oops!") }
futEx: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@3ba0299c

scala&gt; futEx.value
res4: Option[scala.util.Try[Int]] = Some(Failure(java.lang.Exception: oops!))

scala&gt; val roundEx = futEx.validating(isRound)
roundEx: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@22bf1acf

scala&gt; roundEx.value
res5: Option[scala.util.Try[Int]] = Some(Failure(java.lang.Exception: oops!))
</pre></p><p>The <code>validating</code> method accepts one or more validation functions. If you
pass more than one, they will be tried in order up until the first failure, whose
error message will appear in the <code>ValidationFailedException</code>. In other words,
<code>validating</code> will short circuit at the first error and return that. It
will not accumulate errors. For example, the following validation will short circuit
after the <code>isDivBy3</code> function fails:</p><p><pre class="stREPL">
scala&gt; def isDivBy3(i: Int): Validation[ErrorMessage] =
     |   if (i % 3 == 0) Pass else Fail(i + " was not divisible by 3")
isDivBy3: (i: Int)org.scalactic.Validation[org.scalactic.ErrorMessage]

scala&gt; def isAnswerToLifeTheUniverseAndEverything(i: Int): Validation[ErrorMessage] =
     |   if (i == 42) Pass else Fail(i + " did not equal 42")
isAnswerToLifeTheUniverseAndEverything: (i: Int)org.scalactic.Validation[org.scalactic.ErrorMessage]

scala&gt; val futShort = fut100.validating(isRound, isDivBy3, isAnswerToLifeTheUniverseAndEverything)
futShort: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@30bb943e

scala&gt; futShort.value
res11: Option[scala.util.Try[Int]] = Some(Failure(org.scalactic.exceptions.ValidationFailedException: 100 was not divisible by 3))
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.Good" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Good[+G]extendsOr[G,Nothing]withProductwithSerializable"></a><a id="Good[+G]:Good[G]"></a> <span class="permalink"><a href="../../org/scalactic/Good.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">case class</span></span> <span class="symbol"><a href="Good.html" title="Contains a &amp;ldquo;good&amp;rdquo; value."><span class="name">Good</span></a><span class="tparams">[<span name="G">+G</span>]</span><span class="params">(<span name="g">g: <span name="org.scalactic.Good.G" class="extype">G</span></span>)</span><span class="result"> extends <a href="Or.html" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Good.G" class="extype">G</span>, <span name="scala.Nothing" class="extype">Nothing</span>] with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Contains a &ldquo;good&rdquo; value.</p><div class="fullcomment"><div class="comment cmt"><p>Contains a &ldquo;good&rdquo; value.</p><p>You can decide what &ldquo;good&rdquo; means, but it is expected <code>Good</code> will be commonly used
to hold valid results for processes that may fail with an error instead of producing a valid result.</p></div><dl class="paramcmts block"><dt class="param">g</dt><dd class="cmt"><p>the &ldquo;good&rdquo; value</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.LowPriorityTypeCheckedConstraint" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="LowPriorityTypeCheckedConstraintextendsTripleEqualsSupport"></a><a id="LowPriorityTypeCheckedConstraint:LowPriorityTypeCheckedConstraint"></a> <span class="permalink"><a href="../../org/scalactic/LowPriorityTypeCheckedConstraint.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="LowPriorityTypeCheckedConstraint.html" title="Provides an implicit conversion that will be applied only if a higher-priority implicit conversion declared a subtrait is not applicable."><span class="name">LowPriorityTypeCheckedConstraint</span></a><span class="result"> extends <a href="TripleEqualsSupport.html" name="org.scalactic.TripleEqualsSupport" id="org.scalactic.TripleEqualsSupport" class="extype">TripleEqualsSupport</a></span></span><p class="shortcomment cmt">Provides an implicit conversion that will be applied only if a higher-priority implicit conversion declared a subtrait
is not applicable.</p><div class="fullcomment"><div class="comment cmt"><p>Provides an implicit conversion that will be applied only if a higher-priority implicit conversion declared a subtrait
is not applicable.</p><p>The purpose of this trait is to make the <code>===</code> operator symetric. In other words, a <code>===</code> invocation
will be allowed if subtype relationship exists in either direction. For example, in the following expression, the left hand
side is a subtype of the right hand side:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) === <span class="stType">Seq</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>But in the next expression, it the right hand side is a subtype of the left hand side</p><p><pre class="stHighlighted">
<span class="stType">Seq</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>) === <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>The first expression above is enabled by the implicit conversion <code>typeCheckedConstraint</code> in trait
<a href="TypeCheckedTripleEquals.html"><code>TypeCheckedTripleEquals</code></a>.
The second expression above is
enabled by the implicit conversion <code>lowPriorityTypeCheckedConstraint</code> in this trait.</p><p>The reason these two implicit methods aren't both declared in the subtraits is
that if the subtype relationship existed in both directions, they would conflict. This can happen when the exact same type is on both
the left and right hand sides, because a type is a subtype of itself. By placing one of them in this supertrait, the higher
priority conversion will be selected.</p></div></div></li><li class="indented0 " name="org.scalactic.Many" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Many[+T]extendsEvery[T]withProductwithSerializable"></a><a id="Many[+T]:Many[T]"></a> <span class="permalink"><a href="../../org/scalactic/Many.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">case class</span></span> <span class="symbol"><a href="Many.html" title="An Every that contains two or more elements."><span class="name">Many</span></a><span class="tparams">[<span name="T">+T</span>]</span><span class="params">(<span name="firstElement">firstElement: <span name="org.scalactic.Many.T" class="extype">T</span></span>, <span name="secondElement">secondElement: <span name="org.scalactic.Many.T" class="extype">T</span></span>, <span name="otherElements">otherElements: <span name="org.scalactic.Many.T" class="extype">T</span>*</span>)</span><span class="result"> extends <a href="Every.html" name="org.scalactic.Every" id="org.scalactic.Every" class="extype">Every</a>[<span name="org.scalactic.Many.T" class="extype">T</span>] with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">An <code>Every</code> that contains two or more elements.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>Every</code> that contains two or more elements.</p><p>For more information and examples, see the main documentation for superclass <a href="Every.html"><code>Every</code></a>.</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the type of the element contained in this <code>Many</code></p></dd><dt class="param">firstElement</dt><dd class="cmt"><p>the first element (with index 0) contained in this <code>Many</code></p></dd><dt class="param">secondElement</dt><dd class="cmt"><p>the second element (with index 1) contained in this <code>Many</code></p></dd><dt class="param">otherElements</dt><dd class="cmt"><p>a varargs of zero or more other elements (with index 2, 3, ...) contained in this <code>Many</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.MapEqualityConstraints" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="MapEqualityConstraintsextendsAnyRef"></a><a id="MapEqualityConstraints:MapEqualityConstraints"></a> <span class="permalink"><a href="../../org/scalactic/MapEqualityConstraints.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="MapEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Maps to one that more closely matches Scala's approach to Map equality."><span class="name">MapEqualityConstraints</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Provides an implicit method that loosens the equality constraint defined by <code>TypeCheckedTripleEquals</code> or <code>ConversionCheckedTripleEquals</code>
for Scala <code>Map</code>s to one that more closely matches Scala's approach to <code>Map</code> equality.</p><div class="fullcomment"><div class="comment cmt"><p>Provides an implicit method that loosens the equality constraint defined by <code>TypeCheckedTripleEquals</code> or <code>ConversionCheckedTripleEquals</code>
for Scala <code>Map</code>s to one that more closely matches Scala's approach to <code>Map</code> equality.</p><p>Scala's approach to <code>Map</code> equality is that if both objects being compared are <code>Map</code>s, the elements are compared to determine equality.
This means you could compare an immutable <code>TreeMap</code> and a mutable <code>HashMap</code> for equality, for instance, and get true so long as the two maps
contained the same key-value mappings. Here's an example:</p><p><pre class="stREPL">
scala&gt; import scala.collection.immutable.TreeMap
import scala.collection.immutable.TreeMap

scala&gt; import scala.collection.mutable.HashMap
import scala.collection.mutable.HashMap

scala&gt; TreeMap("one" -&gt; 1, "two" -&gt; 2) == HashMap("one" -&gt; 1, "two" -&gt; 2)
res0: Boolean = true
</pre></p><p>Such a comparison would not, however, compile if you used <code>===</code> under either <code>TypeCheckedTripleEquals</code> or <code>ConversionCheckedTripleEquals</code>,
because <code>TreeMap</code> and <code>HashMap</code> are not in a subtype/supertype relationship, nor does an implicit conversion by default exist between them:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TypeCheckedTripleEquals._
import TypeCheckedTripleEquals._

scala&gt; TreeMap("one" -&gt; 1, "two" -&gt; 2) === HashMap("one" -&gt; 1, "two" -&gt; 2)
&lt;console&gt;:16: error: types scala.collection.immutable.TreeMap[String,Int] and
  scala.collection.mutable.HashMap[String,Int] do not adhere to the equality constraint selected for
  the === and !== operators; the missing implicit parameter is of type
  org.scalactic.EqualityConstraint[scala.collection.immutable.TreeMap[String,Int],
  scala.collection.mutable.HashMap[String,Int]]
              TreeMap("one" -&gt; 1, "two" -&gt; 2) === HashMap("one" -&gt; 1, "two" -&gt; 2)
                                              ^
</pre></p><p>If you mix or import the implicit conversion provided by <code>MapEqualityConstraint</code>, however, the comparison will be allowed:</p><p><pre class="stREPL">
scala&gt; import MapEqualityConstraints._
import MapEqualityConstraints._

scala&gt; TreeMap("one" -&gt; 1, "two" -&gt; 2) === HashMap("one" -&gt; 1, "two" -&gt; 2)
res2: Boolean = true
</pre></p><p>The equality constraint provided by this trait requires that both left and right sides are subclasses of <code>scala.collection.GenMap</code> and that
an <code>EqualityConstraint</code> can be found for both key types and both value types. In the example above, both the <code>TreeMap</code> and
<code>HashMap</code> are subclasses of <code>scala.collection.GenMap</code>, and the regular <code>TypeCheckedTripleEquals</code> provides equality
constraints for the key types, both of which are <code>String</code>, and value types, both of which are <code>Int</code>. By contrast, this
trait would not allow a <code>TreeMap[String, Int]</code> to be compared against a <code>HashMap[String, java.util.Date]</code>, because no equality constraint
will exist between the value types <code>Int</code> and <code>Date</code>:</p><p><pre class="stREPL">
scala&gt; import java.util.Date
import java.util.Date

scala&gt; TreeMap("one" -&gt; 1, "two" -&gt; 2) === HashMap("one" -&gt; new Date, "two" -&gt; new Date)
&lt;console&gt;:20: error: types scala.collection.immutable.TreeMap[String,Int] and
  scala.collection.mutable.HashMap[String,java.util.Date] do not adhere to the equality constraint selected for
  the === and !== operators; the missing implicit parameter is of type
  org.scalactic.EqualityConstraint[scala.collection.immutable.TreeMap[String,Int],
  scala.collection.mutable.HashMap[String,java.util.Date]]
              TreeMap("one" -&gt; 1, "two" -&gt; 2) === HashMap("one" -&gt; new Date, "two" -&gt; new Date)
                                              ^
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.NormMethods" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="NormMethodsextendsAnyRef"></a><a id="NormMethods:NormMethods"></a> <span class="permalink"><a href="../../org/scalactic/NormMethods.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="NormMethods.html" title="Provides an implicit conversion that allows norm to be invoked on any value of type T for which an implicit Normalization[T] exists."><span class="name">NormMethods</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Provides an implicit conversion that allows <code>norm</code> to be invoked on any value of type
<code>T</code> for which an implicit <code>Normalization[T]</code> exists.</p><div class="fullcomment"><div class="comment cmt"><p>Provides an implicit conversion that allows <code>norm</code> to be invoked on any value of type
<code>T</code> for which an implicit <code>Normalization[T]</code> exists.</p><p>Here's an example:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import StringNormalizations._
import StringNormalizations._

scala&gt; implicit val stringNormalization = lowerCased and trimmed
stringNormalization: org.scalactic.Uniformity[String] = org.scalactic.Uniformity$$anon$1@19ba67ec

scala&gt; import NormMethods._
import NormMethods._

scala&gt; val s = " There "
s: String = " There "

scala&gt; "Hey " + s + "!"
res5: String = Hey  There !

scala&gt; "Hey " + s.norm + "!"
res6: String = Hey there!
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.Normalization" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="Normalization[A]extendsAnyRef"></a><a id="Normalization[A]:Normalization[A]"></a> <span class="permalink"><a href="../../org/scalactic/Normalization.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Normalization.html" title="Defines a custom way to normalize instances of a type."><span class="name">Normalization</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Defines a custom way to normalize instances of a type.</p><div class="fullcomment"><div class="comment cmt"><p>Defines a custom way to normalize instances of a type.</p><p>For example, to normalize <code>Double</code>s by truncating off any decimal part,
you might write:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalactic._
<br/><span class="stReserved">val</span> truncated =
  <span class="stReserved">new</span> <span class="stType">Normalization[Double]</span> {
   <span class="stReserved">def</span> normalized(d: <span class="stType">Double</span>) = d.floor
 }
</pre></p><p>Given this definition you could use it with the <a href="Explicitly.html"><code>Explicitly</code></a> DSL like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> Matchers._
<span class="stReserved">import</span> TypeCheckedTripleEquals._
<br/>(<span class="stLiteral">2.1</span> should === (<span class="stLiteral">2.0</span>)) (after being truncated)
</pre></p><p>Note that to use a <code>Normalization</code> with the <code>Explicitly</code> DSL, you'll need to use
<a href="TypeCheckedTripleEquals.html"><code>TypeCheckedTripleEquals</code></a>.
If you're just using plain-old
<a href="TripleEquals.html"><code>TripleEquals</code></a>, you'll need a <a href="Uniformity.html"><code>Uniformity</code></a>, a <code>Normalization</code> subclass.</p><p>If you make the <code>truncated</code> <code>val</code> implicit and import or mix in the members of <a href="NormMethods.html"><code>NormMethods</code></a>,
you can access the behavior by invoking <code>.norm</code> on <code>Double</code>s.</p><p><pre class="stHighlighted">
<span class="stReserved">implicit</span> <span class="stReserved">val</span> doubleNormalization = truncated
<span class="stReserved">import</span> NormMethods._
<br/><span class="stReserved">val</span> d = <span class="stLiteral">2.1</span>
d.norm <span class="stLineComment">// returns 2.0</span>
</pre>
</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>the type whose normalization is being defined</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.NormalizingEquality" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="NormalizingEquality[A]extendsEquality[A]"></a><a id="NormalizingEquality[A]:NormalizingEquality[A]"></a> <span class="permalink"><a href="../../org/scalactic/NormalizingEquality.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="NormalizingEquality.html" title="An Equality[A] implementation that determines the equality of two objects by normalizing one or both objects, then comparing the results using an &amp;ldquo;after normalization&amp;rdquo; equality referenced from the afterNormalizationEquality  member."><span class="name">NormalizingEquality</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <a href="Equality.html" name="org.scalactic.Equality" id="org.scalactic.Equality" class="extype">Equality</a>[<span name="org.scalactic.NormalizingEquality.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">An <code>Equality[A]</code> implementation that determines the equality of two objects by normalizing
one or both objects, then comparing the results using an &ldquo;after normalization&rdquo; equality referenced from
the <code>afterNormalizationEquality</code>  member.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>Equality[A]</code> implementation that determines the equality of two objects by normalizing
one or both objects, then comparing the results using an &ldquo;after normalization&rdquo; equality referenced from
the <code>afterNormalizationEquality</code>  member. By default, the <code>afterNormalizationEquality</code> is
an instance of <a href="Equality$.html"><code>Equality.default[A]</code></a>.</p><p><code>NormalizingEquality</code> is returned by the <code>Explicitly</code> DSL's &ldquo;<code>after</code> <code>being</code>&rdquo;
syntax, using for the <code>afterNormalizationEquality</code> the implicit <code>Equality</code> in scope for the type
of <code>Uniformity</code> passed to <code>being</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import Explicitly._
import Explicitly._

scala&gt; import StringNormalizations._
import StringNormalizations._

scala&gt; after being lowerCased
res0: org.scalactic.NormalizingEquality[String] = ComposedNormalizingEquality(Equality.default,lowerCased)
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.NormalizingEquivalence" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="NormalizingEquivalence[A]extendsEquivalence[A]"></a><a id="NormalizingEquivalence[A]:NormalizingEquivalence[A]"></a> <span class="permalink"><a href="../../org/scalactic/NormalizingEquivalence.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="NormalizingEquivalence.html" title="An Equivalence[A] implementation that determines the equality of two objects by normalizing one or both objects, then comparing the results using an &amp;ldquo;after normalization&amp;rdquo; Equivalence referenced from the afterNormalizationEquivalence  member."><span class="name">NormalizingEquivalence</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <a href="Equivalence.html" name="org.scalactic.Equivalence" id="org.scalactic.Equivalence" class="extype">Equivalence</a>[<span name="org.scalactic.NormalizingEquivalence.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">An <code>Equivalence[A]</code> implementation that determines the equality of two objects by normalizing
one or both objects, then comparing the results using an &ldquo;after normalization&rdquo; <code>Equivalence</code> referenced from
the <code>afterNormalizationEquivalence</code>  member.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>Equivalence[A]</code> implementation that determines the equality of two objects by normalizing
one or both objects, then comparing the results using an &ldquo;after normalization&rdquo; <code>Equivalence</code> referenced from
the <code>afterNormalizationEquivalence</code>  member. By default, the <code>afterNormalizationEquivalence</code> is
an instance of <a href="Equivalence$.html"><code>Equivalence.default[A]</code></a>.</p><p><code>NormalizingEquivalence</code> is returned by the <code>Explicitly</code> DSL's &ldquo;<code>after</code> <code>being</code>&rdquo;
syntax, using for the <code>afterNormalizationEquivalence</code> the implicit <code>Equivalence</code> in scope for the type
of <code>Normalization</code> passed to <code>being</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import Explicitly._
import Explicitly._

scala&gt; val lowerCased: Normalization[String] = StringNormalizations.lowerCased
lowerCased: org.scalactic.Normalization[String] = lowerCased

scala&gt; after being lowerCased
res0: org.scalactic.NormalizingEquivalence[String] = ComposedNormalizingEquivalence(Equality.default,lowerCased)
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.One" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="One[+T]extendsEvery[T]withProductwithSerializable"></a><a id="One[+T]:One[T]"></a> <span class="permalink"><a href="../../org/scalactic/One.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">case class</span></span> <span class="symbol"><a href="One.html" title="An Every that contains exactly one element."><span class="name">One</span></a><span class="tparams">[<span name="T">+T</span>]</span><span class="params">(<span name="loneElement">loneElement: <span name="org.scalactic.One.T" class="extype">T</span></span>)</span><span class="result"> extends <a href="Every.html" name="org.scalactic.Every" id="org.scalactic.Every" class="extype">Every</a>[<span name="org.scalactic.One.T" class="extype">T</span>] with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">An <code>Every</code> that contains exactly one element.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>Every</code> that contains exactly one element.</p><p>For more information and examples, see the main documentation for superclass <a href="Every.html"><code>Every</code></a>.</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the type of the element contained in this <code>One</code></p></dd><dt class="param">loneElement</dt><dd class="cmt"><p>the lone element contained in this <code>One</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.OptionSugar" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="OptionSugarextendsAnyRef"></a><a id="OptionSugar:OptionSugar"></a> <span class="permalink"><a href="../../org/scalactic/OptionSugar.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="OptionSugar.html" title="Trait providing an implicit class that adds a toOr method to Option, which converts Some to Good, None to Bad."><span class="name">OptionSugar</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Trait providing an implicit class that adds a <code>toOr</code> method to
<code>Option</code>, which converts <code>Some</code> to <code>Good</code>,
<code>None</code> to <code>Bad</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing an implicit class that adds a <code>toOr</code> method to
<code>Option</code>, which converts <code>Some</code> to <code>Good</code>,
<code>None</code> to <code>Bad</code>.</p><p>You can use the <code>toOr</code> method to record information about why
a processing of nested <code>Option</code>s resulted in <code>None</code>.
For example, the following <code>for</code> expression results in
<code>None</code> if either the passed optional <code>Person</code> is
<code>None</code> or else if the contained optional age is <code>None</code>:</p><p><pre class="stREPL">
scala&gt; case class Person(name: String, age: Option[Int])
defined class Person

scala&gt; def ageOf(person: Option[Person]) =
     |   for {
     |     per &lt;- person
     |     age &lt;- per.age
     |   } yield age
ageOf: (person: Option[Person])Option[Int]

scala&gt; ageOf(Some(Person("Ralph", Some(32))))
res0: Option[Int] = Some(32)

scala&gt; ageOf(Some(Person("Curt", None)))
res3: Option[Int] = None

scala&gt; ageOf(None)
res2: Option[Int] = None
</pre></p><p>If you instead populate the <code>for</code> expression with <code>Or</code>s,
supplying an error message or other "bad" value to the <code>toOr</code> method
in case of <code>None</code>, you'll get an indication of which part
failed if a <code>None</code> is encountered:</p><p><pre class="stREPL">
scala&gt; import OptionSugar._
import OptionSugar._

scala&gt; def ageOf(person: Option[Person]) =
     |   for {
     |     per &lt;- person toOr "no person here"
     |     age &lt;- per.age toOr "ageless person"
     |   } yield age
ageOf: (person: Option[Person])org.scalactic.Or[Int,String]

scala&gt; ageOf(Some(Person("Ralph", Some(32))))
res1: org.scalactic.Or[Int,String] = Good(32)

scala&gt; ageOf(Some(Person("Curt", None)))
res2: org.scalactic.Or[Int,String] = Bad(ageless person)

scala&gt; ageOf(None)
res3: org.scalactic.Or[Int,String] = Bad(no person here)
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.Or" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="Or[+G,+B]extendsProductwithSerializable"></a><a id="Or[+G,+B]:Or[G,B]"></a> <span class="permalink"><a href="../../org/scalactic/Or.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">sealed abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="Or.html" title="Represents a value that is one of two possible types, with one type being &amp;ldquo;good&amp;rdquo; and the other &amp;ldquo;bad.&amp;rdquo;"><span class="name">Or</span></a><span class="tparams">[<span name="G">+G</span>, <span name="B">+B</span>]</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Represents a value that is one of two possible types, with one type being &ldquo;good&rdquo; and
the other &ldquo;bad.&rdquo;</p><div class="fullcomment"><div class="comment cmt"><p>Represents a value that is one of two possible types, with one type being &ldquo;good&rdquo; and
the other &ldquo;bad.&rdquo;</p><p>An <code>Or</code> will either be a &ldquo;good&rdquo; value wrapped in an instance of
<a href="Good.html"><code>Good</code></a> or a &ldquo;bad&rdquo; value wrapped in an instance
of <a href="Bad.html"><code>Bad</code></a>.</p><h4> The motivation for <code>Or</code> </h4><p><code>Or</code> differs from Scala's <code>Either</code> type in that
<code>Either</code> treats both its <code>Left</code> and <code>Right</code> alternatives in an identical manner, whereas
<code>Or</code> treats its two alternatives differently: it favors
<code>Good</code> over <code>Bad</code>.
Because of this, it is more convenient to work with <code>Or</code>s
when you prefer one alternative over the other; for example, if one alternative represents a valid result
and another represents an error.</p><p>To illustrate, imagine you want to create instances this <code>Person</code> class from user input strings:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Person</span>(name: <span class="stType">String</span>, age: <span class="stType">Int</span>)
</pre></p><p>You might write a method that parses the name from user input string and returns an
<code>Option[String]</code>: <code>None</code> if the string is empty or blank, else the
trimmed string wrapped in a <code>Some</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">Option[String]</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Some</span>(trimmed) <span class="stReserved">else</span> <span class="stType">None</span>
}
</pre></p><p>You might also write a method that parses the age from user input string and returns an
<code>Option[Int]</code>: <code>None</code> if either the string is not a valid integer or
it is a negative integer, else the string converted to an integer wrapped in a <code>Some</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Option[Int]</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Some</span>(age) <span class="stReserved">else</span> <span class="stType">None</span>
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">None</span>
  }
}
</pre></p><p>With these building blocks you could write a method that parses name and age input
strings and returns either a <code>Person</code>, wrapped in a <code>Some</code>, or
<code>None</code> if either the name or age, or both, was invalid:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Option[Person]</span> =
  <span class="stReserved">for</span> {
    name &lt;- parseName(inputName)
    age &lt;- parseAge(inputAge)
  } <span class="stReserved">yield</span> <span class="stType">Person</span>(name, age)
</pre></p><p>Here are some examples of invoking <code>parsePerson</code>:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Some(Person(Bridget Jones,29))</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: None</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: None</span>
<br/>parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: None</span>
</pre></p><p>Now imagine you want to give an error message back if the user's input is invalid.
You might rewrite the parsing methods to return an <code>Either</code> instead. In this
case, the desired result is a valid name or age, which by convention should be placed
on the right of the <code>Either</code>. The left will be a <code>String</code> error
message. Here's the new <code>parseName</code> function, which returns an <code>Either[String, String]</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">Either[String, String]</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Right</span>(trimmed) <span class="stReserved">else</span> <span class="stType">Left</span>(s<span class="stQuotedString">""""${input}" is not a valid name"""</span>)
}
</pre></p><p>And here's the new <code>parseAge</code> function, which returns an <code>Either[String, Int]</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Either[String, Int]</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Right</span>(age) <span class="stReserved">else</span> <span class="stType">Left</span>(s<span class="stQuotedString">""""${age}" is not a valid age"""</span>)
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">Left</span>(s<span class="stQuotedString">""""${input}" is not a valid integer"""</span>)
  }
}
</pre></p><p>The new <code>parsePerson</code> method will return an <code>Either[String, Person]</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Either[String, Person]</span> =
  <span class="stReserved">for</span> {
    name &lt;- parseName(inputName).right
    age &lt;- parseAge(inputAge).right
  } <span class="stReserved">yield</span> <span class="stType">Person</span>(name, age)
</pre></p><p>Note that <code>Either</code> requires you to add <code>.right</code>
at the end of each generator in the <code>for</code> expression. Although the convention is to place the
valid result on the right, you must explicitly (and repetitively) indicate that you've done so by transforming
the <code>Either</code> to a <code>RightProjection</code> by invoking <code>.right</code> at each step.
Given this implementation, the <code>parsePerson</code> method will now short-circuit at the first sign
of trouble (as it did when we used an <code>Option</code>), but you now get the first error message returned
in a <code>Left</code>. Here are some examples:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Right(Person(Bridget Jones,29))</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Left("" is not a valid integer)</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: Left("-29" is not a valid age)</span>
<br/>parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Left("" is not a valid name)</span>
</pre></p><h4> An <code>Either</code> with &ldquo;attitude&rdquo; </h4><p>Because <code>Or</code> declares one alternative to be &ldquo;good&rdquo; and the other &ldquo;bad,&rdquo;
it is more convenient than <code>Either</code> in this kind of situation. One difference to note with
<code>Or</code> is that the <code>Good</code> alternative is on the left, <code>Bad</code> on the right.
The reason is that <code>Or</code> is designed to be written using infix notation, and placing the
&ldquo;happy path&rdquo; first is more readable. For example, instead of writing:</p><p><pre class="stHighlighted">
<span class="stType">Or[Int, ErrorMessage]</span>
</pre></p><p>You can write:</p><p><pre class="stHighlighted">
<span class="stType">Int</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span>
</pre></p><p>Here's how the <code>parseName</code> method might be written using an <code>Or</code>, where
<code>ErrorMessage</code> is a type alias for <code>String</code> declared in the <code>org.scalactic</code>
package object:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalactic._
<br/><span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">String</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Good</span>(trimmed) <span class="stReserved">else</span> <span class="stType">Bad</span>(s<span class="stQuotedString">""""${input}" is not a valid name"""</span>)
}
</pre></p><p>You can think of the <code>String</code> <code>Or</code> <code>ErrorMessage</code> result
type like this:</p><p><blockquote>
<em>The <code>parseName</code> method will return a name <code>String</code> or, if the input string
is not a valid name, an <code>ErrorMessage</code>.</em>
</blockquote></p><p>Here's how the <code>parseAge</code> method might be written:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Int</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Good</span>(age) <span class="stReserved">else</span> <span class="stType">Bad</span>(s<span class="stQuotedString">""""${age}" is not a valid age"""</span>)
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">Bad</span>(s<span class="stQuotedString">""""${input}" is not a valid integer"""</span>)
  }
}
</pre></p><p>Given these implementations, here's how you'd write the <code>parsePerson</code> method:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Person</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span> =
  <span class="stReserved">for</span> {
    name &lt;- parseName(inputName)
    age &lt;- parseAge(inputAge)
  } <span class="stReserved">yield</span> <span class="stType">Person</span>(name, age)
</pre></p><p>Because of <code>Or</code>'s attitude, you need not write <code>.good</code> at the end of
each generator. <code>Or</code> will keep going so long as each step produces a <code>Good</code>,
short circuiting at the first sign of a <code>Bad</code>. Here are a few invocations of this
<code>parsePerson</code> method:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Good(Person(Bridget Jones,29))</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad("" is not a valid integer)</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: Bad("-29" is not a valid age)</span>
<br/>parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad("" is not a valid name)</span>
</pre></p><p><a name="accumulatingErrors"></a></p><h4> Accumulating errors with <code>Or</code> </h4><p>Another difference between <code>Or</code> and <code>Either</code> is that <code>Or</code> enables
you to accumulate errors if the <code>Bad</code> type is an <a href="Every.html"><code>Every</code></a>.
An <code>Every</code> is similar to a <code>Seq</code> in that it contains ordered elements, but
different from <code>Seq</code> in that it cannot be empty. An <code>Every</code> is
either a <a href="One.html"><code>One</code></a>,
which contains one and only one element, or a <a href="Many.html"><code>Many</code></a>, which contains two or
more elements.</p><p><em>Note: an <code>Or</code> whose <code>Bad</code> type is an <code>Every</code>, or one of its subtypes,
is called an &ldquo;accumulating <code>Or</code>.&rdquo;</em></p><p>To rewrite the previous example so that errors can be accumulated, you need first to return an <code>Every</code>
as the <code>Bad</code> type. Here's how you'd change the <code>parseName</code> method:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">String</span> <span class="stType">Or</span> <span class="stType">One[ErrorMessage]</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Good</span>(trimmed) <span class="stReserved">else</span> <span class="stType">Bad</span>(<span class="stType">One</span>(s<span class="stQuotedString">""""${input}" is not a valid name"""</span>))
}
</pre></p><p>Because <code>parseName</code> will either return a valid name <code>String</code> wrapped in a
<code>Good</code>, or <em>one</em> error message, wrapped in a <code>Bad</code>, you would write the
<code>Bad</code> type as <code>One[ErrorMessage]</code>. The same is true for <code>parseAge</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Int</span> <span class="stType">Or</span> <span class="stType">One[ErrorMessage]</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Good</span>(age) <span class="stReserved">else</span> <span class="stType">Bad</span>(<span class="stType">One</span>(s<span class="stQuotedString">""""${age}" is not a valid age"""</span>))
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">Bad</span>(<span class="stType">One</span>(s<span class="stQuotedString">""""${input}" is not a valid integer"""</span>))
  }
}
</pre></p><p>Because a <code>for</code> expression short-circuits on the first <code>Bad</code> encountered, you'll
need to use a different approach to write the <code>parsePerson</code> method. In this example, the
<code>withGood</code> method from trait <a href="Accumulation.html"><code>Accumulation</code></a>
will do the trick:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> Accumulation._
<br/><span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Person</span> <span class="stType">Or</span> <span class="stType">Every[ErrorMessage]</span> = {
  <span class="stReserved">val</span> name = parseName(inputName)
  <span class="stReserved">val</span> age = parseAge(inputAge)
  withGood(name, age) { <span class="stType">Person</span>(_, _) }
}
</pre></p><p>Trait <code>Accumulation</code> offers overloaded <code>withGood</code> methods that take 1 to
22 accumulating <code>Or</code>s, plus a function taking the same number of corresponding
<code>Good</code> values.  In this example, if both <code>name</code> and <code>age</code> are
<code>Good</code>s, the <code>withGood</code> method will pass the good name <code>String</code>
and age <code>Int</code> to the <code>Person(_, _)</code> function, and return the resulting <code>Person</code>
object wrapped in a <code>Good</code>. If either <code>name</code> and <code>age</code>, or both,
are <code>Bad</code>, <code>withGood</code> will return the accumulated errors in a <code>Bad</code>.</p><p>The result of <code>parsePerson</code>, if <code>Bad</code>, will therefore contain either one or two
error messages, <em>i.e.</em>, the result will either be a <code>One</code> or a <code>Many</code>.
As a result, the result type of <code>parsePerson</code> must be <code>Person</code> <code>Or</code>
<code>Every[ErrorMessage]</code>. Regardless of whether a <code>Bad</code> result contains one
or two error messages, it will contain <em>every</em> error message. Here's some invocations of
this accumulating version of <code>parsePerson</code>:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Good(Person(Bridget Jones,29))</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad(One("" is not a valid integer))</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: Bad(One("-29" is not a valid age))</span>
<br/>parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad(Many("" is not a valid name, "" is not a valid integer))</span>
</pre></p><p>Note that in the last example, the <code>Bad</code> contains an error message for both name and age.</p><h4> Other ways to accumulate errors </h4><p>The <code>Accumlation</code> trait also enables other ways of accumulating errors.</p><p><a name="usingCombined"></a></p><h5> Using <code>combined</code> </h5><p>If you have a collection of
accumulating <code>Or</code>s, for example, you can <em>combine</em> them into one <code>Or</code> using <code>combined</code>, like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(parseAge(<span class="stQuotedString">"29"</span>), parseAge(<span class="stQuotedString">"30"</span>), parseAge(<span class="stQuotedString">"31"</span>)).combined
<span class="stLineComment">// Result: Good(List(29, 30, 31))</span>
<br/><span class="stType">List</span>(parseAge(<span class="stQuotedString">"29"</span>), parseAge(<span class="stQuotedString">"-30"</span>), parseAge(<span class="stQuotedString">"31"</span>)).combined
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>
<br/><span class="stType">List</span>(parseAge(<span class="stQuotedString">"29"</span>), parseAge(<span class="stQuotedString">"-30"</span>), parseAge(<span class="stQuotedString">"-31"</span>)).combined
<span class="stLineComment">// Result: Bad(Many("-30" is not a valid age, "-31" is not a valid age))</span>
</pre></p><p><a name="usingValidatedBy"></a></p><h5> Using <code>validatedBy</code> </h5><p>Or if you have a collection of values and a function that transforms that type of value into an accumulating
<code>Or</code>s, you can validate the values using the function using <code>validatedBy</code>, like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stQuotedString">"29"</span>, <span class="stQuotedString">"30"</span>, <span class="stQuotedString">"31"</span>).validatedBy(parseAge)
<span class="stLineComment">// Result: Good(List(29, 30, 31))</span>
<br/><span class="stType">List</span>(<span class="stQuotedString">"29"</span>, <span class="stQuotedString">"-30"</span>, <span class="stQuotedString">"31"</span>).validatedBy(parseAge)
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>
<br/><span class="stType">List</span>(<span class="stQuotedString">"29"</span>, <span class="stQuotedString">"-30"</span>, <span class="stQuotedString">"-31"</span>).validatedBy(parseAge)
<span class="stLineComment">// Result: Bad(Many("-30" is not a valid age, "-31" is not a valid age))</span>
</pre></p><p><a name="usingZip"></a></p><h5> Using <code>zip</code> </h5><p>You can also zip two accumulating <code>Or</code>s together. If both are <code>Good</code>, you'll get a
<code>Good</code> tuple containin both original <code>Good</code> values. Otherwise, you'll get a <code>Bad</code>
containing every error message. Here are some examples:</p><p><pre class="stHighlighted">
parseName(<span class="stQuotedString">"Dude"</span>) zip parseAge(<span class="stQuotedString">"21"</span>)
<span class="stLineComment">// Result: Good((Dude,21))</span>
<br/>parseName(<span class="stQuotedString">"Dude"</span>) zip parseAge(<span class="stQuotedString">"-21"</span>)
<span class="stLineComment">// Result: Bad(One("-21" is not a valid age))</span>
<br/>parseName(<span class="stQuotedString">""</span>) zip parseAge(<span class="stQuotedString">"-21"</span>)
<span class="stLineComment">// Result: Bad(Many("" is not a valid name, "-21" is not a valid age))</span>
</pre></p><p><a name="usingWhen"></a></p><h5> Using <code>when</code> </h5><p>In addition, given an accumlating <code>Or</code>, you can pass one or more <em>validation functions</em> to <code>when</code> on the <code>Or</code>
to submit that <code>Or</code> to further scrutiny. A validation function accepts a <code>Good</code> type and returns a <code>Validation[E]</code>,
where <code>E</code> is the type in the <code>Every</code> in the <code>Bad</code> type. For an <code>Int</code> <code>Or</code> <code>One[ErrorMessage]</code>, for example
the validation function type would be <code>Int</code> <code>=&gt;</code> <code>Validation[ErrorMessage]</code>. Here are a few examples:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> isRound(i: <span class="stType">Int</span>): <span class="stType">Validation[ErrorMessage]</span> =
  <span class="stReserved">if</span> (i % <span class="stLiteral">10</span> == <span class="stLiteral">0</span>) <span class="stType">Pass</span> <span class="stReserved">else</span> <span class="stType">Fail</span>(i + <span class="stQuotedString">" was not a round number"</span>)
<br/><span class="stReserved">def</span> isDivBy3(i: <span class="stType">Int</span>): <span class="stType">Validation[ErrorMessage]</span> =
  <span class="stReserved">if</span> (i % <span class="stLiteral">3</span> == <span class="stLiteral">0</span>) <span class="stType">Pass</span> <span class="stReserved">else</span> <span class="stType">Fail</span>(i + <span class="stQuotedString">" was not divisible by 3"</span>)
</pre></p><p>If the <code>Or</code> on which you call <code>when</code> is already <code>Bad</code>, you get the same (<code>Bad</code>) <code>Or</code> back, because
no <code>Good</code> value exists to pass to the valiation functions:</p><p><pre class="stHighlighted">
parseAge(<span class="stQuotedString">"-30"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>
</pre></p><p>If the <code>Or</code> on which you call <code>when</code> is <code>Good</code>, and also passes all the validation functions (<em>i.e.</em>, the
all return <code>None</code>), you again get the same <code>Or</code> back, but this time, a <code>Good</code> one:</p><p><pre class="stHighlighted">
parseAge(<span class="stQuotedString">"30"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Good(30)</span>
</pre></p><p>If one or more of the validation functions fails, however, you'll get a <code>Bad</code> back contining every error. Here are some examples:</p><p><pre class="stHighlighted">
parseAge(<span class="stQuotedString">"33"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(One(33 was not a round number))</span>
<br/>parseAge(<span class="stQuotedString">"20"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(One(20 was not divisible by 3))</span>
<br/>parseAge(<span class="stQuotedString">"31"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(Many(31 was not a round number, 31 was not divisible by 3))</span>
</pre></p><p>Note that you can use <code>when</code> to accumulate errors in a <code>for</code> expression involving an accumulating <code>Or</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"-30"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>
<br/><span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"30"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Good(30)</span>
<br/><span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"33"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(One(33 was not a round number))</span>
<br/><span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"20"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(One(20 was not divisible by 3))</span>
<br/><span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"31"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(Many(31 was not a round number, 31 was not divisible by 3))</span>
</pre></p><h4> Much ado about <code>Nothing</code> </h4><p>Because <code>Or</code> has two types, but each of its two subtypes only takes a value of one or the other type, the Scala compiler will
infer <code>Nothing</code> for the unspecified type:</p><p><pre class="stREPL">
scala&gt; Good(3)
res0: org.scalactic.Good[Int,Nothing] = Good(3)

scala&gt; Bad("oops")
res1: org.scalactic.Bad[Nothing,String] = Bad(oops)
</pre></p><p>Often <code>Nothing</code> will work fine, as it will be widened as soon as the compiler encounters a more specific type.
Sometimes, however, you may need to specify it. In such situations you can use this syntax:</p><p><pre class="stREPL">
scala&gt; Good(3).orBad[String]
res2: org.scalactic.Good[Int,String] = Good(3)

scala&gt; Good[Int].orBad("oops")
res3: org.scalactic.Bad[Int,String] = Bad(oops)
</pre></p><p>If you want to specify both types, because you don't like the inferred type, you can do so like this:</p><p><pre class="stREPL">
scala&gt; Good[AnyVal, String](3)
res4: org.scalactic.Good[AnyVal,String] = Good(3)

scala&gt; Bad[Int, ErrorMessage]("oops")
res5: org.scalactic.Bad[Int,org.scalactic.ErrorMessage] = Bad(oops)
</pre></p><p>But you may find the code is clearer if you instead use a type ascription, like this:</p><p><pre class="stREPL">
scala&gt; Good(3): AnyVal Or String
res6: org.scalactic.Or[AnyVal,String] = Good(3)

scala&gt; Bad("oops"): Int Or ErrorMessage
res7: org.scalactic.Or[Int,org.scalactic.ErrorMessage] = Bad(oops)
</pre></p><p><em>Note: The <code>Or</code> hierarchy was inspired in part by the disjoint union (<code>\/</code>) and <code>Validation</code> types of
<a href="http://code.google.com/p/scalaz/" target="_blank"><code>scalaz</code></a>, the <code>ProcessResult</code> type of
<a href="https://github.com/typesafehub/activator/">Typesafe Activator</a>, and the <code>Result</code> type of
<a href="https://github.com/vpatryshev/ScalaKittens">ScalaKittens</a>.</em></p></div></div></li><li class="indented0 " name="org.scalactic.Prettifier" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="PrettifierextendsSerializable"></a><a id="Prettifier:Prettifier"></a> <span class="permalink"><a href="../../org/scalactic/Prettifier.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Prettifier.html" title="A function that given any object will produce a &amp;ldquo;pretty&amp;rdquo; string representation of that object, where &amp;ldquo;pretty&amp;rdquo; is in the eye of the implementer."><span class="name">Prettifier</span></a><span class="result"> extends <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">A function that given any object will produce a &ldquo;pretty&rdquo; string representation of that object,
where &ldquo;pretty&rdquo; is in the eye of the implementer.</p><div class="fullcomment"><div class="comment cmt"><p>A function that given any object will produce a &ldquo;pretty&rdquo; string representation of that object,
where &ldquo;pretty&rdquo; is in the eye of the implementer.</p><p>Scala's <code>Any</code> type declares a <code>toString</code> that will convert any object to a <code>String</code>
representation. This <code>String</code> representation is primarily intended for programmers, and is usually sufficient.
However, sometimes it can be helpful to provide an alternative implementation of <code>toString</code> for certain types.
For example, the <code>toString</code> implementation on <code>String</code> prints out the value of the <code>String</code>:</p><p><pre class="stREPL">
scala&gt; "1".toString
res0: String = 1
</pre></p><p>If the error message that resulted from comparing <code>Int</code> 1 with <code>String</code> <code>"1"</code>
in a ScalaTest assertion used <code>toString</code>, therefore, the error message would be:</p><p><pre>
1 did not equal 1
</pre></p><p>To make it quicker to figure out why the assertion failed, ScalaTest <i>prettifies</i> the objects involved in
the error message. The default <code>Prettifier</code> will place double quotes on either side of a <code>String</code>s
<code>toString</code> result:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; Prettifier.default("1")
res1: String = "1"
</pre></p><p>Thus the error message resulting from comparing <code>Int</code> 1 with <code>String</code> <code>"1"</code>,
in a ScalaTest assertion is:</p><p><pre>
1 did not equal "1"
</pre></p><p>If you wish to prettify an object in production code, for example, to issue a profoundly clear debug message, you can use
<code>PrettyMethods</code> and invoke <code>pretty</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; import PrettyMethods._
import PrettyMethods._

scala&gt; 1.pretty
res2: String = 1

scala&gt; "1".pretty
res3: String = "1"
</pre></p><p>For example, the default <code>Prettifier</code>, <a href="Prettifier$.html">`Prettifier.default`</a>, transforms:</p><ul><li><code>Null</code> to: <code>null</code></li><li><code>Unit</code> to: <code>&lt;() the Unit value&gt;</code></li><li><code>String</code> to: <code>"string"</code> (the <code>toString</code> result surrounded by double quotes)</li><li><code>Char</code> to: <code>'c'</code> (the <code>toString</code> result surrounded by single quotes)</li><li><code>Array</code> to: <code>Array("1", "2", "3")</code></li><li><code>scala.Some</code> to: <code>Some("3")</code></li><li><code>scala.util.Left</code> to: <code>Left("3")</code></li><li><code>scala.util.Right</code> to: <code>Right("3")</code></li><li><code>scala.util.Success</code> to: <code>Success("3")</code></li><li><code>org.scalactic.Good</code> to: <code>Good("3")</code></li><li><code>org.scalactic.Bad</code> to: <code>Bad("3")</code></li><li><code>org.scalactic.One</code> to: <code>One("3")</code></li><li><code>org.scalactic.Many</code> to: <code>Many("1", "2", "3")</code></li><li><code>scala.collection.GenTraversable</code> to: <code>List("1", "2", "3")</code></li><li><code>java.util.Collection</code> to: <code>["1", "2", "3"]</code></li><li><code>java.util.Map</code> to: <code>{1="one", 2="two", 3="three"}</code></li></ul><p>For anything else, the default <code>Prettifier</code> returns the result of invoking <code>toString</code>.</p><p>Note: <code>Prettifier</code> is not parameterized (<i>i.e.</i>, <code>Prettifier[T]</code>, where <code>T</code> is the type
to prettify) because assertions (including matcher expressions) in ScalaTest would then need to look up <code>Prettifier</code>s implicitly by type. This would slow
compilation even though most (let's guess 99.9%) of the time in practice assertions do not fail, and thus 99.9% of the time no error messages need to be generated.
If no error messages are needed 99.9% of the time, no prettification is needed 99.9% of the time, so the slow down in compile time for the implicit
look ups is unlikely to be worth the benefit. Only a few types in practice usually need prettification for testing error message purposes, and those will be covered
by the default <code>Prettifier</code>. A future version of ScalaTest will provide a simple mechanism to replace the default <code>Prettifier</code> with a
custom one when a test actually fails.</p></div></div></li><li class="indented0 " name="org.scalactic.PrettyMethods" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="PrettyMethodsextendsAnyRef"></a><a id="PrettyMethods:PrettyMethods"></a> <span class="permalink"><a href="../../org/scalactic/PrettyMethods.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="PrettyMethods.html" title="Provides an implicit conversion that enables pretty to be invoked on any object, to transform that object into a String representation."><span class="name">PrettyMethods</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Provides an implicit conversion that enables <code>pretty</code> to be invoked on any
object, to transform that object into a <code>String</code> representation.</p></li><li class="indented0 " name="org.scalactic.PrettyPair" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PrettyPairextendsProductwithSerializable"></a><a id="PrettyPair:PrettyPair"></a> <span class="permalink"><a href="../../org/scalactic/PrettyPair.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="PrettyPair.html" title=""><span class="name">PrettyPair</span></a><span class="params">(<span name="left">left: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="right">right: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="analysis">analysis: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Predef.String" class="extype">String</span>]</span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span></li><li class="indented0 " name="org.scalactic.Requirements" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="RequirementsextendsAnyRef"></a><a id="Requirements:Requirements"></a> <span class="permalink"><a href="../../org/scalactic/Requirements.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Requirements.html" title="Trait that contains require, and requireState, and requireNonNull methods for checking pre-conditions that give descriptive error messages extracted via a macro."><span class="name">Requirements</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Trait that contains <code>require</code>, and <code>requireState</code>, and <code>requireNonNull</code> methods for checking pre-conditions
that give descriptive error messages extracted via a macro.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that contains <code>require</code>, and <code>requireState</code>, and <code>requireNonNull</code> methods for checking pre-conditions
that give descriptive error messages extracted via a macro.</p><p>These methods of trait <code>Requirements</code> aim to improve error messages provided when a pre-condition check fails at runtime in
production code. Although it is recommended practice to supply helpful error messages when doing pre-condition checks, often people
don't. Instead of this:</p><p><pre class="stREPL">
scala&gt; val length = 5
length: Int = 5

scala&gt; val idx = 6
idx: Int = 6

scala&gt; require(idx &gt;= 0 &amp;&amp; idx &lt;= length, "index, " + idx + ", was less than zero or greater than or equal to length, " + length)
java.lang.IllegalArgumentException: <strong>requirement failed: index, 6, was less than zero or greater than or equal to length, 5</strong>
	at scala.Predef$.require(Predef.scala:233)
	...
</pre></p><p>People write simply:</p><p><pre class="stREPL">
scala&gt; require(idx &gt;= 0 &amp;&amp; idx &lt;= length)
java.lang.IllegalArgumentException: <strong>requirement failed</strong>
	at scala.Predef$.require(Predef.scala:221)
	...
</pre></p><p>Note that the detail message of the <code>IllegalArgumentException</code> thrown by the previous line of code is simply, <code>"requirement failed"</code>.
Such messages often end up in a log file or bug report, where a better error message can save time in debugging the problem.
By importing the members of <code>Requirements</code> (or mixing in its companion trait), you'll get a more helpful error message
extracted by a macro, whether or not a clue message is provided:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import Requirements._
import Requirements._

scala&gt; require(idx &gt;= 0 &amp;&amp; idx &lt;= length)
java.lang.IllegalArgumentException: <strong>6 was greater than or equal to 0, but 6 was not less than or equal to 5</strong>
	at org.scalactic.Requirements$RequirementsHelper.macroRequire(Requirements.scala:56)
	...

scala&gt; require(idx &gt;= 0 &amp;&amp; idx &lt;= length, "(hopefully that helps)")
java.lang.IllegalArgumentException: <strong>6 was greater than or equal to 0, but 6 was not less than or equal to 5 (hopefully that helps)</strong>
	at org.scalactic.Requirements$RequirementsHelper.macroRequire(Requirements.scala:56)
	...
</pre></p><p>The <code>requireState</code> method provides identical error messages to <code>require</code>, but throws
<code>IllegalStateException</code> instead of <code>IllegalArgumentException</code>:</p><p><pre class="stREPL">
scala&gt; val connectionOpen = false
connectionOpen: Boolean = false

scala&gt; requireState(connectionOpen)
java.lang.IllegalStateException: <strong>connectionOpen was false</strong>
	at org.scalactic.Requirements$RequirementsHelper.macroRequireState(Requirements.scala:71)
	...
</pre></p><p>Thus, whereas the <code>require</code> methods throw the Java platform's standard exception indicating a passed argument
violated a precondition, <code>IllegalArgumentException</code>, the <code>requireState</code> methods throw the standard
exception indicating an object's method was invoked when the object was in an inappropriate state for that method,
<code>IllegalStateException</code>.</p><p>The <code>requireNonNull</code> method takes one or more variables as arguments and throws <code>NullArgumentException</code>
with an error messages that includes the variable names if any are <code>null</code>. Here's an example:</p><p><pre class="stREPL">
scala&gt; val e: String = null
e: String = null

scala&gt; val f: java.util.Date = null
f: java.util.Date = null

scala&gt; requireNonNull(a, b, c, d, e, f)
org.scalactic.exceptions.NullArgumentException: <strong>e and f were null</strong>
	at org.scalactic.Requirements$RequirementsHelper.macroRequireNonNull(Requirements.scala:101)
	...
</pre></p><p>Although trait <code>Requirements</code> can help you debug problems that occur in production, bear in mind that a much
better alternative is to make it impossible for such events to occur at all. Use the type system to ensure that all
pre-conditions are met so that the compiler can find broken pre-conditions and point them out with compiler error messages.
When this is not possible or practical, however, trait <code>Requirements</code> is helpful.</p></div></div></li><li class="indented0 " name="org.scalactic.SeqEqualityConstraints" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="SeqEqualityConstraintsextendsAnyRef"></a><a id="SeqEqualityConstraints:SeqEqualityConstraints"></a> <span class="permalink"><a href="../../org/scalactic/SeqEqualityConstraints.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="SeqEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Seqs to one that more closely matches Scala's approach to Seq equality."><span class="name">SeqEqualityConstraints</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Provides an implicit method that loosens the equality constraint defined by <code>TypeCheckedTripleEquals</code> or <code>ConversionCheckedTripleEquals</code>
for Scala <code>Seq</code>s to one that more closely matches Scala's approach to <code>Seq</code> equality.</p><div class="fullcomment"><div class="comment cmt"><p>Provides an implicit method that loosens the equality constraint defined by <code>TypeCheckedTripleEquals</code> or <code>ConversionCheckedTripleEquals</code>
for Scala <code>Seq</code>s to one that more closely matches Scala's approach to <code>Seq</code> equality.</p><p>Scala's approach to <code>Seq</code> equality is that if both objects being compared are <code>Seq</code>s, the elements are compared to determine equality.
This means you could compare an immutable <code>Vector</code> and a mutable <code>ListBuffer</code> for equality, for instance, and get true so long as the
two <code>Seq</code>s contained the same elements in the same order. Here's an example:</p><p><pre class="stREPL">
scala&gt; import scala.collection.mutable.ListBuffer
import scala.collection.mutable.ListBuffer

scala&gt; Vector(1, 2) == ListBuffer(1, 2)
res0: Boolean = true
</pre></p><p>Such a comparison would not, however, compile if you used <code>===</code> under either <code>TypeCheckedTripleEquals</code> or <code>ConversionCheckedTripleEquals</code>,
because <code>Vector</code> and <code>ListBuffer</code> are not in a subtype/supertype relationship, nor does an implicit conversion by default exist between them:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TypeCheckedTripleEquals._
import TypeCheckedTripleEquals._

scala&gt; Vector(1, 2) === ListBuffer(1, 2)
&lt;console&gt;:16: error: types scala.collection.immutable.Vector[Int] and
  scala.collection.mutable.ListBuffer[Int] do not adhere to the equality constraint selected for
  the === and !== operators; the missing implicit parameter is of type
  org.scalactic.EqualityConstraint[scala.collection.immutable.Vector[Int],
  scala.collection.mutable.ListBuffer[Int]]
              Vector(1, 2) === ListBuffer(1, 2)
                           ^
</pre></p><p>If you mix or import the implicit conversion provided by <code>SeqEqualityConstraint</code>, however, the comparison will be allowed:</p><p><pre class="stREPL">
scala&gt; import SeqEqualityConstraints._
import SeqEqualityConstraints._

scala&gt; Vector(1, 2) === ListBuffer(1, 2)
res2: Boolean = true
</pre></p><p>The equality constraint provided by this trait requires that both left and right sides are subclasses of <code>scala.collection.GenSeq</code> and that
an <code>EqualityConstraint</code> can be found for the element types. In the example above, both the <code>Vector</code> and
<code>ListBuffer</code> are subclasses of <code>scala.collection.GenSeq</code>, and the regular <code>TypeCheckedTripleEquals</code> provides equality
constraints for the element types, both of which are <code>Int</code>. By contrast, this
trait would not allow a <code>Vector[Int]</code> to be compared against a <code>ListBuffer[java.util.Date]</code>, because no equality constraint
will exist between the element types <code>Int</code> and <code>Date</code>:</p><p><pre class="stREPL">
scala&gt; import java.util.Date
import java.util.Date

scala&gt; Vector(1, 2) === ListBuffer(new Date, new Date)
&lt;console&gt;:20: error: types scala.collection.immutable.Vector[Int] and
  scala.collection.mutable.ListBuffer[java.util.Date] do not adhere to the equality constraint selected for
  the === and !== operators; the missing implicit parameter is of type
  org.scalactic.EqualityConstraint[scala.collection.immutable.Vector[Int],
  scala.collection.mutable.ListBuffer[java.util.Date]]
              Vector(1, 2) === ListBuffer(new Date, new Date)
                           ^
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.SetEqualityConstraints" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="SetEqualityConstraintsextendsAnyRef"></a><a id="SetEqualityConstraints:SetEqualityConstraints"></a> <span class="permalink"><a href="../../org/scalactic/SetEqualityConstraints.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="SetEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Sets to one that more closely matches Scala's approach to Set equality."><span class="name">SetEqualityConstraints</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Provides an implicit method that loosens the equality constraint defined by <code>TypeCheckedTripleEquals</code> or <code>ConversionCheckedTripleEquals</code>
for Scala <code>Set</code>s to one that more closely matches Scala's approach to <code>Set</code> equality.</p><div class="fullcomment"><div class="comment cmt"><p>Provides an implicit method that loosens the equality constraint defined by <code>TypeCheckedTripleEquals</code> or <code>ConversionCheckedTripleEquals</code>
for Scala <code>Set</code>s to one that more closely matches Scala's approach to <code>Set</code> equality.</p><p>Scala's approach to <code>Set</code> equality is that if both objects being compared are <code>Set</code>s, the elements are compared to determine equality.
This means you could compare an immutable <code>TreeSet</code> and a mutable <code>HashSet</code> for equality, for instance, and get true so long as the
two <code>Set</code>s contained the same elements in the same order. Here's an example:</p><p><pre class="stREPL">
scala&gt; import scala.collection.immutable.TreeSet
import scala.collection.immutable.TreeSet

scala&gt; import scala.collection.mutable.HashSet
import scala.collection.mutable.HashSet

scala&gt; TreeSet(1, 2) == HashSet(1, 2)
res0: Boolean = true
</pre></p><p>Such a comparison would not, however, compile if you used <code>===</code> under either <code>TypeCheckedTripleEquals</code> or <code>ConversionCheckedTripleEquals</code>,
because <code>TreeSet</code> and <code>HashSet</code> are not in a subtype/supertype relationship, nor does an implicit conversion by default exist between them:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TypeCheckedTripleEquals._
import TypeCheckedTripleEquals._

scala&gt; TreeSet(1, 2) === HashSet(1, 2)
&lt;console&gt;:16: error: types scala.collection.immutable.TreeSet[Int] and
  scala.collection.mutable.HashSet[Int] do not adhere to the equality constraint selected for
  the === and !== operators; the missing implicit parameter is of type
  org.scalactic.EqualityConstraint[scala.collection.immutable.TreeSet[Int],
  scala.collection.mutable.HashSet[Int]]
              TreeSet(1, 2) === HashSet(1, 2)
                            ^
</pre></p><p>If you mix or import the implicit conversion provided by <code>SetEqualityConstraint</code>, however, the comparison will be allowed:</p><p><pre class="stREPL">
scala&gt; import SetEqualityConstraints._
import SetEqualityConstraints._

scala&gt; TreeSet(1, 2) === HashSet(1, 2)
res2: Boolean = true
</pre></p><p>The equality constraint provided by this trait requires that both left and right sides are subclasses of <code>scala.collection.GenSet</code> and that
an <code>EqualityConstraint</code> can be found for the element types. In the example above, both the <code>TreeSet</code> and
<code>HashSet</code> are subclasses of <code>scala.collection.GenSet</code>, and the regular <code>TypeCheckedTripleEquals</code> provides equality
constraints for the element types, both of which are <code>Int</code>. By contrast, this
trait would not allow a <code>TreeSet[Int]</code> to be compared against a <code>HashSet[java.util.Date]</code>, because no equality constraint
will exist between the element types <code>Int</code> and <code>Date</code>:</p><p><pre class="stREPL">
scala&gt; import java.util.Date
import java.util.Date

scala&gt; TreeSet(1, 2) === HashSet(new Date, new Date)
&lt;console&gt;:20: error: types scala.collection.immutable.TreeSet[Int] and
  scala.collection.mutable.HashSet[java.util.Date] do not adhere to the equality constraint selected for
  the === and !== operators; the missing implicit parameter is of type
  org.scalactic.EqualityConstraint[scala.collection.immutable.TreeSet[Int],
  scala.collection.mutable.HashSet[java.util.Date]]
              TreeSet(1, 2) === HashSet(new Date, new Date)
                            ^
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.Snapshot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="SnapshotextendsProductwithSerializable"></a><a id="Snapshot:Snapshot"></a> <span class="permalink"><a href="../../org/scalactic/Snapshot.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">case class</span></span> <span class="symbol"><a href="Snapshot.html" title="Case class that stores the name and value of a variable or expression."><span class="name">Snapshot</span></a><span class="params">(<span name="name">name: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Case class that stores the name and value of a variable or expression.</p><div class="fullcomment"><div class="comment cmt"><p>Case class that stores the name and value of a variable or expression.</p><p>See the main documentation for trait <a href="Snapshots.html"><code>Snapshots</code></a> for more information and examples.</p></div><dl class="paramcmts block"><dt class="param">name</dt><dd class="cmt"><p>the name of the expression</p></dd><dt class="param">value</dt><dd class="cmt"><p>the value of the expression</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.SnapshotSeq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="SnapshotSeqextendsIndexedSeq[org.scalactic.Snapshot]"></a><a id="SnapshotSeq:SnapshotSeq"></a> <span class="permalink"><a href="../../org/scalactic/SnapshotSeq.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="SnapshotSeq.html" title="An IndexedSeq[Snapshot] providing toString and lines methods that can be useful for debug and log messages about program state."><span class="name">SnapshotSeq</span></a><span class="result"> extends <span name="scala.collection.immutable.IndexedSeq" class="extype">IndexedSeq</span>[<a href="Snapshot.html" name="org.scalactic.Snapshot" id="org.scalactic.Snapshot" class="extype">Snapshot</a>]</span></span><p class="shortcomment cmt">An <code>IndexedSeq[Snapshot]</code> providing <code>toString</code> and <code>lines</code> methods that
can be useful for debug and log messages about program state.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>IndexedSeq[Snapshot]</code> providing <code>toString</code> and <code>lines</code> methods that
can be useful for debug and log messages about program state.</p><p>See the main documentation for trait <a href="Snapshots.html"><code>Snapshots</code></a> for more information and examples.</p></div></div></li><li class="indented0 " name="org.scalactic.Snapshots" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="SnapshotsextendsAnyRef"></a><a id="Snapshots:Snapshots"></a> <span class="permalink"><a href="../../org/scalactic/Snapshots.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Snapshots.html" title="Trait that provides a snap method that takes one or more arguments and results in a SnapshotSeq, whose toString lists the names and values of each argument."><span class="name">Snapshots</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Trait that provides a <code>snap</code> method that takes one or more arguments and results in a
<a href="SnapshotSeq.html"><code>SnapshotSeq</code></a>, whose <code>toString</code> lists the names
and values of each argument.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that provides a <code>snap</code> method that takes one or more arguments and results in a
<a href="SnapshotSeq.html"><code>SnapshotSeq</code></a>, whose <code>toString</code> lists the names
and values of each argument.</p><p>The intended use case of this trait is to help you write debug and log
messages that give a "snapshot" of program state. Here's an example:</p><p><pre class="stREPL">
scala&gt; import Snapshots._
import Snapshots._

scala&gt; snap(a, b, c, d, e, f)
res3: org.scalactic.SnapshotSeq = a was 1, b was 2, c was 3, d was 4, e was null, f was null
</pre></p><p><code>SnapshotSeq</code> offers a <code>lines</code> method that places each variable name/value pair on its own line:</p><p><pre class="stREPL">
scala&gt; snap(a, b, c, d, e, f).lines
res4: String =
a was 1
b was 2
c was 3
d was 4
e was null
f was null
</pre></p><p>Or, because a <code>SnapshotSeq</code> is a <code>IndexedSeq[Snapshot]</code>, you can process it just like any other <code>Seq</code>, for example:</p><p><pre class="stREPL">
scala&gt; snap(a, b, c, d, e, f).mkString("Wow! ", ", and ", ". That's so awesome!")
res6: String = Wow! a was 1, and b was 2, and c was 3, and d was 4, and e was null, and f was null. That's so awesome!
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.StringNormalizations" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="StringNormalizationsextendsAnyRef"></a><a id="StringNormalizations:StringNormalizations"></a> <span class="permalink"><a href="../../org/scalactic/StringNormalizations.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="StringNormalizations.html" title="Provides methods that produce Uniformity[String] instances for various ways to normalize strings for equality comparisons."><span class="name">StringNormalizations</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Provides methods that produce <code>Uniformity[String]</code> instances for various
ways to normalize strings for equality comparisons.</p></li><li class="indented0 " name="org.scalactic.TimesOnInt" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="TimesOnIntextendsAnyRef"></a><a id="TimesOnInt:TimesOnInt"></a> <span class="permalink"><a href="../../org/scalactic/TimesOnInt.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="TimesOnInt.html" title="Trait providing an implicit conversion that adds a times method to Ints that will repeat a given side-effecting operation multiple times."><span class="name">TimesOnInt</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Trait providing an implicit conversion that adds a <code>times</code> method to <code>Int</code>s that
will repeat a given side-effecting operation multiple times.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing an implicit conversion that adds a <code>times</code> method to <code>Int</code>s that
will repeat a given side-effecting operation multiple times.</p><p>Here's an example in which a friendly greeting is printed three times:</p><p><pre class="stHighlighted">
<span class="stLiteral">3</span> times println(<span class="stQuotedString">"Hello again, world!"</span>)
</pre></p><p>Running the above code would yield this output:</p><p><pre>
Hello again, world!
Hello again, world!
Hello again, world!
</pre></p><p>If you need to repeat a block of statements multiple times, just enclose them in parentheses, like this:</p><p><pre class="stHighlighted">
<span class="stLiteral">2</span> times {
 print(<span class="stQuotedString">"Hello "</span>)
 print(<span class="stQuotedString">"again, "</span>)
 println(<span class="stQuotedString">"world!"</span>)
}
</pre></p><p>Running the above code would yield:</p><p><pre>
Hello again, world!
Hello again, world!
</pre></p><p>This trait enables <code>times</code> to be invoked on 0 and any positive integer,
but attempting to invoke <code>times</code> on a negative integer will result in an <code>IllegalArgumentException</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.Tolerance" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="ToleranceextendsAnyRef"></a><a id="Tolerance:Tolerance"></a> <span class="permalink"><a href="../../org/scalactic/Tolerance.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Tolerance.html" title="Trait containing an implicit conversion that adds a +- method to Numeric types, which enables spreads to be expressed in terms of a pivot and tolerance."><span class="name">Tolerance</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Trait containing an implicit conversion that adds a <code>+-</code> method to <code>Numeric</code> types, which enables
spreads to be expressed in terms of a <em>pivot</em> and <em>tolerance</em>.</p><div class="fullcomment"><div class="comment cmt"><p>Trait containing an implicit conversion that adds a <code>+-</code> method to <code>Numeric</code> types, which enables
spreads to be expressed in terms of a <em>pivot</em> and <em>tolerance</em>.</p><p>For example, the <code>TripleEquals</code> trait (and its type-checking siblings <code>TypeCheckedTripleEquals</code> and
<code>ConversionCheckedTripleEquals</code>) enable you to write:</p><p><pre class="stHighlighted">
a === (<span class="stLiteral">1.0</span> +- <span class="stLiteral">0.1</span>)
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.TolerantNumerics" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="TolerantNumericsextendsAnyRef"></a><a id="TolerantNumerics:TolerantNumerics"></a> <span class="permalink"><a href="../../org/scalactic/TolerantNumerics.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="TolerantNumerics.html" title="Provides Equality and Equivalence instances for Numeric types that compare for equality with a given tolerance."><span class="name">TolerantNumerics</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Provides <code>Equality</code> and <code>Equivalence</code> instances for <code>Numeric</code> types that
compare for equality with a given tolerance.</p><div class="fullcomment"><div class="comment cmt"><p>Provides <code>Equality</code> and <code>Equivalence</code> instances for <code>Numeric</code> types that
compare for equality with a given tolerance.</p><p>Here's an example:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TripleEquals._
import TripleEquals._

scala&gt; 2.001 === 2.0
res0: Boolean = false

scala&gt; implicit val doubleEquality = TolerantNumerics.tolerantDoubleEquality(0.01)
doubleEquality: org.scalactic.Equality[Double] = org.scalactic.TolerantNumerics$$anon$1@16c2bd13

scala&gt; 2.001 === 2.0
res1: Boolean = true
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.TraversableEqualityConstraints" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="TraversableEqualityConstraintsextendsSeqEqualityConstraintswithSetEqualityConstraintswithMapEqualityConstraints"></a><a id="TraversableEqualityConstraints:TraversableEqualityConstraints"></a> <span class="permalink"><a href="../../org/scalactic/TraversableEqualityConstraints.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="TraversableEqualityConstraints.html" title="Provides three implicit methods that loosen the equality constraint defined by TypeCheckedTripleEquals for Scala Traversables to one that more closely matches Scala's approach to Traversable equality."><span class="name">TraversableEqualityConstraints</span></a><span class="result"> extends <a href="SeqEqualityConstraints.html" name="org.scalactic.SeqEqualityConstraints" id="org.scalactic.SeqEqualityConstraints" class="extype">SeqEqualityConstraints</a> with <a href="SetEqualityConstraints.html" name="org.scalactic.SetEqualityConstraints" id="org.scalactic.SetEqualityConstraints" class="extype">SetEqualityConstraints</a> with <a href="MapEqualityConstraints.html" name="org.scalactic.MapEqualityConstraints" id="org.scalactic.MapEqualityConstraints" class="extype">MapEqualityConstraints</a></span></span><p class="shortcomment cmt">Provides three implicit methods that loosen the equality constraint defined by <code>TypeCheckedTripleEquals</code>
for Scala <code>Traversable</code>s to one that more closely matches Scala's approach to <code>Traversable</code> equality.</p><div class="fullcomment"><div class="comment cmt"><p>Provides three implicit methods that loosen the equality constraint defined by <code>TypeCheckedTripleEquals</code>
for Scala <code>Traversable</code>s to one that more closely matches Scala's approach to <code>Traversable</code> equality.</p><p>Scala's approach to <code>Traversable</code> equality is that if the objects being compared are ether both <code>Seq</code>s, both <code>Set</code>s,
or both <code>Map</code>s, the elements are compared to determine equality.
This means you could compare an immutable <code>Vector</code> and a mutable <code>ListBuffer</code> for equality, for instance, and get true so long as the
two <code>Seq</code>s contained the same elements in the same order. Here's an example:</p><p><pre class="stREPL">
scala&gt; import scala.collection.mutable.ListBuffer
import scala.collection.mutable.ListBuffer

scala&gt; Vector(1, 2) == ListBuffer(1, 2)
res0: Boolean = true
</pre></p><p>Such a comparison would not, however, compile if you used <code>===</code> under <code>TypeCheckedTripleEquals</code>,
because <code>Vector</code> and <code>ListBuffer</code> are not in a subtype/supertype relationship:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TypeCheckedTripleEquals._
import TypeCheckedTripleEquals._

scala&gt; Vector(1, 2) === ListBuffer(1, 2)
&lt;console&gt;:16: error: types scala.collection.immutable.Vector[Int] and
  scala.collection.mutable.ListBuffer[Int] do not adhere to the equality constraint selected for
  the === and !== operators; the missing implicit parameter is of type
  org.scalactic.CanEqual[scala.collection.immutable.Vector[Int],
  scala.collection.mutable.ListBuffer[Int]]
              Vector(1, 2) === ListBuffer(1, 2)
                           ^
</pre></p><p>If you mix or import the implicit conversion provided by <code>TraversableEqualityConstraint</code>, however, the comparison will be allowed:</p><p><pre class="stREPL">
scala&gt; import TraversableEqualityConstraints._
import TraversableEqualityConstraints._

scala&gt; Vector(1, 2) === ListBuffer(1, 2)
res2: Boolean = true
</pre></p><p>The equality constraints provided by this trait require that left and right sides are both subclasses of either <code>scala.collection.GenSeq</code>,
<code>scala.collection.GenSet</code>, or <code>scala.collection.GenMap</code>, and that
an <code>CanEqual</code> can be found for the element types for <code>Seq</code> and <code>Set</code>, or the key and value types for <code>Map</code>s. In
the example above, both the <code>Vector</code> and
<code>ListBuffer</code> are subclasses of <code>scala.collection.GenSeq</code>, and the regular <code>TypeCheckedTripleEquals</code> provides equality
constraints for the element types, both of which are <code>Int</code>. By contrast, this
trait would not allow a <code>Vector[Int]</code> to be compared against a <code>ListBuffer[java.util.Date]</code>, because no equality constraint
will exist between the element types <code>Int</code> and <code>Date</code>:</p><p><pre class="stREPL">
scala&gt; import java.util.Date
import java.util.Date

scala&gt; Vector(1, 2) === ListBuffer(new Date, new Date)
&lt;console&gt;:20: error: types scala.collection.immutable.Vector[Int] and
  scala.collection.mutable.ListBuffer[java.util.Date] do not adhere to the equality constraint selected for
  the === and !== operators; the missing implicit parameter is of type
  org.scalactic.CanEqual[scala.collection.immutable.Vector[Int],
  scala.collection.mutable.ListBuffer[java.util.Date]]
              Vector(1, 2) === ListBuffer(new Date, new Date)
                           ^
</pre></p><p>This trait simply mixes together <a href="SeqEqualityConstraints.html"><code>SeqEqualityConstraints</code></a>,
<a href="SetEqualityConstraints.html"><code>SetEqualityConstraints</code></a>,
and <a href="MapEqualityConstraints.html"><code>MapEqualityConstraints</code></a>.</p></div></div></li><li class="indented0 " name="org.scalactic.TripleEquals" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="TripleEqualsextendsTripleEqualsSupport"></a><a id="TripleEquals:TripleEquals"></a> <span class="permalink"><a href="../../org/scalactic/TripleEquals.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="TripleEquals.html" title="Provides === and !== operators that return Boolean, delegate the equality determination to an Equality type class, and require no relationship between the types of the two values compared."><span class="name">TripleEquals</span></a><span class="result"> extends <a href="TripleEqualsSupport.html" name="org.scalactic.TripleEqualsSupport" id="org.scalactic.TripleEqualsSupport" class="extype">TripleEqualsSupport</a></span></span><p class="shortcomment cmt">Provides <code>===</code> and <code>!==</code> operators that return <code>Boolean</code>, delegate the equality determination
to an <code>Equality</code> type class, and require no relationship between the types of the two values compared.</p><div class="fullcomment"><div class="comment cmt"><p>Provides <code>===</code> and <code>!==</code> operators that return <code>Boolean</code>, delegate the equality determination
to an <code>Equality</code> type class, and require no relationship between the types of the two values compared.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Trait <code>TripleEquals</code> is useful (in both production and test code) when you need determine equality for a type of object differently than its
<code>equals</code> method: either you can't change the <code>equals</code> method, or the <code>equals</code> method is sensible generally, but
you are in a special situation where you need something else. You can use the <a href="http://www.scalactic.org/supersafe">SuperSafe Community Edition</a> compiler plugin  to
get a compile-time safety check of types being compared with <code>===</code>. In situations where you need a stricter type check, you can use
<a href="TypeCheckedTripleEquals.html"><code>TypeCheckedTripleEquals</code></a>.
</td></tr></table></p><p>This trait will override or hide implicit methods defined by its sibling trait,
<a href="TypeCheckedTripleEquals.html"><code>TypeCheckedTripleEquals</code></a>,
and can therefore be used to temporarily turn of type checking in a limited scope. Here's an example, in which <code>TypeCheckedTripleEquals</code> will
cause a compiler error:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalactic._
<span class="stReserved">import</span> TypeCheckedTripleEquals._
<br/><span class="stReserved">object</span> <span class="stType">Example</span> {
<br/>  <span class="stReserved">def</span> cmp(a: <span class="stType">Int</span>, b: <span class="stType">Long</span>): <span class="stType">Int</span> = {
    <span class="stReserved">if</span> (a === b) <span class="stLiteral">0</span>       <span class="stLineComment">// This line won't compile</span>
    <span class="stReserved">else</span> <span class="stReserved">if</span> (a &lt; b) -<span class="stLiteral">1</span>
    <span class="stReserved">else</span> <span class="stLiteral">1</span>
  }
<br/> <span class="stReserved">def</span> cmp(s: <span class="stType">String</span>, t: <span class="stType">String</span>): <span class="stType">Int</span> = {
   <span class="stReserved">if</span> (s === t) <span class="stLiteral">0</span>
   <span class="stReserved">else</span> <span class="stReserved">if</span> (s &lt; t) -<span class="stLiteral">1</span>
   <span class="stReserved">else</span> <span class="stLiteral">1</span>
 }
}
</pre></p><p>Because <code>Int</code> and <code>Long</code> are not in a subtype/supertype relationship, comparing <code>1</code> and <code>1L</code> in the context
of <code>TypeCheckedTripleEquals</code> will generate a compiler error:</p><p><pre>
Example.scala:9: error: types Int and Long do not adhere to the equality constraint selected for
the === and !== operators; they must either be in a subtype/supertype relationship;
the missing implicit parameter is of type org.scalactic.Constraint[Int,Long]
    if (a === b) 0      // This line won't compile
          ^
one error found
</pre></p><p>You can &ldquo;turn off&rdquo; the type checking locally by importing the members of <code>TripleEquals</code> in
a limited scope:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalactic.examples.tripleequals
<br/><span class="stReserved">import</span> org.scalactic._
<span class="stReserved">import</span> TypeCheckedTripleEquals._
<br/><span class="stReserved">object</span> <span class="stType">Example</span> {
<br/>  <span class="stReserved">def</span> cmp(a: <span class="stType">Int</span>, b: <span class="stType">Long</span>): <span class="stType">Int</span> = {
    <span class="stReserved">import</span> TripleEquals._
    <span class="stReserved">if</span> (a === b) <span class="stLiteral">0</span>
    <span class="stReserved">else</span> <span class="stReserved">if</span> (a &lt; b) -<span class="stLiteral">1</span>
    <span class="stReserved">else</span> <span class="stLiteral">1</span>
  }
<br/> <span class="stReserved">def</span> cmp(s: <span class="stType">String</span>, t: <span class="stType">String</span>): <span class="stType">Int</span> = {
   <span class="stReserved">if</span> (s === t) <span class="stLiteral">0</span>
   <span class="stReserved">else</span> <span class="stReserved">if</span> (s &lt; t) -<span class="stLiteral">1</span>
   <span class="stReserved">else</span> <span class="stLiteral">1</span>
 }
}
</pre></p><p>With the above change, the <code>Example.scala</code> file compiles fine. Type checking is turned off only inside the first <code>cmp</code> method that
takes an <code>Int</code> and a <code>Long</code>. <code>TypeCheckedTripleEquals</code> is still enforcing its type constraint, for example, for the <code>s === t</code>
expression in the other overloaded <code>cmp</code> method that takes strings.</p><p>Because the methods in <code>TripleEquals</code> (and its siblings)<em>override</em> all the methods defined in
supertype <a href="TripleEqualsSupport.html"><code>TripleEqualsSupport</code></a>, you can achieve the same
kind of nested tuning of equality constraints whether you mix in traits, import from companion objects, or use some combination of both.</p><p>In short, you should be able to select a primary constraint level via either a mixin or import, then change that in nested scopes
however you want, again either through a mixin or import, without getting any implicit conversion ambiguity. The innermost constraint level in scope
will always be in force.</p></div></div></li><li class="indented0 " name="org.scalactic.TripleEqualsSupport" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="TripleEqualsSupportextendsAnyRef"></a><a id="TripleEqualsSupport:TripleEqualsSupport"></a> <span class="permalink"><a href="../../org/scalactic/TripleEqualsSupport.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="TripleEqualsSupport.html" title="Trait that defines abstract methods used to enforce compile-time type constraints for equality comparisons, and defines === and !== operators used by matchers."><span class="name">TripleEqualsSupport</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Trait that defines abstract methods used to enforce compile-time type constraints for equality comparisons, and defines <code>===</code> and <code>!==</code> operators
used by matchers.</p><div class="fullcomment"><div class="comment cmt"><p>Trait that defines abstract methods used to enforce compile-time type constraints for equality comparisons, and defines <code>===</code> and <code>!==</code> operators
used by matchers.</p><p>The abstract methods of this trait are selectively implemented as implicit by subclasses to enable a spectrum of type constraints for the
<code>===</code> and <code>!==</code> operators. As an illustration, if in the expression, <code>a === b</code>, the type of <code>a</code>
is <code>A</code> and <code>b</code> is <code>B</code>, the following three levels of compile-time checking can be obtained from
<code>TripleEqualsSupport</code> subtraits:</p><p><b>Unchecked</b> - <code>A</code> and <code>B</code> can be any two types. This constraint level is available from
subtrait <a href="TripleEquals.html"><code>TripleEquals</code></a>.</p><p><b>Statically-checked</b> - <code>A</code> must be a subtype of <code>B</code>, or vice versa, or must cooperate such that the
equality laws stated in the <code>equals</code> contract are preserved.
This (intermediate) constraint level is available by using subtrait <a href="TripleEquals.html"><code>TripleEquals</code></a> and installing the <a href="http://www.scalactic.org/supersafe">SuperSafe Community Edition</a>
Scala compiler plugin.</p><p><b>Type-checked</b> - <code>A</code> must be a subtype of <code>B</code>, or vice versa.
(Both <code>A</code> and <code>B</code> can be the same type, because a type is considered a subtype
of itself.)
This (strongest) constraint level is available from subtrait <a href="TypeCheckedTripleEquals.html"><code>TypeCheckedTripleEquals</code></a>.</p><p>This trait defines all methods that need to be defined implicitly by the subtraits so that if multiple subtraits are used together, the inner-most
subtrait in scope can not only enable the implicits it needs by overriding or hiding those methods (currently-in-scope as regular, non-implicit
methods) and making
them implicit, it can also <em>disable</em> any implicits enabled by its sibling subtraits in enclosing scopes. For example, if your test class mixes
in <code>TypeCheckedTripleEquals</code>, inside your test class the following methods will be implicit:</p><ul><li><code>convertToCheckingEqualizer</code></li><li><code>typeCheckedConstraint</code></li><li><code>lowPriorityTypeCheckedConstraint</code></li><li><code>convertEquivalenceToAToBConstraint</code></li><li><code>convertEquivalenceToBToAConstraint</code></li></ul><p>If in the body of a test you want to turn off the type checking, you can import the members
of <code>TripleEquals</code> in the body of that test. This will not only hide
non-implicit methods <code>convertToEqualizer</code> <code>unconstrainedEquality</code> of <code>TypeCheckedTripleEquals</code>,
replacing those with implicit ones defined in <code>TripleEquals</code>, it will also hide the three methods made implicit in <code>TypeCheckedTripleEquals</code>
(and listed above), replacing them by <em>non-implicit</em> ones.</p><p>In short, you should be able to select a primary constraint level via either a mixin or import, then change that in nested scopes
however you want, again either through a mixin or import, without getting any implicit conversion ambiguity. The innermost constraint level in scope
will always be in force.</p></div></div></li><li class="indented0 " name="org.scalactic.TrySugar" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="TrySugarextendsAnyRef"></a><a id="TrySugar:TrySugar"></a> <span class="permalink"><a href="../../org/scalactic/TrySugar.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="TrySugar.html" title="Trait providing an implicit class that adds a toOr method to Try, which converts Success to Good, and Failure to Bad, as well as a validating method, which takes one or more validation functions and returns either the same Try if either the Try had already failed or its value passes all the functions, or ValidationFailedException containing an error message describing the first validation that failed."><span class="name">TrySugar</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Trait providing an implicit class that adds a <code>toOr</code> method to
<code>Try</code>, which converts <code>Success</code> to <code>Good</code>,
and <code>Failure</code> to <code>Bad</code>, as well as a <code>validating</code> method,
which takes one or more validation functions and returns either the
same <code>Try</code> if either the <code>Try</code> had already failed or its value
passes all the functions, or <a href="exceptions/ValidationFailedException.html" name="org.scalactic.exceptions.ValidationFailedException" id="org.scalactic.exceptions.ValidationFailedException" class="extype"><code>ValidationFailedException</code></a> containing an error message
describing the first validation that failed.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing an implicit class that adds a <code>toOr</code> method to
<code>Try</code>, which converts <code>Success</code> to <code>Good</code>,
and <code>Failure</code> to <code>Bad</code>, as well as a <code>validating</code> method,
which takes one or more validation functions and returns either the
same <code>Try</code> if either the <code>Try</code> had already failed or its value
passes all the functions, or <a href="exceptions/ValidationFailedException.html" name="org.scalactic.exceptions.ValidationFailedException" id="org.scalactic.exceptions.ValidationFailedException" class="extype"><code>ValidationFailedException</code></a> containing an error message
describing the first validation that failed.</p><p>Here's an example validation method, which passes if the given <code>Int</code> is evenly
divisible by 10 (<em>i.e.</em>, the result will be <a href="Pass$.html" name="org.scalactic.Pass" id="org.scalactic.Pass" class="extype"><code>Pass</code></a>). If the value does not pass
this test, the result is a <a href="Fail.html" name="org.scalactic.Fail" id="org.scalactic.Fail" class="extype"><code>Fail</code></a> containing a helpful error message string.</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TrySugar._
import TrySugar._

scala&gt; import scala.util.Try
import scala.util.Try

scala&gt; def isRound(i: Int): Validation[ErrorMessage] =
     |   if (i % 10 == 0) Pass else Fail(i + " was not a round number")
isRound: (i: Int)org.scalactic.Validation[org.scalactic.ErrorMessage]
</pre></p><p>Validation will be attempted on a successful <code>Try</code>. If the validation succeeds, the
resulting <code>Try</code> will be the same successful <code>Try</code> with the same value. (A
"validation" only transforms the <code>Try</code> if the validation fails, otherwise it is the
same <code>Try</code>. The only difference is its value has now been proven <em>valid</em>.)
In the following example, a successful <code>Try[Int]</code> with the value 100
passes the validation (which checks whether 100 is evenly divisible by 10), therefore
the result of the <code>validating</code> call is the same successful <code>Try</code>
with the same value.</p><p><pre class="stREPL">
scala&gt; val try100 = Try(100)
try100: scala.util.Try[Int] = Success(100)

scala&gt; val round100 = try100.validating(isRound)
round100: scala.util.Try[Int] = Success(100)
</pre></p><p>If validation fails, the successful <code>Try</code> will be transformed into a failed one, with
a <code>ValidationFailedException</code> that contains the error message
returned by the validation function. In the following example, 42 fails the validation because it
is not evenly divisible by 10:</p><p><pre class="stREPL">
scala&gt; val try42 = Try(42)
try42: scala.util.Try[Int] = Success(42)

scala&gt; val round42 = try42.validating(isRound)
round42: scala.util.Try[Int] = Failure(org.scalactic.exceptions.ValidationFailedException: 42 was not a round number)
</pre></p><p>If <code>validating</code> is called on a failed <code>Try</code>, it just returns the same failed <code>Try</code>:</p><p><pre class="stREPL">
scala&gt; val tryEx = Try[Int] { throw new Exception("oops!") }
tryEx: scala.util.Try[Int] = Failure(java.lang.Exception: oops!)

scala&gt; val roundEx = tryEx.validating(isRound)
roundEx: scala.util.Try[Int] = Failure(java.lang.Exception: oops!)
</pre></p><p>The <code>validating</code> method accepts one or more validation functions. If you
pass more than one, they will be tried in order up until the first failure, whose
error message will appear in the <code>ValidationFailedException</code>. In other words,
<code>validating</code> will short circuit at the first error and return that. It
will not accumulate errors. For example, the following validation will short circuit
after the <code>isDivBy3</code> function fails:</p><p><pre class="stREPL">
scala&gt; def isDivBy3(i: Int): Validation[ErrorMessage] =
     |   if (i % 3 == 0) Pass else Fail(i + " was not divisible by 3")
isDivBy3: (i: Int)org.scalactic.Validation[org.scalactic.ErrorMessage]

scala&gt; def isAnswerToLifeTheUniverseAndEverything(i: Int): Validation[ErrorMessage] =
     |   if (i == 42) Pass else Fail(i + " did not equal 42")
isAnswerToLifeTheUniverseAndEverything: (i: Int)org.scalactic.Validation[org.scalactic.ErrorMessage]

scala&gt; try100.validating(isRound, isDivBy3, isAnswerToLifeTheUniverseAndEverything)
res0: scala.util.Try[Int] = Failure(org.scalactic.exceptions.ValidationFailedException: 100 was not divisible by 3)
</pre></p><p>Here are some examples of the <code>toOr</code> method:</p><p><pre class="stREPL">
scala&gt; try100.toOr
res1: org.scalactic.Or[Int,Throwable] = Good(100)

scala&gt; tryEx.toOr
res2: org.scalactic.Or[Int,Throwable] = Bad(java.lang.Exception: oops!)
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.TypeCheckedTripleEquals" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="TypeCheckedTripleEqualsextendsLowPriorityTypeCheckedConstraint"></a><a id="TypeCheckedTripleEquals:TypeCheckedTripleEquals"></a> <span class="permalink"><a href="../../org/scalactic/TypeCheckedTripleEquals.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="TypeCheckedTripleEquals.html" title="Provides === and !== operators that return Boolean, delegate the equality determination to an Equality type class, and require the types of the two values compared to be in a subtype/supertype relationship."><span class="name">TypeCheckedTripleEquals</span></a><span class="result"> extends <a href="LowPriorityTypeCheckedConstraint.html" name="org.scalactic.LowPriorityTypeCheckedConstraint" id="org.scalactic.LowPriorityTypeCheckedConstraint" class="extype">LowPriorityTypeCheckedConstraint</a></span></span><p class="shortcomment cmt">Provides <code>===</code> and <code>!==</code> operators that return <code>Boolean</code>, delegate the equality determination
to an <code>Equality</code> type class, and require the types of the two values compared to be in a subtype/supertype
relationship.</p><div class="fullcomment"><div class="comment cmt"><p>Provides <code>===</code> and <code>!==</code> operators that return <code>Boolean</code>, delegate the equality determination
to an <code>Equality</code> type class, and require the types of the two values compared to be in a subtype/supertype
relationship.</p><p><table><tr><td class="usage">
<strong>Recommended Usage</strong>:
Trait <code>TypeCheckedTripleEquals</code> is useful (in both production and test code) when you need a stricter type check
than is provided by the <a href="http://www.scalactic.org/supersafe">SuperSafe Community Edition</a> compiler plugin for
<a href="TripleEquals.html"><code>TripleEquals</code></a>. For example, if you are developing a library that uses advanced
features of Scala's type system, you may want to enforce in your tests that the types appearing
in equality comparisons match exactly.
</td></tr></table></p><p>By default under <code>TripleEquals</code>, any use of <code>===</code> will compile, just like the <code>==</code> operator:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TripleEquals._
import TripleEquals._

scala&gt; 1L === 1 // A Long can equal an Int
res0: Boolean = true

scala&gt; List(1, 2, 3) === Vector(1, 2, 3) // A List can equal a Vector
res1: Boolean = true

scala&gt; "hi" === 1 // Likely a bug, because a String can never equal an Int
res2: Boolean = false
</pre></p><p>With <a href="http://www.scalactic.org/supersafe">SuperSafe Community Edition</a> installed, the first two expressions
above will be allowed to compile, but the third (which represents a likely bug) will not:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TripleEquals._
import TripleEquals._

scala&gt; 1L === 1
res0: Boolean = true

scala&gt; List(1, 2, 3) === Vector(1, 2, 3)
res1: Boolean = true

scala&gt; "hi" === 1 // SuperSafe catches the bug at compile time
&lt;console&gt;:17: error: [Artima SuperSafe] Values of type String and Int may not be compared with
the === operator. If you really want to compare them for equality, configure Artima SuperSafe to allow
those types to be compared for equality.  For more information on this kind of error, see:
http://www.artima.com/supersafe_user_guide.html#safer-equality
       "hi" === 1
            ^
</pre></p><p>By contrast, <code>TypeCheckedTripleEquals</code> will prevent any of the above three expressions from compiling:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TypeCheckedTripleEquals._
import TypeCheckedTripleEquals._

scala&gt; 1L === 1
&lt;console&gt;:17: error: types Long and Int do not adhere to the type constraint selected for
    the === and !== operators; the missing implicit parameter is of type org.scalactic.CanEqual[Long,Int]
       1L === 1
          ^

scala&gt; List(1, 2, 3) === Vector(1, 2, 3)
&lt;console&gt;:17: error: types List[Int] and scala.collection.immutable.Vector[Int] do not adhere
    to the type constraint selected for the === and !== operators; the missing implicit parameter is
    of type org.scalactic.CanEqual[List[Int],scala.collection.immutable.Vector[Int]]
       List(1, 2, 3) === Vector(1, 2, 3)
                     ^

scala&gt; "hi" === 1
&lt;console&gt;:17: error: types String and Int do not adhere to the type constraint selected for
    the === and !== operators; the missing implicit parameter is of type org.scalactic.CanEqual[String,Int]
       "hi" === 1
            ^
</pre></p><p>Trait <code>TypeCheckedTripleEquals</code> rejects comparisons of types <code>Int</code> and <code>Long</code>, <code>List[Int]</code>
and <code>Vector[Int]</code>, and <code>String</code> and <code>Int</code>, because none have a direct subtype/supertype relationship.
To compare two types that are unrelated by inheritance under <code>TypeCheckedTripleEquals</code>, you could
convert one of them to the other type (because a type is both a subtype and supertype of itself). Here's an example:</p><p><pre class="stREPL">
scala&gt; 1L === 1.toLong // Now both sides are Long
res0: Boolean = true

scala&gt; List(1, 2, 3) === Vector(1, 2, 3).toList // Now both sides are List[Int]
res1: Boolean = true
</pre></p><p>Nevertheless, a better (and the recommended) way to deal with this situation is to use a <em>widening type ascription</em>.
A type ascription is simply a colon and a type placed next to a variable, usually surrounded by parentheses.
For example, because <code>AnyVal</code> is a common supertype of <code>Int</code> and <code>Long</code>,
you could solve the type error by widening the type of one side or the other to <code>AnyVal</code>.
Because <code>AnyVal</code> is a supertype of both <code>Int</code> and <code>Long</code>, the
type constraint will be satisfied:</p><p><pre class="stREPL">
scala&gt; 1 === (1L: AnyVal)
res2: Boolean = true

scala&gt; (1: AnyVal) === 1L
res3: Boolean = true
</pre></p><p>Similarly, since <code>Seq[Int]</code> is a common supertype of both
<code>Vector[Int]</code> and <code>List[Int]</code>, the type constraint can be
satisfied by widening either to their common supertype, <code>Seq[Int]</code>:</p><p><pre class="stREPL">
scala&gt; List(1, 2, 3) === (Vector(1, 2, 3): Seq[Int])
res4: Boolean = true

scala&gt; (List(1, 2, 3): Seq[Int]) === Vector(1, 2, 3)
res5: Boolean = true
</pre></p><p>The primary intended use case for <code>TypeCheckedTripleEquals</code> is to enable tests to be very strict
about which types can compared for equality, but it can also be used with production code where this level of
strictness is desired.</p><h4> Forcing implicit conversions before equality checks </h4><p>You can also use a type ascription to force an implicit conversion before a value participates
in an equality comparison. For example, although <code>JavaConversions</code> provides
an implicit conversion between <code>java.util.Set</code> and <code>scala.collection.mutable.Set</code>,
under <code>TypeCheckedTripleEquals</code> an equality comparison between those two types
will not be allowed:</p><p><pre class="stREPL">
scala&gt; import collection.JavaConversions._
import collection.JavaConversions._

scala&gt; import collection.mutable
import collection.mutable

scala&gt; import TypeCheckedTripleEquals._
import TypeCheckedTripleEquals._

scala&gt; mutable.Set.empty[String] === new java.util.HashSet[String]
&lt;console&gt;:36: error: types scala.collection.mutable.Set[String] and java.util.HashSet[String] do not
    adhere to the type constraint selected for the === and !== operators; the missing implicit parameter
    is of type org.scalactic.CanEqual[scala.collection.mutable.Set[String],java.util.HashSet[String]]
       mutable.Set.empty[String] === new java.util.HashSet[String]
                                 ^
</pre></p><p>To force an implicit conversion of the Java <code>HashSet</code> to a Scala <code>mutable.Set</code>, after which the
type constraint will be satisfied, you can use a type ascription:</p><p><pre class="stREPL">
scala&gt; mutable.Set.empty[String] === (new java.util.HashSet[String]: mutable.Set[String])
res0: Boolean = true
</pre></p><h4> Scoping equality policies </h4><p>This trait will override or hide implicit methods defined by
<a href="TripleEquals.html"><code>TripleEquals</code></a>
and can therefore be used to temporarily turn on or off type checking in a limited scope. Here's an example, in which <code>TypeCheckedTripleEquals</code> will
cause a compiler error:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalactic._
<span class="stReserved">import</span> TypeCheckedTripleEquals._
<br/><span class="stReserved">object</span> <span class="stType">Example</span> {
<br/>  <span class="stReserved">def</span> cmp(a: <span class="stType">Int</span>, b: <span class="stType">Long</span>): <span class="stType">Int</span> = {
    <span class="stReserved">if</span> (a === b) <span class="stLiteral">0</span>       <span class="stLineComment">// This line won't compile</span>
    <span class="stReserved">else</span> <span class="stReserved">if</span> (a &lt; b) -<span class="stLiteral">1</span>
    <span class="stReserved">else</span> <span class="stLiteral">1</span>
  }
<br/> <span class="stReserved">def</span> cmp(s: <span class="stType">String</span>, t: <span class="stType">String</span>): <span class="stType">Int</span> = {
   <span class="stReserved">if</span> (s === t) <span class="stLiteral">0</span>
   <span class="stReserved">else</span> <span class="stReserved">if</span> (s &lt; t) -<span class="stLiteral">1</span>
   <span class="stReserved">else</span> <span class="stLiteral">1</span>
 }
}
</pre></p><p>Because <code>Int</code> and <code>Long</code> are not in a subtype/supertype relationship, comparing <code>1</code> and <code>1L</code> in the context
of <code>TypeCheckedTripleEquals</code> will generate a compiler error:</p><p><pre>
Example.scala:9: error: types Int and Long do not adhere to the type constraint selected
  for the === and !== operators; the missing implicit parameter is of
  type org.scalactic.CanEqual[Int,Long]
        if (a === b) 0       // This line won't compile
              ^
one error found
</pre></p><p>You can &ldquo;relax&rdquo; the type checking locally by importing
the members of <code>TripleEquals</code> in a limited scope:</p><p><pre class="stHighlighted">
<span class="stReserved">package</span> org.scalactic.examples.conversioncheckedtripleequals
<br/><span class="stReserved">import</span> org.scalactic._
<span class="stReserved">import</span> TypeCheckedTripleEquals._
<br/><span class="stReserved">object</span> <span class="stType">Example</span> {
<br/>  <span class="stReserved">def</span> cmp(a: <span class="stType">Int</span>, b: <span class="stType">Long</span>): <span class="stType">Int</span> = {
    <span class="stReserved">import</span> TripleEquals._
    <span class="stReserved">if</span> (a === b) <span class="stLiteral">0</span>
    <span class="stReserved">else</span> <span class="stReserved">if</span> (a &lt; b) -<span class="stLiteral">1</span>
    <span class="stReserved">else</span> <span class="stLiteral">1</span>
  }
<br/> <span class="stReserved">def</span> cmp(s: <span class="stType">String</span>, t: <span class="stType">String</span>): <span class="stType">Int</span> = {
   <span class="stReserved">if</span> (s === t) <span class="stLiteral">0</span>
   <span class="stReserved">else</span> <span class="stReserved">if</span> (s &lt; t) -<span class="stLiteral">1</span>
   <span class="stReserved">else</span> <span class="stLiteral">1</span>
 }
}
</pre></p><p>With the above change, the <code>Example.scala</code> file compiles fine. The strict checking is disabled only inside the first <code>cmp</code> method that
takes an <code>Int</code> and a <code>Long</code>. <code>TypeCheckedTripleEquals</code> is still enforcing its type constraint, for example, for the <code>s === t</code>
expression in the other overloaded <code>cmp</code> method that takes strings.</p><p>Because the methods <code>TripleEquals</code> and <code>TypeCheckedTripleEquals</code>
<em>override</em> all the methods defined in supertype <a href="TripleEqualsSupport.html"><code>TripleEqualsSupport</code></a>, you can achieve the same
kind of nested tuning of equality constraints whether you mix in traits, import from companion objects, or use some combination of both.</p><p>In short, you should be able to select a primary constraint level via either a mixin or import, then change that in nested scopes
however you want, again either through a mixin or import, without getting any implicit conversion ambiguity. The innermost constraint level in scope
will always be in force.</p></div></div></li><li class="indented0 " name="org.scalactic.Uniformity" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="Uniformity[A]extendsNormalization[A]"></a><a id="Uniformity[A]:Uniformity[A]"></a> <span class="permalink"><a href="../../org/scalactic/Uniformity.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Uniformity.html" title="Defines a custom way to normalize instances of a type that can also handle normalization of that type when passed as Any."><span class="name">Uniformity</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <a href="Normalization.html" name="org.scalactic.Normalization" id="org.scalactic.Normalization" class="extype">Normalization</a>[<span name="org.scalactic.Uniformity.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Defines a custom way to normalize instances of a type that can also handle normalization of that type when passed as <code>Any</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Defines a custom way to normalize instances of a type that can also handle normalization of that type when passed as <code>Any</code>.</p><p>For example, to normalize <code>Double</code>s by truncating off any decimal part,
you might write:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalactic._
<br/><span class="stReserved">val</span> truncated =
  <span class="stReserved">new</span> <span class="stType">Uniformity[Double]</span> {
   <span class="stReserved">def</span> normalized(d: <span class="stType">Double</span>) = d.floor
   <span class="stReserved">def</span> normalizedCanHandle(o: <span class="stType">Any</span>) = o.isInstanceOf[<span class="stType">Double</span>]
   <span class="stReserved">def</span> normalizedOrSame(o: <span class="stType">Any</span>): <span class="stType">Any</span> =
     o <span class="stReserved">match</span> {
       <span class="stReserved">case</span> d: <span class="stType">Double</span> =&gt; normalized(d)
       <span class="stReserved">case</span> _ =&gt; o
     }
 }
</pre></p><p>Given this definition you could use it with the <a href="Explicitly.html"><code>Explicitly</code></a> DSL like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest._
<span class="stReserved">import</span> Matchers._
<br/><span class="stLiteral">2.1</span> should equal (<span class="stLiteral">2.0</span>) (after being truncated)
</pre></p><p>If you make the <code>truncated</code> <code>val</code> implicit and import or mix in the members of <a href="NormMethods.html"><code>NormMethods</code></a>,
you can access the behavior by invoking <code>.norm</code> on <code>Double</code>s.</p><p><pre class="stHighlighted">
<span class="stReserved">implicit</span> <span class="stReserved">val</span> doubleUniformity = truncated
<span class="stReserved">import</span> NormMethods._
<br/><span class="stReserved">val</span> d = <span class="stLiteral">2.1</span>
d.norm <span class="stLineComment">// returns 2.0</span>
</pre></p><p>Note that by creating a <code>Uniformity</code> rather than just an instance of its supertype, <a href="Normalization.html"><code>Normalization</code></a>,
it can be used more generally. For example, <code>Uniformity</code>s allow you to the <code>Explicitly</code> DSL with
<a href="TripleEquals.html"><code>TripleEquals</code></a>, whereas <code>Normalization</code>s require
<a href="TypeCheckedTripleEquals.html"><code>TypeCheckedTripleEquals</code></a>.
<code>Uniformity</code>s also enable you to use the <code>Explicitly</code> DSL with ScalaTest's <code>should</code> <code>===</code>, <code>equal</code>,
and <code>contain</code> matcher syntax, whereas a plain <code>Normalization</code> can only be used with <code>should</code> <code>===</code>, and only
under <code>TypeCheckedTripleEquals</code>.</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>the type whose uniformity is being defined</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Validation" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="Validation[+E]extendsProductwithSerializable"></a><a id="Validation[+E]:Validation[E]"></a> <span class="permalink"><a href="../../org/scalactic/Validation.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">sealed </span> <span class="kind">trait</span></span> <span class="symbol"><a href="Validation.html" title="Represents the result of a validation, either the object Pass if the validation succeeded, else an instance of Fail containing an error value describing the validation failure."><span class="name">Validation</span></a><span class="tparams">[<span name="E">+E</span>]</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Represents the result of a <em>validation</em>, either the object <a href="Pass$.html"><code>Pass</code></a> if the validation
succeeded, else an instance of <a href="Fail.html"><code>Fail</code></a> containing an error value describing the validation failure.</p><div class="fullcomment"><div class="comment cmt"><p>Represents the result of a <em>validation</em>, either the object <a href="Pass$.html"><code>Pass</code></a> if the validation
succeeded, else an instance of <a href="Fail.html"><code>Fail</code></a> containing an error value describing the validation failure.</p><p><code>Validation</code>s are used to filter <a href="Or.html"><code>Or</code></a>s in <code>for</code> expressions or <code>filter</code> method calls.
For example, consider these methods:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalactic._
<br/><span class="stReserved">def</span> isRound(i: <span class="stType">Int</span>): <span class="stType">Validation[ErrorMessage]</span> =
  <span class="stReserved">if</span> (i % <span class="stLiteral">10</span> == <span class="stLiteral">0</span>) <span class="stType">Pass</span> <span class="stReserved">else</span> <span class="stType">Fail</span>(i + <span class="stQuotedString">" was not a round number"</span>)
<br/><span class="stReserved">def</span> isDivBy3(i: <span class="stType">Int</span>): <span class="stType">Validation[ErrorMessage]</span> =
  <span class="stReserved">if</span> (i % <span class="stLiteral">3</span> == <span class="stLiteral">0</span>) <span class="stType">Pass</span> <span class="stReserved">else</span> <span class="stType">Fail</span>(i + <span class="stQuotedString">" was not divisible by 3"</span>)
</pre></p><p>Because <code>isRound</code> and <code>isDivBy3</code> take an <code>Int</code> and return a <code>Validation[ErrorMessage]</code>, you
can use them in filters in <code>for</code> expressions involving <code>Or</code>s of type <code>Int</code> <code>Or</code> <code>ErrorMessage</code>.
Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">for</span> (i &lt;- <span class="stType">Good</span>(<span class="stLiteral">3</span>) <span class="stReserved">if</span> isRound(i) &amp;&amp; isDivBy3(i)) <span class="stReserved">yield</span> i
<span class="stLineComment">// Result: Bad(3 was not a round number)</span>
</pre></p><p><code>Validation</code>s can also be used to accumulate error using <code>when</code>, a method that's made available by trait <code>Accumulation</code> on
accumualting <code>Or</code>s (<code>Or</code>s whose <code>Bad</code> type is an <code>Every[T]</code>). Here are some examples:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> Accumulation._
<br/><span class="stReserved">for</span> (i &lt;- <span class="stType">Good</span>(<span class="stLiteral">3</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> i
<span class="stLineComment">// Result: Bad(One(3 was not a round number))</span>
<br/><span class="stReserved">for</span> (i &lt;- <span class="stType">Good</span>(<span class="stLiteral">4</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> i
<span class="stLineComment">// Result: Bad(Many(4 was not a round number, 4 was not divisible by 3))</span>
</pre></p><p>Note: You can think of <code>Validation</code> as an &ldquo;<code>Option</code> with attitude,&rdquo; where <code>Pass</code> is
a <code>None</code> that indicates validation success and <code>Fail</code> is a <code>Some</code> whose value describes
the validation failure.</p></div><dl class="paramcmts block"><dt class="tparam">E</dt><dd class="cmt"><p>the type of error value describing a validation failure for this <code>Validation</code></p></dd></dl></div></li></ol></div><div class="types members"><h3>Deprecated Type Members</h3><ol><li class="indented0 " name="org.scalactic.Chain" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Chain[+T]=org.scalactic.anyvals.NonEmptyList[T]"></a><a id="Chain[+T]:Chain[T]"></a> <span class="permalink"><a href="../../org/scalactic/index.html#Chain[+T]=org.scalactic.anyvals.NonEmptyList[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">type</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 3.1.0) Chain has been deprecated and will be removed in a future version of Scalactic. Please use org.scalactic.anyvals.NonEmptyList instead.">Chain</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result alias"> = <a href="anyvals/NonEmptyList.html" name="org.scalactic.anyvals.NonEmptyList" id="org.scalactic.anyvals.NonEmptyList" class="extype">NonEmptyList</a>[<span name="org.scalactic.Chain.T" class="extype">T</span>]</span></span><p class="shortcomment cmt"><strong>The name <code>org.scalactic.Chain</code> has been deprecated and will be removed in a future version of Scalactic. Please use
its new name, <code>org.scalatest.anyvals.NonEmptyList</code>, instead.</strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>The name <code>org.scalactic.Chain</code> has been deprecated and will be removed in a future version of Scalactic. Please use
its new name, <code>org.scalatest.anyvals.NonEmptyList</code>, instead.</strong></p><p>This type has been renamed for consistency with other '<code>NonEmpty</code>' anyvals.
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 3.1.0)</i> Chain has been deprecated and will be removed in a future version of Scalactic. Please use org.scalactic.anyvals.NonEmptyList instead.</p></dd></dl></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="org.scalactic#ScalacticVersion" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ScalacticVersion:String"></a> <span class="permalink"><a href="../../org/scalactic/index.html#ScalacticVersion:String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">ScalacticVersion</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><p class="shortcomment cmt">The version number of Scalactic.</p><div class="fullcomment"><div class="comment cmt"><p>The version number of Scalactic.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the Scalactic version number.</p></dd></dl></div></li><li class="indented0 " name="org.scalactic#attempt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="attempt[R](f:=&gt;R):org.scalactic.Or[R,Throwable]"></a><a id="attempt[R](=&gt;R):Or[R,Throwable]"></a> <span class="permalink"><a href="../../org/scalactic/index.html#attempt[R](f:=&gt;R):org.scalactic.Or[R,Throwable]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">attempt</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: =&gt; <span name="org.scalactic.attempt.R" class="extype">R</span></span>)</span><span class="result">: <a href="Or.html" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.attempt.R" class="extype">R</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span></span><p class="shortcomment cmt">Returns the result of evaluating the given block <code>f</code>, wrapped in a <code>Good</code>, or
if an exception is thrown, the <code>Throwable</code>, wrapped in a <code>Bad</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the result of evaluating the given block <code>f</code>, wrapped in a <code>Good</code>, or
if an exception is thrown, the <code>Throwable</code>, wrapped in a <code>Bad</code>.</p><p>Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; attempt { 2 / 1 }
res0: org.scalactic.Or[Int,Throwable] = Good(2)

scala&gt; attempt { 2 / 0 }
res1: org.scalactic.Or[Int,Throwable] = Bad(java.lang.ArithmeticException: / by zero)
</pre>
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the block to attempt to evaluate</p></dd><dt>returns</dt><dd class="cmt"><p>the result of evaluating the block, wrapped in a <code>Good</code>, or the
    thrown exception, wrapped in a <code>Bad</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Accumulation" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Accumulation"></a><a id="Accumulation:Accumulation"></a> <span class="permalink"><a href="../../org/scalactic/Accumulation$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Accumulation$.html" title="Companion object to trait Accumulation that allows Accumulation's members to be imported rather than mixed in, and also contains nested traits used by implicit conversions declared in trait Accumulations."><span class="name">Accumulation</span></a><span class="result"> extends <a href="Accumulation.html" name="org.scalactic.Accumulation" id="org.scalactic.Accumulation" class="extype">Accumulation</a></span></span><p class="shortcomment cmt">Companion object to trait <code>Accumulation</code> that allows <code>Accumulation</code>'s members to be imported
rather than mixed in, and also contains nested traits used by implicit conversions declared in
trait <code>Accumulations</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object to trait <code>Accumulation</code> that allows <code>Accumulation</code>'s members to be imported
rather than mixed in, and also contains nested traits used by implicit conversions declared in
trait <code>Accumulations</code>.</p><p>For more information and examples, see the <a href="Or.html#accumulatingErrors">Accumulating errors with <code>Or</code></a> section
of the main documentation for class <code>Or</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.Bool" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Bool"></a><a id="Bool:Bool"></a> <span class="permalink"><a href="../../org/scalactic/Bool$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Bool$.html" title="Bool companion object that provides factory methods to create different sub types of Bool"><span class="name">Bool</span></a></span><p class="shortcomment cmt"><code>Bool</code> companion object that provides factory methods to create different sub types of <code>Bool</code></p><div class="fullcomment"><div class="comment cmt"><p><code>Bool</code> companion object that provides factory methods to create different sub types of <code>Bool</code></p><p><code>Bool</code> is used by code generated from <code>BooleanMacro</code> (which <code>AssertionsMacro</code> and <code>RequirementsMacro</code> uses),
it needs to be public so that the generated code can be compiled.  It is expected that ScalaTest users would ever need to use <code>Bool</code> directly.
</p></div></div></li><li class="indented0 " name="org.scalactic.Catcher" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Catcher"></a><a id="Catcher:Catcher"></a> <span class="permalink"><a href="../../org/scalactic/Catcher$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Catcher$.html" title="Companion object for Catcher that provides a factory method for creating Throwable extractors."><span class="name">Catcher</span></a></span><p class="shortcomment cmt">Companion object for <code>Catcher</code> that provides a factory method for creating <code>Throwable</code> extractors.</p></li><li class="indented0 " name="org.scalactic.DefaultEquality" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="DefaultEquality"></a><a id="DefaultEquality:DefaultEquality"></a> <span class="permalink"><a href="../../org/scalactic/DefaultEquality$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="DefaultEquality$.html" title=""><span class="name">DefaultEquality</span></a></span></li><li class="indented0 " name="org.scalactic.Equality" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Equality"></a><a id="Equality:Equality"></a> <span class="permalink"><a href="../../org/scalactic/Equality$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Equality$.html" title="Companion object for trait Equality that provides factory methods for producing Equality instances."><span class="name">Equality</span></a></span><p class="shortcomment cmt">Companion object for trait <code>Equality</code> that provides factory methods for producing <code>Equality</code>
instances.</p></li><li class="indented0 " name="org.scalactic.Equivalence" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Equivalence"></a><a id="Equivalence:Equivalence"></a> <span class="permalink"><a href="../../org/scalactic/Equivalence$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Equivalence$.html" title="Companion object for trait Equivalence that provides a factory method for producing default Equivalence instances."><span class="name">Equivalence</span></a></span><p class="shortcomment cmt">Companion object for trait <code>Equivalence</code> that provides a factory method for producing
default <code>Equivalence</code> instances.</p></li><li class="indented0 " name="org.scalactic.Every" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Every"></a><a id="Every:Every"></a> <span class="permalink"><a href="../../org/scalactic/Every$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Every$.html" title="Companion object for abstract class Every."><span class="name">Every</span></a><span class="result"> extends <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span><p class="shortcomment cmt">Companion object for abstract class <code>Every</code>.</p></li><li class="indented0 " name="org.scalactic.Explicitly" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Explicitly"></a><a id="Explicitly:Explicitly"></a> <span class="permalink"><a href="../../org/scalactic/Explicitly$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Explicitly$.html" title="Companion object for Explicitly, which enables the Scalactic explicitly DSL to be imported rather than mixed in, like this:"><span class="name">Explicitly</span></a><span class="result"> extends <a href="Explicitly.html" name="org.scalactic.Explicitly" id="org.scalactic.Explicitly" class="extype">Explicitly</a></span></span><p class="shortcomment cmt">Companion object for <code>Explicitly</code>, which enables the Scalactic explicitly DSL to
be imported rather than mixed in, like this:</p><div class="fullcomment"><div class="comment cmt"><p>Companion object for <code>Explicitly</code>, which enables the Scalactic explicitly DSL to
be imported rather than mixed in, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalactic._
<span class="stReserved">import</span> Explicitly._
<br/><span class="stLineComment">// Use the explicitly DSL...</span>
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.FutureSugar" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="FutureSugar"></a><a id="FutureSugar:FutureSugar"></a> <span class="permalink"><a href="../../org/scalactic/FutureSugar$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="FutureSugar$.html" title="Companion object for FutureSugar enabling its members to be imported as an alternative to mixing them in."><span class="name">FutureSugar</span></a><span class="result"> extends <a href="FutureSugar.html" name="org.scalactic.FutureSugar" id="org.scalactic.FutureSugar" class="extype">FutureSugar</a></span></span><p class="shortcomment cmt">Companion object for <code>FutureSugar</code> enabling its members to be
imported as an alternative to mixing them in.</p></li><li class="indented0 " name="org.scalactic.Good" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Good"></a><a id="Good:Good"></a> <span class="permalink"><a href="../../org/scalactic/Good$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Good$.html" title="Companion object for Good that offers, in addition to the standard factory method for Good that takes single &amp;ldquo;good&amp;rdquo; type, an parameterless apply used to narrow the Good type when creating a Bad."><span class="name">Good</span></a><span class="result"> extends <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span><p class="shortcomment cmt">Companion object for <code>Good</code> that offers, in addition to the standard factory method
for <code>Good</code> that takes single &ldquo;good&rdquo; type, an parameterless <a code>apply</code>
used to narrow the <code>Good</code> type when creating a <code>Bad</code>.
</a></p><div class="fullcomment"><div class="comment cmt"><p>Companion object for <code>Good</code> that offers, in addition to the standard factory method
for <code>Good</code> that takes single &ldquo;good&rdquo; type, an parameterless <a code>apply</code>
used to narrow the <code>Good</code> type when creating a <code>Bad</code>.
</p></div></div></li><li class="indented0 " name="org.scalactic.MapEqualityConstraints" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="MapEqualityConstraints"></a><a id="MapEqualityConstraints:MapEqualityConstraints"></a> <span class="permalink"><a href="../../org/scalactic/MapEqualityConstraints$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="MapEqualityConstraints$.html" title="Companion object that facilitates the importing of MapEqualityConstraints members as an alternative to mixing it in."><span class="name">MapEqualityConstraints</span></a><span class="result"> extends <a href="MapEqualityConstraints.html" name="org.scalactic.MapEqualityConstraints" id="org.scalactic.MapEqualityConstraints" class="extype">MapEqualityConstraints</a></span></span><p class="shortcomment cmt">Companion object that facilitates the importing of <code>MapEqualityConstraints</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>MapEqualityConstraints</code> members as
an alternative to mixing it in. One use case is to import <code>MapEqualityConstraints</code> members so you can use
them in the Scala interpreter.
</p></div></div></li><li class="indented0 " name="org.scalactic.NormMethods" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NormMethods"></a><a id="NormMethods:NormMethods"></a> <span class="permalink"><a href="../../org/scalactic/NormMethods$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NormMethods$.html" title="Companion object for NormMethods enabling its members to be imported as an alternative to mixing them in."><span class="name">NormMethods</span></a><span class="result"> extends <a href="NormMethods.html" name="org.scalactic.NormMethods" id="org.scalactic.NormMethods" class="extype">NormMethods</a></span></span><p class="shortcomment cmt">Companion object for <code>NormMethods</code> enabling its members to be imported as an alternative to mixing them in.</p></li><li class="indented0 " name="org.scalactic.OptionSugar" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="OptionSugar"></a><a id="OptionSugar:OptionSugar"></a> <span class="permalink"><a href="../../org/scalactic/OptionSugar$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="OptionSugar$.html" title="Companion object for OptionSugar enabling its members to be imported as an alternative to mixing them in."><span class="name">OptionSugar</span></a><span class="result"> extends <a href="OptionSugar.html" name="org.scalactic.OptionSugar" id="org.scalactic.OptionSugar" class="extype">OptionSugar</a></span></span><p class="shortcomment cmt">Companion object for <code>OptionSugar</code> enabling its members to be
imported as an alternative to mixing them in.</p></li><li class="indented0 " name="org.scalactic.Or" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Or"></a><a id="Or:Or"></a> <span class="permalink"><a href="../../org/scalactic/Or$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Or$.html" title="The companion object for Or providing factory methods for creating Ors from Eithers and Trys."><span class="name">Or</span></a><span class="result"> extends <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span><p class="shortcomment cmt">The companion object for <code>Or</code> providing factory methods for creating <code>Or</code>s from <code>Either</code>s and <code>Try</code>s.</p></li><li class="indented0 " name="org.scalactic.Pass" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Pass"></a><a id="Pass:Pass"></a> <span class="permalink"><a href="../../org/scalactic/Pass$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="Pass$.html" title="Indicates a validation succeeded."><span class="name">Pass</span></a><span class="result"> extends <a href="Validation.html" name="org.scalactic.Validation" id="org.scalactic.Validation" class="extype">Validation</a>[<span name="scala.Nothing" class="extype">Nothing</span>] with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Indicates a validation succeeded.</p></li><li class="indented0 " name="org.scalactic.Prettifier" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Prettifier"></a><a id="Prettifier:Prettifier"></a> <span class="permalink"><a href="../../org/scalactic/Prettifier$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Prettifier$.html" title="Companion object for Prettifier that provides a default Prettifier implementation."><span class="name">Prettifier</span></a><span class="result"> extends <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span><p class="shortcomment cmt">Companion object for <code>Prettifier</code> that provides a default <code>Prettifier</code> implementation.</p></li><li class="indented0 " name="org.scalactic.PrettyMethods" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PrettyMethods"></a><a id="PrettyMethods:PrettyMethods"></a> <span class="permalink"><a href="../../org/scalactic/PrettyMethods$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PrettyMethods$.html" title="Companion object for trait PrettyMethods enabling its members to be imported as an alternative to mixing them in."><span class="name">PrettyMethods</span></a><span class="result"> extends <a href="PrettyMethods.html" name="org.scalactic.PrettyMethods" id="org.scalactic.PrettyMethods" class="extype">PrettyMethods</a></span></span><p class="shortcomment cmt">Companion object for trait <code>PrettyMethods</code> enabling its members to be imported as an
alternative to mixing them in.</p></li><li class="indented0 " name="org.scalactic.Requirements" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Requirements"></a><a id="Requirements:Requirements"></a> <span class="permalink"><a href="../../org/scalactic/Requirements$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Requirements$.html" title="Companion object that facilitates the importing of Requirements members as an alternative to mixing it in."><span class="name">Requirements</span></a><span class="result"> extends <a href="Requirements.html" name="org.scalactic.Requirements" id="org.scalactic.Requirements" class="extype">Requirements</a></span></span><p class="shortcomment cmt">Companion object that facilitates the importing of <code>Requirements</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>Requirements</code> members as
an alternative to mixing it in. One use case is to import <code>Requirements</code> members so you can use
them in the Scala interpreter:</p><p><pre class="stREPL">
$scala -classpath scalatest.jar
Welcome to Scala version 2.10.3.final (Java HotSpot(TM) Client VM, Java xxxxxx).
Type in expressions to have them evaluated.
Type :help for more information.
&nbsp;
scala&gt; import org.scalactic.Requirements._
import org.scalactic.Requirements._
&nbsp;
scala&gt; val a = 1
a: Int = 1
&nbsp;
scala&gt; require(a == 2)
java.lang.IllegalArgumentException: 1 did not equal 2
     at org.scalactic.Requirements$RequirementsHelper.macroRequire(Requirements.scala:56)
     at .&lt;init&gt;(&lt;console&gt;:20)
     at .&lt;clinit&gt;(&lt;console&gt;)
     at .&lt;init&gt;(&lt;console&gt;:7)
     at .&lt;clinit&gt;(&lt;console&gt;)
     at $print(&lt;console&gt;)
     at sun.reflect.NativeMethodAccessorImpl.invoke...
</p></div></div></li><li class="indented0 " name="org.scalactic.SeqEqualityConstraints" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="SeqEqualityConstraints"></a><a id="SeqEqualityConstraints:SeqEqualityConstraints"></a> <span class="permalink"><a href="../../org/scalactic/SeqEqualityConstraints$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="SeqEqualityConstraints$.html" title="Companion object that facilitates the importing of SeqEqualityConstraints members as an alternative to mixing it in."><span class="name">SeqEqualityConstraints</span></a><span class="result"> extends <a href="SeqEqualityConstraints.html" name="org.scalactic.SeqEqualityConstraints" id="org.scalactic.SeqEqualityConstraints" class="extype">SeqEqualityConstraints</a></span></span><p class="shortcomment cmt">Companion object that facilitates the importing of <code>SeqEqualityConstraints</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>SeqEqualityConstraints</code> members as
an alternative to mixing it in. One use case is to import <code>SeqEqualityConstraints</code> members so you can use
them in the Scala interpreter.
</p></div></div></li><li class="indented0 " name="org.scalactic.SetEqualityConstraints" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="SetEqualityConstraints"></a><a id="SetEqualityConstraints:SetEqualityConstraints"></a> <span class="permalink"><a href="../../org/scalactic/SetEqualityConstraints$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="SetEqualityConstraints$.html" title="Companion object that facilitates the importing of SetEqualityConstraints members as an alternative to mixing it in."><span class="name">SetEqualityConstraints</span></a><span class="result"> extends <a href="SetEqualityConstraints.html" name="org.scalactic.SetEqualityConstraints" id="org.scalactic.SetEqualityConstraints" class="extype">SetEqualityConstraints</a></span></span><p class="shortcomment cmt">Companion object that facilitates the importing of <code>SetEqualityConstraints</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>SetEqualityConstraints</code> members as
an alternative to mixing it in. One use case is to import <code>SetEqualityConstraints</code> members so you can use
them in the Scala interpreter.
</p></div></div></li><li class="indented0 " name="org.scalactic.SnapshotSeq" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="SnapshotSeq"></a><a id="SnapshotSeq:SnapshotSeq"></a> <span class="permalink"><a href="../../org/scalactic/SnapshotSeq$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="SnapshotSeq$.html" title=""><span class="name">SnapshotSeq</span></a></span></li><li class="indented0 " name="org.scalactic.Snapshots" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Snapshots"></a><a id="Snapshots:Snapshots"></a> <span class="permalink"><a href="../../org/scalactic/Snapshots$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Snapshots$.html" title="Companion object that facilitates the importing of Snapshots members as an alternative to mixing it in."><span class="name">Snapshots</span></a><span class="result"> extends <a href="Snapshots.html" name="org.scalactic.Snapshots" id="org.scalactic.Snapshots" class="extype">Snapshots</a></span></span><p class="shortcomment cmt">Companion object that facilitates the importing of <code>Snapshots</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>Snapshots</code> members as
an alternative to mixing it in. One use case is to import <code>Snapshots</code> members so you can use
them in the Scala interpreter:</p><p><pre class="stREPL">
$scala -classpath scalatest.jar
Welcome to Scala version 2.10.3.final (Java HotSpot(TM) Client VM, Java xxxxxx).
Type in expressions to have them evaluated.
Type :help for more information.
&nbsp;
scala&gt; import org.scalactic.Snapshots._
import org.scalatest.Snapshots._
&nbsp;
scala&gt; val a = 8
a: Int = 8
&nbsp;
scala&gt; snap(a)
res0: scala.collection.immutable.Vector[org.scalactic.Snapshot] = Vector(a = 8)
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.StringNormalizations" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="StringNormalizations"></a><a id="StringNormalizations:StringNormalizations"></a> <span class="permalink"><a href="../../org/scalactic/StringNormalizations$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="StringNormalizations$.html" title="Companion object to trait StringNormalizations that provides an alternative to mixing it in."><span class="name">StringNormalizations</span></a><span class="result"> extends <a href="StringNormalizations.html" name="org.scalactic.StringNormalizations" id="org.scalactic.StringNormalizations" class="extype">StringNormalizations</a></span></span><p class="shortcomment cmt">Companion object to trait <code>StringNormalizations</code> that provides an
alternative to mixing it in.</p></li><li class="indented0 " name="org.scalactic.TimesOnInt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="TimesOnInt"></a><a id="TimesOnInt:TimesOnInt"></a> <span class="permalink"><a href="../../org/scalactic/TimesOnInt$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="TimesOnInt$.html" title="Companion object that facilitates the importing of TimesOnInt members as an alternative to mixing it in."><span class="name">TimesOnInt</span></a><span class="result"> extends <a href="TimesOnInt.html" name="org.scalactic.TimesOnInt" id="org.scalactic.TimesOnInt" class="extype">TimesOnInt</a></span></span><p class="shortcomment cmt">Companion object that facilitates the importing of <code>TimesOnInt</code> members as an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>TimesOnInt</code> members as an alternative to mixing it in.</p><p>One use case of this companion object is to import <code>TimesOnInt</code> members so you can use them in the Scala interpreter.
Here's an example:</p><p><pre class="stREPL">
scala&gt; import org.scalatest.TimesOnInt._
import org.scalatest.TimesOnInt._

scala&gt; 3 times println("Hello again, world!")
Hello again, world!
Hello again, world!
Hello again, world!
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.Tolerance" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Tolerance"></a><a id="Tolerance:Tolerance"></a> <span class="permalink"><a href="../../org/scalactic/Tolerance$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Tolerance$.html" title="Companion object to trait Tolerance that facilitates the importing of Tolerance members as an alternative to mixing it in."><span class="name">Tolerance</span></a><span class="result"> extends <a href="Tolerance.html" name="org.scalactic.Tolerance" id="org.scalactic.Tolerance" class="extype">Tolerance</a></span></span><p class="shortcomment cmt">Companion object to trait <code>Tolerance</code> that facilitates the importing of <code>Tolerance</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object to trait <code>Tolerance</code> that facilitates the importing of <code>Tolerance</code> members as
an alternative to mixing it in. One use case is to import <code>Tolerance</code> members so you can use
them in the Scala interpreter:</p><p><pre class="stREPL">
$ scala -classpath scalactic.jar
Welcome to Scala version 2.10.0
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import Tolerance._
import Tolerance._

scala&gt; 1.0 +- 0.1
res0: org.scalactic.TripleEqualsSupport.Spread[Double] = Spread(1.0,0.1)
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.TolerantNumerics" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="TolerantNumerics"></a><a id="TolerantNumerics:TolerantNumerics"></a> <span class="permalink"><a href="../../org/scalactic/TolerantNumerics$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="TolerantNumerics$.html" title="Companion object for TolerantNumerics that enables its members to be imported as an alternative to mixing them in."><span class="name">TolerantNumerics</span></a><span class="result"> extends <a href="TolerantNumerics.html" name="org.scalactic.TolerantNumerics" id="org.scalactic.TolerantNumerics" class="extype">TolerantNumerics</a></span></span><p class="shortcomment cmt">Companion object for <code>TolerantNumerics</code> that enables its members to be imported as an alternative to
mixing them in.</p></li><li class="indented0 " name="org.scalactic.TraversableEqualityConstraints" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="TraversableEqualityConstraints"></a><a id="TraversableEqualityConstraints:TraversableEqualityConstraints"></a> <span class="permalink"><a href="../../org/scalactic/TraversableEqualityConstraints$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="TraversableEqualityConstraints$.html" title="Companion object that facilitates the importing of TraversableEqualityConstraints members as an alternative to mixing it in."><span class="name">TraversableEqualityConstraints</span></a><span class="result"> extends <a href="TraversableEqualityConstraints.html" name="org.scalactic.TraversableEqualityConstraints" id="org.scalactic.TraversableEqualityConstraints" class="extype">TraversableEqualityConstraints</a></span></span><p class="shortcomment cmt">Companion object that facilitates the importing of <code>TraversableEqualityConstraints</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object that facilitates the importing of <code>TraversableEqualityConstraints</code> members as
an alternative to mixing it in. One use case is to import <code>TraversableEqualityConstraints</code> members so you can use
them in the Scala interpreter.
</p></div></div></li><li class="indented0 " name="org.scalactic.TripleEquals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="TripleEquals"></a><a id="TripleEquals:TripleEquals"></a> <span class="permalink"><a href="../../org/scalactic/TripleEquals$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="TripleEquals$.html" title="Companion object to trait TripleEquals that facilitates the importing of TripleEquals members as an alternative to mixing it in."><span class="name">TripleEquals</span></a><span class="result"> extends <a href="TripleEquals.html" name="org.scalactic.TripleEquals" id="org.scalactic.TripleEquals" class="extype">TripleEquals</a></span></span><p class="shortcomment cmt">Companion object to trait <code>TripleEquals</code> that facilitates the importing of <code>TripleEquals</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object to trait <code>TripleEquals</code> that facilitates the importing of <code>TripleEquals</code> members as
an alternative to mixing it in. One use case is to import <code>TripleEquals</code> members so you can use
them in the Scala interpreter:</p><p><pre class="stREPL">
$ scala -classpath scalatest.jar
Welcome to Scala version 2.10.0
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TripleEquals._
import TripleEquals._

scala&gt; 1 + 1 === 2
res0: Boolean = true
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.TripleEqualsSupport" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="TripleEqualsSupport"></a><a id="TripleEqualsSupport:TripleEqualsSupport"></a> <span class="permalink"><a href="../../org/scalactic/TripleEqualsSupport$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="TripleEqualsSupport$.html" title=""><span class="name">TripleEqualsSupport</span></a></span></li><li class="indented0 " name="org.scalactic.TrySugar" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="TrySugar"></a><a id="TrySugar:TrySugar"></a> <span class="permalink"><a href="../../org/scalactic/TrySugar$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="TrySugar$.html" title="Companion object for TrySugar enabling its members to be imported as an alternative to mixing them in."><span class="name">TrySugar</span></a><span class="result"> extends <a href="TrySugar.html" name="org.scalactic.TrySugar" id="org.scalactic.TrySugar" class="extype">TrySugar</a></span></span><p class="shortcomment cmt">Companion object for <code>TrySugar</code> enabling its members to be
imported as an alternative to mixing them in.</p></li><li class="indented0 " name="org.scalactic.TypeCheckedTripleEquals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="TypeCheckedTripleEquals"></a><a id="TypeCheckedTripleEquals:TypeCheckedTripleEquals"></a> <span class="permalink"><a href="../../org/scalactic/TypeCheckedTripleEquals$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="TypeCheckedTripleEquals$.html" title="Companion object to trait TypeCheckedTripleEquals that facilitates the importing of TypeCheckedTripleEquals members as an alternative to mixing it in."><span class="name">TypeCheckedTripleEquals</span></a><span class="result"> extends <a href="TypeCheckedTripleEquals.html" name="org.scalactic.TypeCheckedTripleEquals" id="org.scalactic.TypeCheckedTripleEquals" class="extype">TypeCheckedTripleEquals</a></span></span><p class="shortcomment cmt">Companion object to trait <code>TypeCheckedTripleEquals</code> that facilitates the importing of <code>TypeCheckedTripleEquals</code> members as
an alternative to mixing it in.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object to trait <code>TypeCheckedTripleEquals</code> that facilitates the importing of <code>TypeCheckedTripleEquals</code> members as
an alternative to mixing it in. One use case is to import <code>TypeCheckedTripleEquals</code> members so you can use
them in the Scala interpreter:</p><p><pre class="stREPL">
$ scala -classpath scalatest.jar
Welcome to Scala version 2.10.0
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import org.scalactic._
import org.scalactic._

scala&gt; import TypeCheckedTripleEquals._
import TypeCheckedTripleEquals._

scala&gt; 1 + 1 === 2
res0: Boolean = true
</pre>
</p></div></div></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="org.scalactic#Chain" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Chain:org.scalactic.anyvals.NonEmptyList.type"></a><a id="Chain:NonEmptyList.type"></a> <span class="permalink"><a href="../../org/scalactic/index.html#Chain:org.scalactic.anyvals.NonEmptyList.type" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 3.1.0) Chain has been deprecated and will be removed in a future version of Scalactic. Please use org.scalactic.anyvals.NonEmptyList instead.">Chain</span><span class="result">: <a href="anyvals/NonEmptyList$.html" name="org.scalactic.anyvals.NonEmptyList" id="org.scalactic.anyvals.NonEmptyList" class="extype">NonEmptyList</a>.type</span></span><p class="shortcomment cmt"><strong>The name <code>org.scalactic.Chain</code> has been deprecated and will be removed in a future version of Scalactic. Please use
its new name, <code>org.scalatest.anyvals.NonEmptyList</code>, instead.</strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>The name <code>org.scalactic.Chain</code> has been deprecated and will be removed in a future version of Scalactic. Please use
its new name, <code>org.scalatest.anyvals.NonEmptyList</code>, instead.</strong></p><p>This type has been renamed for consistency with other '<code>NonEmpty</code>' anyvals.
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 3.1.0)</i> Chain has been deprecated and will be removed in a future version of Scalactic. Please use org.scalactic.anyvals.NonEmptyList instead.</p></dd></dl></div></li><li class="indented0 " name="org.scalactic#End" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="End:org.scalactic.anyvals.End.type"></a><a id="End:scalactic.anyvals.End.type"></a> <span class="permalink"><a href="../../org/scalactic/index.html#End:org.scalactic.anyvals.End.type" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 3.1.0) End has been deprecated and will be removed in a future version of Scalactic. Please use org.scalactic.anyvals.End instead.">End</span><span class="result">: <a href="anyvals/End$.html" name="org.scalactic.anyvals.End" id="org.scalactic.anyvals.End" class="extype">scalactic.anyvals.End</a>.type</span></span><p class="shortcomment cmt"><strong>The name <code>org.scalactic.End</code> has been deprecated and will be removed in a future version of Scalactic. Please use
its new name, <code>org.scalatest.anyvals.End</code>, instead.</strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>The name <code>org.scalactic.End</code> has been deprecated and will be removed in a future version of Scalactic. Please use
its new name, <code>org.scalatest.anyvals.End</code>, instead.</strong></p><p>This type has been renamed for consistency with other '<code>NonEmpty</code>' anyvals.
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 3.1.0)</i> End has been deprecated and will be removed in a future version of Scalactic. Please use org.scalactic.anyvals.End instead.</p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
