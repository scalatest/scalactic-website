<!DOCTYPE html >
<html>
        <head>
          <title>Or - Scalactic 3.0.0 - org.scalactic.Or</title>
          <meta name="description" content="Or - Scalactic 3.0.0 - org.scalactic.Or" />
          <meta name="keywords" content="Or Scalactic 3.0.0 org.scalactic.Or" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../index.html';
            var hash = 'org.scalactic.Or';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    


<!-- gtag [javascript] -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-19BZD1XMRV"></script>

<script defer>

window.dataLayer = window.dataLayer || [];

function gtag(){dataLayer.push(arguments);}

gtag('js', new Date());

gtag('config', 'G-19BZD1XMRV');

</script>
        </head>
        <body class="type">

<!-- Top of doc.scalactic.org [javascript] -->

<script id="adsArtimaScript" type="text/javascript" src="https://www.artima.com/assets/javascripts/3cbad67e7fa9539151489fd25cf64fdd-ads.js?product=Scalactic"></script>

      <div id="definition">
        <a href="Or$.html" title="See companion object"><img alt="Class/Object" src="../../lib/class_to_object_big.png" /></a>
        <p id="owner"><a href="../package.html" class="extype" name="org">org</a>.<a href="package.html" class="extype" name="org.scalactic">scalactic</a></p>
        <h1><a href="Or$.html" title="See companion object">Or</a></h1><h3><span class="morelinks"><div>
            Related Docs:
            <a href="Or$.html" title="See companion object">object Or</a>
            | <a href="package.html" class="extype" name="org.scalactic">package scalactic</a>
          </div></span></h3><span class="permalink">
      <a href="../../index.html#org.scalactic.Or" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">Or</span><span class="tparams">[<span name="G">+G</span>, <span name="B">+B</span>]</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Represents a value that is one of two possible types, with one type being &ldquo;good&rdquo; and
the other &ldquo;bad.&rdquo;</p><p>An <code>Or</code> will either be a &ldquo;good&rdquo; value wrapped in an instance of
<a href="Good.html"><code>Good</code></a> or a &ldquo;bad&rdquo; value wrapped in an instance
of <a href="Bad.html"><code>Bad</code></a>.</p><h4> The motivation for <code>Or</code> </h4><p><code>Or</code> differs from Scala's <code>Either</code> type in that
<code>Either</code> treats both its <code>Left</code> and <code>Right</code> alternatives in an identical manner, whereas
<code>Or</code> treats its two alternatives differently: it favors
<code>Good</code> over <code>Bad</code>.
Because of this, it is more convenient to work with <code>Or</code>s
when you prefer one alternative over the other; for example, if one alternative represents a valid result
and another represents an error.</p><p>To illustrate, imagine you want to create instances this <code>Person</code> class from user input strings:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Person</span>(name: <span class="stType">String</span>, age: <span class="stType">Int</span>)
</pre></p><p>You might write a method that parses the name from user input string and returns an
<code>Option[String]</code>: <code>None</code> if the string is empty or blank, else the
trimmed string wrapped in a <code>Some</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">Option[String]</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Some</span>(trimmed) <span class="stReserved">else</span> <span class="stType">None</span>
}
</pre></p><p>You might also write a method that parses the age from user input string and returns an
<code>Option[Int]</code>: <code>None</code> if either the string is not a valid integer or
it is a negative integer, else the string converted to an integer wrapped in a <code>Some</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Option[Int]</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Some</span>(age) <span class="stReserved">else</span> <span class="stType">None</span>
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">None</span>
  }
}
</pre></p><p>With these building blocks you could write a method that parses name and age input
strings and returns either a <code>Person</code>, wrapped in a <code>Some</code>, or
<code>None</code> if either the name or age, or both, was invalid:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Option[Person]</span> =
  <span class="stReserved">for</span> {
    name &lt;- parseName(inputName)
    age &lt;- parseAge(inputAge)
  } <span class="stReserved">yield</span> <span class="stType">Person</span>(name, age)
</pre></p><p>Here are some examples of invoking <code>parsePerson</code>:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Some(Person(Bridget Jones,29))</span>

parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: None</span>

parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: None</span>

parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: None</span>
</pre></p><p>Now imagine you want to give an error message back if the user's input is invalid.
You might rewrite the parsing methods to return an <code>Either</code> instead. In this
case, the desired result is a valid name or age, which by convention should be placed
on the right of the <code>Either</code>. The left will be a <code>String</code> error
message. Here's the new <code>parseName</code> function, which returns an <code>Either[String, String]</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">Either[String, String]</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Right</span>(trimmed) <span class="stReserved">else</span> <span class="stType">Left</span>(s<span class="stQuotedString">""""${input}" is not a valid name"""</span>)
}
</pre></p><p>And here's the new <code>parseAge</code> function, which returns an <code>Either[String, Int]</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Either[String, Int]</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Right</span>(age) <span class="stReserved">else</span> <span class="stType">Left</span>(s<span class="stQuotedString">""""${age}" is not a valid age"""</span>)
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">Left</span>(s<span class="stQuotedString">""""${input}" is not a valid integer"""</span>)
  }
}
</pre></p><p>The new <code>parsePerson</code> method will return an <code>Either[String, Person]</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Either[String, Person]</span> =
  <span class="stReserved">for</span> {
    name &lt;- parseName(inputName).right
    age &lt;- parseAge(inputAge).right
  } <span class="stReserved">yield</span> <span class="stType">Person</span>(name, age)
</pre></p><p>Note that <code>Either</code> requires you to add <code>.right</code>
at the end of each generator in the <code>for</code> expression. Although the convention is to place the
valid result on the right, you must explicitly (and repetitively) indicate that you've done so by transforming
the <code>Either</code> to a <code>RightProjection</code> by invoking <code>.right</code> at each step.
Given this implementation, the <code>parsePerson</code> method will now short-circuit at the first sign
of trouble (as it did when we used an <code>Option</code>), but you now get the first error message returned
in a <code>Left</code>. Here are some examples:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Right(Person(Bridget Jones,29))</span>

parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Left("" is not a valid integer)</span>

parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: Left("-29" is not a valid age)</span>

parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Left("" is not a valid name)</span>
</pre></p><h4> An <code>Either</code> with &ldquo;attitude&rdquo; </h4><p>Because <code>Or</code> declares one alternative to be &ldquo;good&rdquo; and the other &ldquo;bad,&rdquo;
it is more convenient than <code>Either</code> in this kind of situation. One difference to note with
<code>Or</code> is that the <code>Good</code> alternative is on the left, <code>Bad</code> on the right.
The reason is that <code>Or</code> is designed to be written using infix notation, and placing the
&ldquo;happy path&rdquo; first is more readable. For example, instead of writing:</p><p><pre class="stHighlighted">
<span class="stType">Or[Int, ErrorMessage]</span>
</pre></p><p>You can write:</p><p><pre class="stHighlighted">
<span class="stType">Int</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span>
</pre></p><p>Here's how the <code>parseName</code> method might be written using an <code>Or</code>, where
<code>ErrorMessage</code> is a type alias for <code>String</code> declared in the <code>org.scalactic</code>
package object:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalactic._

<span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">String</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Good</span>(trimmed) <span class="stReserved">else</span> <span class="stType">Bad</span>(s<span class="stQuotedString">""""${input}" is not a valid name"""</span>)
}
</pre></p><p>You can think of the <code>String</code> <code>Or</code> <code>ErrorMessage</code> result
type like this:</p><p><blockquote>
<em>The <code>parseName</code> method will return a name <code>String</code> or, if the input string
is not a valid name, an <code>ErrorMessage</code>.</em>
</blockquote></p><p>Here's how the <code>parseAge</code> method might be written:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Int</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Good</span>(age) <span class="stReserved">else</span> <span class="stType">Bad</span>(s<span class="stQuotedString">""""${age}" is not a valid age"""</span>)
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">Bad</span>(s<span class="stQuotedString">""""${input}" is not a valid integer"""</span>)
  }
}
</pre></p><p>Given these implementations, here's how you'd write the <code>parsePerson</code> method:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Person</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span> =
  <span class="stReserved">for</span> {
    name &lt;- parseName(inputName)
    age &lt;- parseAge(inputAge)
  } <span class="stReserved">yield</span> <span class="stType">Person</span>(name, age)
</pre></p><p>Because of <code>Or</code>'s attitude, you need not write <code>.good</code> at the end of
each generator. <code>Or</code> will keep going so long as each step produces a <code>Good</code>,
short circuiting at the first sign of a <code>Bad</code>. Here are a few invocations of this
<code>parsePerson</code> method:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Good(Person(Bridget Jones,29))</span>

parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad("" is not a valid integer)</span>

parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: Bad("-29" is not a valid age)</span>

parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad("" is not a valid name)</span>
</pre></p><p><a name="accumulatingErrors"></a></p><h4> Accumulating errors with <code>Or</code> </h4><p>Another difference between <code>Or</code> and <code>Either</code> is that <code>Or</code> enables
you to accumulate errors if the <code>Bad</code> type is an <a href="Every.html"><code>Every</code></a>.
An <code>Every</code> is similar to a <code>Seq</code> in that it contains ordered elements, but
different from <code>Seq</code> in that it cannot be empty. An <code>Every</code> is
either a <a href="One.html"><code>One</code></a>,
which contains one and only one element, or a <a href="Many.html"><code>Many</code></a>, which contains two or
more elements.</p><p><em>Note: an <code>Or</code> whose <code>Bad</code> type is an <code>Every</code>, or one of its subtypes,
is called an &ldquo;accumulating <code>Or</code>.&rdquo;</em></p><p>To rewrite the previous example so that errors can be accumulated, you need first to return an <code>Every</code>
as the <code>Bad</code> type. Here's how you'd change the <code>parseName</code> method:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">String</span> <span class="stType">Or</span> <span class="stType">One[ErrorMessage]</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Good</span>(trimmed) <span class="stReserved">else</span> <span class="stType">Bad</span>(<span class="stType">One</span>(s<span class="stQuotedString">""""${input}" is not a valid name"""</span>))
}
</pre></p><p>Because <code>parseName</code> will either return a valid name <code>String</code> wrapped in a
<code>Good</code>, or <em>one</em> error message, wrapped in a <code>Bad</code>, you would write the
<code>Bad</code> type as <code>One[ErrorMessage]</code>. The same is true for <code>parseAge</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Int</span> <span class="stType">Or</span> <span class="stType">One[ErrorMessage]</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Good</span>(age) <span class="stReserved">else</span> <span class="stType">Bad</span>(<span class="stType">One</span>(s<span class="stQuotedString">""""${age}" is not a valid age"""</span>))
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">Bad</span>(<span class="stType">One</span>(s<span class="stQuotedString">""""${input}" is not a valid integer"""</span>))
  }
}
</pre></p><p>Because a <code>for</code> expression short-circuits on the first <code>Bad</code> encountered, you'll
need to use a different approach to write the <code>parsePerson</code> method. In this example, the
<code>withGood</code> method from trait <a href="Accumulation.html"><code>Accumulation</code></a>
will do the trick:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> Accumulation._

<span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Person</span> <span class="stType">Or</span> <span class="stType">Every[ErrorMessage]</span> = {
  <span class="stReserved">val</span> name = parseName(inputName)
  <span class="stReserved">val</span> age = parseAge(inputAge)
  withGood(name, age) { <span class="stType">Person</span>(_, _) }
}
</pre></p><p>Trait <code>Accumulation</code> offers overloaded <code>withGood</code> methods that take 1 to
22 accumulating <code>Or</code>s, plus a function taking the same number of corresponding
<code>Good</code> values.  In this example, if both <code>name</code> and <code>age</code> are
<code>Good</code>s, the <code>withGood</code> method will pass the good name <code>String</code>
and age <code>Int</code> to the <code>Person(_, _)</code> function, and return the resulting <code>Person</code>
object wrapped in a <code>Good</code>. If either <code>name</code> and <code>age</code>, or both,
are <code>Bad</code>, <code>withGood</code> will return the accumulated errors in a <code>Bad</code>.</p><p>The result of <code>parsePerson</code>, if <code>Bad</code>, will therefore contain either one or two
error messages, <em>i.e.</em>, the result will either be a <code>One</code> or a <code>Many</code>.
As a result, the result type of <code>parsePerson</code> must be <code>Person</code> <code>Or</code>
<code>Every[ErrorMessage]</code>. Regardless of whether a <code>Bad</code> result contains one
or two error messages, it will contain <em>every</em> error message. Here's some invocations of
this accumulating version of <code>parsePerson</code>:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Good(Person(Bridget Jones,29))</span>

parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad(One("" is not a valid integer))</span>

parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: Bad(One("-29" is not a valid age))</span>

parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad(Many("" is not a valid name, "" is not a valid integer))</span>
</pre></p><p>Note that in the last example, the <code>Bad</code> contains an error message for both name and age.</p><h4> Other ways to accumulate errors </h4><p>The <code>Accumlation</code> trait also enables other ways of accumulating errors.</p><p><a name="usingCombined"></a></p><h5> Using <code>combined</code> </h5><p>If you have a collection of
accumulating <code>Or</code>s, for example, you can <em>combine</em> them into one <code>Or</code> using <code>combined</code>, like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(parseAge(<span class="stQuotedString">"29"</span>), parseAge(<span class="stQuotedString">"30"</span>), parseAge(<span class="stQuotedString">"31"</span>)).combined
<span class="stLineComment">// Result: Good(List(29, 30, 31))</span>

<span class="stType">List</span>(parseAge(<span class="stQuotedString">"29"</span>), parseAge(<span class="stQuotedString">"-30"</span>), parseAge(<span class="stQuotedString">"31"</span>)).combined
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>

<span class="stType">List</span>(parseAge(<span class="stQuotedString">"29"</span>), parseAge(<span class="stQuotedString">"-30"</span>), parseAge(<span class="stQuotedString">"-31"</span>)).combined
<span class="stLineComment">// Result: Bad(Many("-30" is not a valid age, "-31" is not a valid age))</span>
</pre></p><p><a name="usingValidatedBy"></a></p><h5> Using <code>validatedBy</code> </h5><p>Or if you have a collection of values and a function that transforms that type of value into an accumulating
<code>Or</code>s, you can validate the values using the function using <code>validatedBy</code>, like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stQuotedString">"29"</span>, <span class="stQuotedString">"30"</span>, <span class="stQuotedString">"31"</span>).validatedBy(parseAge)
<span class="stLineComment">// Result: Good(List(29, 30, 31))</span>

<span class="stType">List</span>(<span class="stQuotedString">"29"</span>, <span class="stQuotedString">"-30"</span>, <span class="stQuotedString">"31"</span>).validatedBy(parseAge)
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>

<span class="stType">List</span>(<span class="stQuotedString">"29"</span>, <span class="stQuotedString">"-30"</span>, <span class="stQuotedString">"-31"</span>).validatedBy(parseAge)
<span class="stLineComment">// Result: Bad(Many("-30" is not a valid age, "-31" is not a valid age))</span>
</pre></p><p><a name="usingZip"></a></p><h5> Using <code>zip</code> </h5><p>You can also zip two accumulating <code>Or</code>s together. If both are <code>Good</code>, you'll get a
<code>Good</code> tuple containin both original <code>Good</code> values. Otherwise, you'll get a <code>Bad</code>
containing every error message. Here are some examples:</p><p><pre class="stHighlighted">
parseName(<span class="stQuotedString">"Dude"</span>) zip parseAge(<span class="stQuotedString">"21"</span>)
<span class="stLineComment">// Result: Good((Dude,21))</span>

parseName(<span class="stQuotedString">"Dude"</span>) zip parseAge(<span class="stQuotedString">"-21"</span>)
<span class="stLineComment">// Result: Bad(One("-21" is not a valid age))</span>

parseName(<span class="stQuotedString">""</span>) zip parseAge(<span class="stQuotedString">"-21"</span>)
<span class="stLineComment">// Result: Bad(Many("" is not a valid name, "-21" is not a valid age))</span>
</pre></p><p><a name="usingWhen"></a></p><h5> Using <code>when</code> </h5><p>In addition, given an accumlating <code>Or</code>, you can pass one or more <em>validation functions</em> to <code>when</code> on the <code>Or</code>
to submit that <code>Or</code> to further scrutiny. A validation function accepts a <code>Good</code> type and returns a <code>Validation[E]</code>,
where <code>E</code> is the type in the <code>Every</code> in the <code>Bad</code> type. For an <code>Int</code> <code>Or</code> <code>One[ErrorMessage]</code>, for example
the validation function type would be <code>Int</code> <code>=&gt;</code> <code>Validation[ErrorMessage]</code>. Here are a few examples:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> isRound(i: <span class="stType">Int</span>): <span class="stType">Validation[ErrorMessage]</span> =
  <span class="stReserved">if</span> (i % <span class="stLiteral">10</span> == <span class="stLiteral">0</span>) <span class="stType">Pass</span> <span class="stReserved">else</span> <span class="stType">Fail</span>(i + <span class="stQuotedString">" was not a round number"</span>)

<span class="stReserved">def</span> isDivBy3(i: <span class="stType">Int</span>): <span class="stType">Validation[ErrorMessage]</span> =
  <span class="stReserved">if</span> (i % <span class="stLiteral">3</span> == <span class="stLiteral">0</span>) <span class="stType">Pass</span> <span class="stReserved">else</span> <span class="stType">Fail</span>(i + <span class="stQuotedString">" was not divisible by 3"</span>)
</pre></p><p>If the <code>Or</code> on which you call <code>when</code> is already <code>Bad</code>, you get the same (<code>Bad</code>) <code>Or</code> back, because
no <code>Good</code> value exists to pass to the valiation functions:</p><p><pre class="stHighlighted">
parseAge(<span class="stQuotedString">"-30"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>
</pre></p><p>If the <code>Or</code> on which you call <code>when</code> is <code>Good</code>, and also passes all the validation functions (<em>i.e.</em>, the
all return <code>None</code>), you again get the same <code>Or</code> back, but this time, a <code>Good</code> one:</p><p><pre class="stHighlighted">
parseAge(<span class="stQuotedString">"30"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Good(30)</span>
</pre></p><p>If one or more of the validation functions fails, however, you'll get a <code>Bad</code> back contining every error. Here are some examples:</p><p><pre class="stHighlighted">
parseAge(<span class="stQuotedString">"33"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(One(33 was not a round number))</span>

parseAge(<span class="stQuotedString">"20"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(One(20 was not divisible by 3))</span>

parseAge(<span class="stQuotedString">"31"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(Many(31 was not a round number, 31 was not divisible by 3))</span>
</pre></p><p>Note that you can use <code>when</code> to accumulate errors in a <code>for</code> expression involving an accumulating <code>Or</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"-30"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>

<span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"30"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Good(30)</span>

<span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"33"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(One(33 was not a round number))</span>

<span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"20"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(One(20 was not divisible by 3))</span>

<span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"31"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(Many(31 was not a round number, 31 was not divisible by 3))</span>
</pre></p><h4> Much ado about <code>Nothing</code> </h4><p>Because <code>Or</code> has two types, but each of its two subtypes only takes a value of one or the other type, the Scala compiler will
infer <code>Nothing</code> for the unspecified type:</p><p><pre class="stREPL">
scala&gt; Good(3)
res0: org.scalactic.Good[Int,Nothing] = Good(3)

scala&gt; Bad("oops")
res1: org.scalactic.Bad[Nothing,String] = Bad(oops)
</pre></p><p>Often <code>Nothing</code> will work fine, as it will be widened as soon as the compiler encounters a more specific type.
Sometimes, however, you may need to specify it. In such situations you can use this syntax:</p><p><pre class="stREPL">
scala&gt; Good(3).orBad[String]
res2: org.scalactic.Good[Int,String] = Good(3)

scala&gt; Good[Int].orBad("oops")
res3: org.scalactic.Bad[Int,String] = Bad(oops)
</pre></p><p>If you want to specify both types, because you don't like the inferred type, you can do so like this:</p><p><pre class="stREPL">
scala&gt; Good[AnyVal, String](3)
res4: org.scalactic.Good[AnyVal,String] = Good(3)

scala&gt; Bad[Int, ErrorMessage]("oops")
res5: org.scalactic.Bad[Int,org.scalactic.ErrorMessage] = Bad(oops)
</pre></p><p>But you may find the code is clearer if you instead use a type ascription, like this:</p><p><pre class="stREPL">
scala&gt; Good(3): AnyVal Or String
res6: org.scalactic.Or[AnyVal,String] = Good(3)

scala&gt; Bad("oops"): Int Or ErrorMessage
res7: org.scalactic.Or[Int,org.scalactic.ErrorMessage] = Bad(oops)
</pre></p><p><em>Note: The <code>Or</code> hierarchy was inspired in part by the disjoint union (<code>\/</code>) and <code>Validation</code> types of
<a href="http://code.google.com/p/scalaz/" target="_blank"><code>scalaz</code></a>, the <code>ProcessResult</code> type of
<a href="https://github.com/typesafehub/activator/">Typesafe Activator</a>, and the <code>Result</code> type of
<a href="https://github.com/vpatryshev/ScalaKittens">ScalaKittens</a>.</em></p></div><dl class="attributes block"> <dt>Source</dt><dd><a href="https://github.com/scalatest/scalatest/tree/release-3.0.0/scalactic//src/main/scala/org/scalactic/Or.scala" target="_blank">Or.scala</a></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.Serializable">Serializable</span>, <span class="extype" name="java.io.Serializable">Serializable</span>, <span class="extype" name="scala.Product">Product</span>, <span class="extype" name="scala.Equals">Equals</span>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div><div class="toggleContainer block">
            <span class="toggle">Known Subclasses</span>
            <div class="subClasses hiddenContent"><a href="Bad.html" class="extype" name="org.scalactic.Bad">Bad</a>, <a href="Good.html" class="extype" name="org.scalactic.Good">Good</a></div>
          </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By Inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="org.scalactic.Or"><span>Or</span></li><li class="in" name="scala.Serializable"><span>Serializable</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.Product"><span>Product</span></li><li class="in" name="scala.Equals"><span>Equals</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show All</span></li>
            </ol>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        <div id="values" class="values members">
              <h3>Abstract Value Members</h3>
              <ol><li name="org.scalactic.Or#accumulating" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="accumulating:org.scalactic.Or[G,org.scalactic.One[B]]"></a>
      <a id="accumulating:Or[G,One[B]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accumulating</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.G">G</span>, <a href="One.html" class="extype" name="org.scalactic.One">One</a>[<span class="extype" name="org.scalactic.Or.B">B</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@accumulating:org.scalactic.Or[G,org.scalactic.One[B]]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Converts this <code>Or</code> to an <code>Or</code> with the same <code>Good</code> type and a <code>Bad</code> type consisting of
<a href="One.html"><code>One</code></a> parameterized by this <code>Or</code>'s <code>Bad</code> type.</code></code></a></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Converts this <code>Or</code> to an <code>Or</code> with the same <code>Good</code> type and a <code>Bad</code> type consisting of
<a href="One.html"><code>One</code></a> parameterized by this <code>Or</code>'s <code>Bad</code> type.</p><p>For example, invoking the <code>accumulating</code> method on an <code>Int Or ErrorMessage</code> would convert it to an
<code>Int Or One[ErrorMessage]</code>. This result type, because the <code>Bad</code> type is an <code>Every</code>, can be used
with the mechanisms provided in trait <a href="Accumulation.html"><code>Accumulation</code></a> to accumulate errors.</p><p>Note that if this <code>Or</code> is already an accumulating <code>Or</code>, the behavior of this <code>accumulating</code> method does not change.
For example, if you invoke <code>accumulating</code> on an <code>Int Or One[ErrorMessage]</code> you will be rewarded with an
<code>Int Or One[One[ErrorMessage]]</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>this <code>Good</code>, if this <code>Or</code> is a <code>Good</code>; or this <code>Bad</code> value wrapped in a <code>One</code> if
    this <code>Or</code> is a <code>Bad</code>.</p></dd></dl></div>
    </li><li name="org.scalactic.Or#badMap" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="badMap[C](f:B=&gt;C):org.scalactic.Or[G,C]"></a>
      <a id="badMap[C]((B)⇒C):Or[G,C]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">badMap</span><span class="tparams">[<span name="C">C</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.scalactic.Or.B">B</span>) ⇒ <span class="extype" name="org.scalactic.Or.badMap.C">C</span></span>)</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.G">G</span>, <span class="extype" name="org.scalactic.Or.badMap.C">C</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@badMap[C](f:B=&gt;C):org.scalactic.Or[G,C]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code> or returns <code>this</code> if it is a <code>Good</code>.</code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code> or returns <code>this</code> if it is a <code>Good</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>if this is a <code>Bad</code>, the result of applying the given function to the contained value wrapped in a <code>Bad</code>,
        else this <code>Good</code> is returned</p></dd></dl></div>
    </li><li name="scala.Equals#canEqual" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="canEqual(that:Any):Boolean"></a>
      <a id="canEqual(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">canEqual</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@canEqual(that:Any):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Equals</dd></dl></div>
    </li><li name="org.scalactic.Or#exists" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="exists(p:G=&gt;Boolean):Boolean"></a>
      <a id="exists((G)⇒Boolean):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">exists</span><span class="params">(<span name="p">p: (<span class="extype" name="org.scalactic.Or.G">G</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@exists(p:G=&gt;Boolean):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns <code>true</code> if this <code>Or</code> is a <code>Good</code> and the predicate <code>p</code> returns true when applied to this <code>Good</code>'s value.</code></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>true</code> if this <code>Or</code> is a <code>Good</code> and the predicate <code>p</code> returns true when applied to this <code>Good</code>'s value.</p><p>Note: The <code>exists</code> method will return the same result as <code>forall</code> if this <code>Or</code> is a <code>Good</code>, but the opposite
result if this <code>Or</code> is a <code>Bad</code>.</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the predicate to apply to the <code>Good</code> value, if this is a <code>Good</code></p></dd><dt>returns</dt><dd class="cmt"><p>the result of applying the passed predicate <code>p</code> to the <code>Good</code> value, if this is a <code>Good</code>, else <code>false</code></p></dd></dl></div>
    </li><li name="org.scalactic.Or#filter" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="filter[C&gt;:B](f:G=&gt;org.scalactic.Validation[C]):org.scalactic.Or[G,C]"></a>
      <a id="filter[C&gt;:B]((G)⇒Validation[C]):Or[G,C]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filter</span><span class="tparams">[<span name="C">C &gt;: <span class="extype" name="org.scalactic.Or.B">B</span></span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.scalactic.Or.G">G</span>) ⇒ <a href="Validation.html" class="extype" name="org.scalactic.Validation">Validation</a>[<span class="extype" name="org.scalactic.Or.filter.C">C</span>]</span>)</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.G">G</span>, <span class="extype" name="org.scalactic.Or.filter.C">C</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@filter[C&gt;:B](f:G=&gt;org.scalactic.Validation[C]):org.scalactic.Or[G,C]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns this <code>Or</code> if either 1) it is a <code>Bad</code> or 2) it is a <code>Good</code> and applying the validation function <code>f</code> to this
<code>Good</code>'s value returns <code>Pass</code>; otherwise,
returns a new <code>Bad</code> containing the error value contained in the <code>Fail</code> resulting from applying the validation
function <code>f</code> to this <code>Good</code>'s value.</code></code></code></code></code></code></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns this <code>Or</code> if either 1) it is a <code>Bad</code> or 2) it is a <code>Good</code> and applying the validation function <code>f</code> to this
<code>Good</code>'s value returns <code>Pass</code>; otherwise,
returns a new <code>Bad</code> containing the error value contained in the <code>Fail</code> resulting from applying the validation
function <code>f</code> to this <code>Good</code>'s value.</p><p>For examples of <code>filter</code> used in <code>for</code> expressions, see the main documentation for trait
<a href="Validation.html"><code>Validation</code></a>.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the validation function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>a <code>Good</code> if this <code>Or</code> is a <code>Good</code> that passes the validation function, else a <code>Bad</code>.</p></dd></dl></div>
    </li><li name="org.scalactic.Or#flatMap" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="flatMap[H,C&gt;:B](f:G=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]"></a>
      <a id="flatMap[H,C&gt;:B]((G)⇒Or[H,C]):Or[H,C]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="H">H</span>, <span name="C">C &gt;: <span class="extype" name="org.scalactic.Or.B">B</span></span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.scalactic.Or.G">G</span>) ⇒ <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.flatMap.H">H</span>, <span class="extype" name="org.scalactic.Or.flatMap.C">C</span>]</span>)</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.flatMap.H">H</span>, <span class="extype" name="org.scalactic.Or.flatMap.C">C</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@flatMap[H,C&gt;:B](f:G=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the given function applied to the value contained in this <code>Or</code> if it is a <code>Good</code>,
or returns <code>this</code> if it is a <code>Bad</code>.</code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns the given function applied to the value contained in this <code>Or</code> if it is a <code>Good</code>,
or returns <code>this</code> if it is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>if this is a <code>Good</code>, the result of applying the given function to the contained value wrapped in a <code>Good</code>,
        else this <code>Bad</code> is returned</p></dd></dl></div>
    </li><li name="org.scalactic.Or#fold" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="fold[V](gf:G=&gt;V,bf:B=&gt;V):V"></a>
      <a id="fold[V]((G)⇒V,(B)⇒V):V"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fold</span><span class="tparams">[<span name="V">V</span>]</span><span class="params">(<span name="gf">gf: (<span class="extype" name="org.scalactic.Or.G">G</span>) ⇒ <span class="extype" name="org.scalactic.Or.fold.V">V</span></span>, <span name="bf">bf: (<span class="extype" name="org.scalactic.Or.B">B</span>) ⇒ <span class="extype" name="org.scalactic.Or.fold.V">V</span></span>)</span><span class="result">: <span class="extype" name="org.scalactic.Or.fold.V">V</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@fold[V](gf:G=&gt;V,bf:B=&gt;V):V" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Folds this <code>Or</code> into a value of type <code>V</code> by applying the given <code>gf</code> function if this is
a <code>Good</code> else the given <code>bf</code> function if this is a <code>Bad</code>.</code></code></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Folds this <code>Or</code> into a value of type <code>V</code> by applying the given <code>gf</code> function if this is
a <code>Good</code> else the given <code>bf</code> function if this is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt class="param">gf</dt><dd class="cmt"><p>the function to apply to this <code>Or</code>'s <code>Good</code> value, if it is a <code>Good</code></p></dd><dt class="param">bf</dt><dd class="cmt"><p>the function to apply to this <code>Or</code>'s <code>Bad</code> value, if it is a <code>Bad</code></p></dd><dt>returns</dt><dd class="cmt"><p>the result of applying the appropriate one of the two passed functions, <code>gf</code> or </code>bf</code>, to this <code>Or</code>'s value</p></dd></dl></div>
    </li><li name="org.scalactic.Or#forall" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="forall(f:G=&gt;Boolean):Boolean"></a>
      <a id="forall((G)⇒Boolean):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">forall</span><span class="params">(<span name="f">f: (<span class="extype" name="org.scalactic.Or.G">G</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@forall(f:G=&gt;Boolean):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns <code>true</code> if either this <code>Or</code> is a <code>Bad</code> or if the predicate <code>p</code> returns <code>true</code> when applied
to this <code>Good</code>'s value.</code></code></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>true</code> if either this <code>Or</code> is a <code>Bad</code> or if the predicate <code>p</code> returns <code>true</code> when applied
to this <code>Good</code>'s value.</p><p>Note: The <code>forall</code> method will return the same result as <code>exists</code> if this <code>Or</code> is a <code>Good</code>, but the opposite
result if this <code>Or</code> is a <code>Bad</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the result of applying the passed predicate <code>p</code> to the <code>Good</code> value, if this is a <code>Good</code>, else <code>true</code></p></dd></dl></div>
    </li><li name="org.scalactic.Or#foreach" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="foreach(f:G=&gt;Unit):Unit"></a>
      <a id="foreach((G)⇒Unit):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foreach</span><span class="params">(<span name="f">f: (<span class="extype" name="org.scalactic.Or.G">G</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@foreach(f:G=&gt;Unit):Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Applies the given function f to the contained value if this <code>Or</code> is a <code>Good</code>; does nothing if this <code>Or</code>
is a <code>Bad</code>.</code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Applies the given function f to the contained value if this <code>Or</code> is a <code>Good</code>; does nothing if this <code>Or</code>
is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd></dl></div>
    </li><li name="org.scalactic.Or#get" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="get:G"></a>
      <a id="get:G"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">get</span><span class="result">: <span class="extype" name="org.scalactic.Or.G">G</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@get:G" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the <code>Or</code>'s value if it is a <code>Good</code> or throws <code>NoSuchElementException</code> if it is a <code>Bad</code>.</code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns the <code>Or</code>'s value if it is a <code>Good</code> or throws <code>NoSuchElementException</code> if it is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the contained value if this is a <code>Good</code></p></dd></dl><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt"><p><span class="extype" name="NoSuchElementException"><code>NoSuchElementException</code></span> if this is a <code>Bad</code></p></span></dd></dl></div>
    </li><li name="org.scalactic.Or#getOrElse" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getOrElse[H&gt;:G](default:=&gt;H):H"></a>
      <a id="getOrElse[H&gt;:G](⇒H):H"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getOrElse</span><span class="tparams">[<span name="H">H &gt;: <span class="extype" name="org.scalactic.Or.G">G</span></span>]</span><span class="params">(<span name="default">default: ⇒ <span class="extype" name="org.scalactic.Or.getOrElse.H">H</span></span>)</span><span class="result">: <span class="extype" name="org.scalactic.Or.getOrElse.H">H</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@getOrElse[H&gt;:G](default:=&gt;H):H" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns, if this <code>Or</code> is <code>Good</code>, this <code>Good</code>'s value; otherwise returns the result of evaluating <code>default</code>.</code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns, if this <code>Or</code> is <code>Good</code>, this <code>Good</code>'s value; otherwise returns the result of evaluating <code>default</code>.
</p></div><dl class="paramcmts block"><dt class="param">default</dt><dd class="cmt"><p>the default expression to evaluate if this <code>Or</code> is a <code>Bad</code></p></dd><dt>returns</dt><dd class="cmt"><p>the contained value, if this <code>Or</code> is a <code>Good</code>, else the result of evaluating the given <code>default</code></p></dd></dl></div>
    </li><li name="org.scalactic.Or#map" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="map[H](f:G=&gt;H):org.scalactic.Or[H,B]"></a>
      <a id="map[H]((G)⇒H):Or[H,B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="H">H</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.scalactic.Or.G">G</span>) ⇒ <span class="extype" name="org.scalactic.Or.map.H">H</span></span>)</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.map.H">H</span>, <span class="extype" name="org.scalactic.Or.B">B</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@map[H](f:G=&gt;H):org.scalactic.Or[H,B]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Maps the given function to this <code>Or</code>'s value if it is a <code>Good</code> or returns <code>this</code> if it is a <code>Bad</code>.</code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Maps the given function to this <code>Or</code>'s value if it is a <code>Good</code> or returns <code>this</code> if it is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>if this is a <code>Good</code>, the result of applying the given function to the contained value wrapped in a <code>Good</code>,
        else this <code>Bad</code> is returned</p></dd></dl></div>
    </li><li name="org.scalactic.Or#orElse" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="orElse[H&gt;:G,C&gt;:B](alternative:=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]"></a>
      <a id="orElse[H&gt;:G,C&gt;:B](⇒Or[H,C]):Or[H,C]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">orElse</span><span class="tparams">[<span name="H">H &gt;: <span class="extype" name="org.scalactic.Or.G">G</span></span>, <span name="C">C &gt;: <span class="extype" name="org.scalactic.Or.B">B</span></span>]</span><span class="params">(<span name="alternative">alternative: ⇒ <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.orElse.H">H</span>, <span class="extype" name="org.scalactic.Or.orElse.C">C</span>]</span>)</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.orElse.H">H</span>, <span class="extype" name="org.scalactic.Or.orElse.C">C</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@orElse[H&gt;:G,C&gt;:B](alternative:=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns this <code>Or</code> if it is a <code>Good</code>, otherwise returns the result of evaluating the passed <code>alternative</code>.</code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns this <code>Or</code> if it is a <code>Good</code>, otherwise returns the result of evaluating the passed <code>alternative</code>.
</p></div><dl class="paramcmts block"><dt class="param">alternative</dt><dd class="cmt"><p>the alternative by-name to evaluate if this <code>Or</code> is a <code>Bad</code></p></dd><dt>returns</dt><dd class="cmt"><p>this <code>Or</code>, if it is a <code>Good</code>, else the result of evaluating <code>alternative</code></p></dd></dl></div>
    </li><li name="scala.Product#productArity" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="productArity:Int"></a>
      <a id="productArity:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">productArity</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@productArity:Int" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Product</dd></dl></div>
    </li><li name="scala.Product#productElement" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="productElement(n:Int):Any"></a>
      <a id="productElement(Int):Any"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">productElement</span><span class="params">(<span name="n">n: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Any">Any</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@productElement(n:Int):Any" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Product</dd></dl></div>
    </li><li name="org.scalactic.Or#recover" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="recover[H&gt;:G](f:B=&gt;H):org.scalactic.Or[H,B]"></a>
      <a id="recover[H&gt;:G]((B)⇒H):Or[H,B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">recover</span><span class="tparams">[<span name="H">H &gt;: <span class="extype" name="org.scalactic.Or.G">G</span></span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.scalactic.Or.B">B</span>) ⇒ <span class="extype" name="org.scalactic.Or.recover.H">H</span></span>)</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.recover.H">H</span>, <span class="extype" name="org.scalactic.Or.B">B</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@recover[H&gt;:G](f:B=&gt;H):org.scalactic.Or[H,B]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code>, transforming it into a <code>Good</code>, or returns
<code>this</code> if it is already a <code>Good</code>.</code></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code>, transforming it into a <code>Good</code>, or returns
<code>this</code> if it is already a <code>Good</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>if this is a <code>Bad</code>, the result of applying the given function to the contained value wrapped in a <code>Good</code>,
        else this <code>Good</code> is returned</p></dd></dl></div>
    </li><li name="org.scalactic.Or#recoverWith" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="recoverWith[H&gt;:G,C](f:B=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]"></a>
      <a id="recoverWith[H&gt;:G,C]((B)⇒Or[H,C]):Or[H,C]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">recoverWith</span><span class="tparams">[<span name="H">H &gt;: <span class="extype" name="org.scalactic.Or.G">G</span></span>, <span name="C">C</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.scalactic.Or.B">B</span>) ⇒ <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.recoverWith.H">H</span>, <span class="extype" name="org.scalactic.Or.recoverWith.C">C</span>]</span>)</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.recoverWith.H">H</span>, <span class="extype" name="org.scalactic.Or.recoverWith.C">C</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@recoverWith[H&gt;:G,C](f:B=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code>, returning the result, or returns
<code>this</code> if it is already a <code>Good</code>.</code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code>, returning the result, or returns
<code>this</code> if it is already a <code>Good</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>if this is a <code>Bad</code>, the result of applying the given function to the contained value,
        else this <code>Good</code> is returned</p></dd></dl></div>
    </li><li name="org.scalactic.Or#swap" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="swap:org.scalactic.Or[B,G]"></a>
      <a id="swap:Or[B,G]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">swap</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.B">B</span>, <span class="extype" name="org.scalactic.Or.G">G</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@swap:org.scalactic.Or[B,G]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns an <code>Or</code> with the <code>Good</code> and <code>Bad</code> types swapped: <code>Bad</code> becomes <code>Good</code> and <code>Good</code>
becomes <code>Bad</code>.</code></code></code></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Or</code> with the <code>Good</code> and <code>Bad</code> types swapped: <code>Bad</code> becomes <code>Good</code> and <code>Good</code>
becomes <code>Bad</code>.</p><p>Here's an example:</p><p><pre class="stREPL">
scala&gt; val lyrics = Bad("Hey Jude, don't make it bad. Take a sad song and make it better.")
lyrics: org.scalactic.Bad[Nothing,String] =
    Bad(Hey Jude, don't make it bad. Take a sad song and make it better.)

scala&gt; lyrics.swap
res12: org.scalactic.Or[String,Nothing] =
    Good(Hey Jude, don't make it bad. Take a sad song and make it better.)
</pre></p><p>Now that song will be rolling around in your head all afternoon. But at least it is a good song (thanks to <code>swap</code>).</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>if this <code>Or</code> is a <code>Good</code>, its <code>Good</code> value wrapped in a <code>Bad</code>; if this <code>Or</code> is
    a <code>Bad</code>, its <code>Bad</code> value wrapped in a <code>Good</code>.</p></dd></dl></div>
    </li><li name="org.scalactic.Or#toEither" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="toEither:Either[B,G]"></a>
      <a id="toEither:Either[B,G]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toEither</span><span class="result">: <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="org.scalactic.Or.B">B</span>, <span class="extype" name="org.scalactic.Or.G">G</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@toEither:Either[B,G]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns an <code>Either</code>: a <code>Right</code> containing the <code>Good</code> value, if this is a <code>Good</code>; a <code>Left</code>
containing the <code>Bad</code> value, if this is a <code>Bad</code>.</code></code></code></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Either</code>: a <code>Right</code> containing the <code>Good</code> value, if this is a <code>Good</code>; a <code>Left</code>
containing the <code>Bad</code> value, if this is a <code>Bad</code>.</p><p>Note that values effectively &ldquo;switch sides&rdquo; when convering an <code>Or</code> to an <code>Either</code>. If the type of the
<code>Or</code> on which you invoke <code>toEither</code> is <code>Or[Int, ErrorMessage]</code> for example, the result will be an
<code>Either[ErrorMessage, Int]</code>. The reason is that the convention for <code>Either</code> is that <code>Left</code> is used for &ldquo;bad&rdquo;
values and <code>Right</code> is used for &ldquo;good&rdquo; ones.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>this <code>Good</code> value, wrapped in a <code>Right</code>, or this <code>Bad</code> value, wrapped in a <code>Left</code>.</p></dd></dl></div>
    </li><li name="org.scalactic.Or#toOption" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="toOption:Option[G]"></a>
      <a id="toOption:Option[G]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toOption</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="org.scalactic.Or.G">G</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@toOption:Option[G]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a <code>Some</code> containing the <code>Good</code> value, if this <code>Or</code> is a <code>Good</code>, else <code>None</code>.</code></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Some</code> containing the <code>Good</code> value, if this <code>Or</code> is a <code>Good</code>, else <code>None</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the contained &ldquo;good&rdquo; value wrapped in a <code>Some</code>, if this <code>Or</code> is a <code>Good</code>; <code>None</code>
    if this <code>Or</code> is a <code>Bad</code>.</p></dd></dl></div>
    </li><li name="org.scalactic.Or#toSeq" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="toSeq:scala.collection.immutable.IndexedSeq[G]"></a>
      <a id="toSeq:IndexedSeq[G]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toSeq</span><span class="result">: <span class="extype" name="scala.collection.immutable.IndexedSeq">IndexedSeq</span>[<span class="extype" name="org.scalactic.Or.G">G</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@toSeq:scala.collection.immutable.IndexedSeq[G]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns an immutable <code>IndexedSeq</code> containing the <code>Good</code> value, if this <code>Or</code> is a <code>Good</code>, else an empty
immutable <code>IndexedSeq</code>.</code></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns an immutable <code>IndexedSeq</code> containing the <code>Good</code> value, if this <code>Or</code> is a <code>Good</code>, else an empty
immutable <code>IndexedSeq</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the contained &ldquo;good&rdquo; value in a lone-element <code>Seq</code> if this <code>Or</code> is a <code>Good</code>; an empty <code>Seq</code> if
    this <code>Or</code> is a <code>Bad</code>.</p></dd></dl></div>
    </li><li name="org.scalactic.Or#toTry" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="toTry(implicitev:&lt;:&lt;[B,Throwable]):scala.util.Try[G]"></a>
      <a id="toTry(&lt;:&lt;[B,Throwable]):Try[G]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toTry</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="org.scalactic.Or.B">B</span>, <span class="extype" name="scala.Throwable">Throwable</span>]</span>)</span><span class="result">: <span class="extype" name="scala.util.Try">Try</span>[<span class="extype" name="org.scalactic.Or.G">G</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@toTry(implicitev:&lt;:&lt;[B,Throwable]):scala.util.Try[G]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns a <code>Try</code>: a <code>Success</code> containing the
<code>Good</code> value, if this is a <code>Good</code>; a <code>Failure</code>
containing the <code>Bad</code> value, if this is a <code>Bad</code>.</code></code></code></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Try</code>: a <code>Success</code> containing the
<code>Good</code> value, if this is a <code>Good</code>; a <code>Failure</code>
containing the <code>Bad</code> value, if this is a <code>Bad</code>.</p><p>Note: This method can only be called if the <code>Bad</code> type of this <code>Or</code> is a subclass
of <code>Throwable</code> (or <code>Throwable</code> itself).</p><p>Note that values effectively &ldquo;switch sides&rdquo; when converting an <code>Or</code> to an <code>Either</code>. If the type of the
<code>Or</code> on which you invoke <code>toEither</code> is <code>Or[Int, ErrorMessage]</code> for example, the result will be an
<code>Either[ErrorMessage, Int]</code>. The reason is that the convention for <code>Either</code> is that <code>Left</code> is used for &ldquo;bad&rdquo;
values and <code>Right</code> is used for &ldquo;good&rdquo; ones.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>this <code>Good</code> value, wrapped in a <code>Right</code>, or this <code>Bad</code> value, wrapped in a <code>Left</code>.</p></dd></dl></div>
    </li><li name="org.scalactic.Or#transform" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="transform[H,C](gf:G=&gt;org.scalactic.Or[H,C],bf:B=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]"></a>
      <a id="transform[H,C]((G)⇒Or[H,C],(B)⇒Or[H,C]):Or[H,C]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transform</span><span class="tparams">[<span name="H">H</span>, <span name="C">C</span>]</span><span class="params">(<span name="gf">gf: (<span class="extype" name="org.scalactic.Or.G">G</span>) ⇒ <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.transform.H">H</span>, <span class="extype" name="org.scalactic.Or.transform.C">C</span>]</span>, <span name="bf">bf: (<span class="extype" name="org.scalactic.Or.B">B</span>) ⇒ <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.transform.H">H</span>, <span class="extype" name="org.scalactic.Or.transform.C">C</span>]</span>)</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.transform.H">H</span>, <span class="extype" name="org.scalactic.Or.transform.C">C</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@transform[H,C](gf:G=&gt;org.scalactic.Or[H,C],bf:B=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Transforms this <code>Or</code> by applying the function <code>gf</code> to this <code>Or</code>'s <code>Good</code> value if it is a <code>Good</code>,
or by applying <code>bf</code> to this <code>Or</code>'s <code>Bad</code> value if it is a <code>Bad</code>.</code></code></code></code></code></code></code></code></code></p><div class="fullcomment"><div class="comment cmt"><p>Transforms this <code>Or</code> by applying the function <code>gf</code> to this <code>Or</code>'s <code>Good</code> value if it is a <code>Good</code>,
or by applying <code>bf</code> to this <code>Or</code>'s <code>Bad</code> value if it is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt class="param">gf</dt><dd class="cmt"><p>the function to apply to this <code>Or</code>'s <code>Good</code> value, if it is a <code>Good</code></p></dd><dt class="param">bf</dt><dd class="cmt"><p>the function to apply to this <code>Or</code>'s <code>Bad</code> value, if it is a <code>Bad</code></p></dd><dt>returns</dt><dd class="cmt"><p>the result of applying the appropriate one of the two passed functions, <code>gf</code> or </code>bf</code>, to this <code>Or</code>'s value</p></dd></dl></div>
    </li></ol>
            </div>

        <div id="values" class="values members">
              <h3>Concrete Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@!=(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@##():Int" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@==(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@asInstanceOf[T0]:T0" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@clone():Object" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@eq(x$1:AnyRef):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@equals(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@finalize():Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@getClass():Class[_]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@hashCode():Int" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="org.scalactic.Or#isBad" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isBad:Boolean"></a>
      <a id="isBad:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">isBad</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@isBad:Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Indicates whether this <code>Or</code> is a <code>Bad</code>
</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Indicates whether this <code>Or</code> is a <code>Bad</code>
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if this <code>Or</code> is a <code>Bad</code>, <code>false</code> if it is a <code>Good</code>.</p></dd></dl></div>
    </li><li name="org.scalactic.Or#isGood" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isGood:Boolean"></a>
      <a id="isGood:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">isGood</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@isGood:Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Indicates whether this <code>Or</code> is a <code>Good</code>
</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Indicates whether this <code>Or</code> is a <code>Good</code>
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if this <code>Or</code> is a <code>Good</code>, <code>false</code> if it is a <code>Bad</code>.</p></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@isInstanceOf[T0]:Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@ne(x$1:AnyRef):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@notify():Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@notifyAll():Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Product#productIterator" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="productIterator:Iterator[Any]"></a>
      <a id="productIterator:Iterator[Any]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">productIterator</span><span class="result">: <span class="extype" name="scala.Iterator">Iterator</span>[<span class="extype" name="scala.Any">Any</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@productIterator:Iterator[Any]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Product</dd></dl></div>
    </li><li name="scala.Product#productPrefix" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="productPrefix:String"></a>
      <a id="productPrefix:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">productPrefix</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@productPrefix:String" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Product</dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@synchronized[T0](x$1:=&gt;T0):T0" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@toString():String" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@wait():Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@wait(x$1:Long,x$2:Int):Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@wait(x$1:Long):Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="org.scalactic.Or#withFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withFilter[C&gt;:B](f:G=&gt;org.scalactic.Validation[C]):org.scalactic.Or[G,C]"></a>
      <a id="withFilter[C&gt;:B]((G)⇒Validation[C]):Or[G,C]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withFilter</span><span class="tparams">[<span name="C">C &gt;: <span class="extype" name="org.scalactic.Or.B">B</span></span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.scalactic.Or.G">G</span>) ⇒ <a href="Validation.html" class="extype" name="org.scalactic.Validation">Validation</a>[<span class="extype" name="org.scalactic.Or.withFilter.C">C</span>]</span>)</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.G">G</span>, <span class="extype" name="org.scalactic.Or.withFilter.C">C</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@withFilter[C&gt;:B](f:G=&gt;org.scalactic.Validation[C]):org.scalactic.Or[G,C]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Currently just forwards to </code>filter</code>, and therefore, returns the same result.</code></p><div class="fullcomment"><div class="comment cmt"><p>Currently just forwards to </code>filter</code>, and therefore, returns the same result.
</p></div></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="org.scalactic.Or#asOr" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asOr:org.scalactic.Or[G,B]"></a>
      <a id="asOr:Or[G,B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: The asOr is no longer needed because Good(value).orBad[Type] and Good[Type].orBad(value) now return Or. You can delete invocations of asOr in those cases, otherwise, please use a type annotation to widen the type, like (Good(3): Int Or ErrorMessage).">asOr</span><span class="result">: <a href="" class="extype" name="org.scalactic.Or">Or</a>[<span class="extype" name="org.scalactic.Or.G">G</span>, <span class="extype" name="org.scalactic.Or.B">B</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#org.scalactic.Or@asOr:org.scalactic.Or[G,B]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt"><strong>The <code>asOr</code> method has been deprecated and will be removed in a future version of Scalactic.
Please remove invocations of <code>asOr</code> in expressions of type <code>Good(value).orBad[Type]</code> and
<code>Good[Type].orBad(value)</code> (which now return a type already widened to <code>Or</code>), otherwise please
use a type annotation to widen the type, such as: <code>(Good(3): Int Or ErrorMessage)</code>.</strong>
</strong></p><div class="fullcomment"><div class="comment cmt"><p><strong>The <code>asOr</code> method has been deprecated and will be removed in a future version of Scalactic.
Please remove invocations of <code>asOr</code> in expressions of type <code>Good(value).orBad[Type]</code> and
<code>Good[Type].orBad(value)</code> (which now return a type already widened to <code>Or</code>), otherwise please
use a type annotation to widen the type, such as: <code>(Good(3): Int Or ErrorMessage)</code>.</strong>
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p>The asOr is no longer needed because Good(value).orBad[Type] and Good[Type].orBad(value) now return Or. You can delete invocations of asOr in those cases, otherwise, please use a type annotation to widen the type, like (Good(3): Int Or ErrorMessage).</p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.Serializable">
              <h3>Inherited from <span class="extype" name="scala.Serializable">Serializable</span></h3>
            </div><div class="parent" name="java.io.Serializable">
              <h3>Inherited from <span class="extype" name="java.io.Serializable">Serializable</span></h3>
            </div><div class="parent" name="scala.Product">
              <h3>Inherited from <span class="extype" name="scala.Product">Product</span></h3>
            </div><div class="parent" name="scala.Equals">
              <h3>Inherited from <span class="extype" name="scala.Equals">Equals</span></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
