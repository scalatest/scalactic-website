<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Scalactic 3.2.7  - org.scalactic.anyvals</title><meta content="Scalactic 3.2.7 - org.scalactic.anyvals" name="description"/><meta content="Scalactic 3.2.7 org.scalactic.anyvals" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../lib/index.js"></script><script type="text/javascript" src="../../../index.js"></script><script type="text/javascript" src="../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../';</script>

<!-- gtag [javascript] -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-19BZD1XMRV"></script>

<script defer>

window.dataLayer = window.dataLayer || [];

function gtag(){dataLayer.push(arguments);}

gtag('js', new Date());

gtag('config', 'G-19BZD1XMRV');

</script>
</head><body><div id="search"><span id="doc-title">Scalactic 3.2.7<span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.org" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="org" class="anchorToMember"></a><a id="org:org" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">org</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="org.scalactic" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scalactic" class="anchorToMember"></a><a id="scalactic:scalactic" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">scalactic</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="org" id="org" class="extype">org</a></dd></dl></div></li><li class="indented3 current" name="org.scalactic.anyvals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="anyvals" class="anchorToMember"></a><a id="anyvals:anyvals" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">anyvals</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="org.scalactic" id="org.scalactic" class="extype">scalactic</a></dd></dl></div></li><li class="current-entities indented3"><a href="CompileTimeAssertions$.html" title="Companion object that facilitates the importing of CompileTimeAssertions members as an alternative to mixing in the trait." class="object"></a> <a href="CompileTimeAssertions.html" title="Trait providing assertion methods that can be called at compile time from macros to validate literals in source code." class="trait"></a><a href="CompileTimeAssertions.html" title="Trait providing assertion methods that can be called at compile time from macros to validate literals in source code.">CompileTimeAssertions</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="End$.html" title="Object that can be used as an endpoint for NonEmptyList construction expressions that use the cons (::) operator." class="object"></a><a href="End$.html" title="Object that can be used as an endpoint for NonEmptyList construction expressions that use the cons (::) operator.">End</a></li><li class="current-entities indented3"><a href="FiniteDouble$.html" title="The companion object for FiniteDouble that offers factory methods that produce FiniteDoubles, implicit widening conversions from FiniteDouble to other numeric types, and maximum and minimum constant values for FiniteDouble." class="object"></a> <a href="FiniteDouble.html" title="An AnyVal for finite Doubles." class="class"></a><a href="FiniteDouble.html" title="An AnyVal for finite Doubles.">FiniteDouble</a></li><li class="current-entities indented3"><a href="FiniteFloat$.html" title="The companion object for FiniteFloat that offers factory methods that produce FiniteFloats, implicit widening conversions from FiniteFloat to other numeric types, and maximum and minimum constant values for FiniteFloat." class="object"></a> <a href="FiniteFloat.html" title="An AnyVal for finite Floats." class="class"></a><a href="FiniteFloat.html" title="An AnyVal for finite Floats.">FiniteFloat</a></li><li class="current-entities indented3"><a href="NegDouble$.html" title="The companion object for NegDouble that offers factory methods that produce NegDoubles, implicit widening conversions from NegDouble to other numeric types, and maximum and minimum constant values for NegDouble." class="object"></a> <a href="NegDouble.html" title="An AnyVal for negative Doubles." class="class"></a><a href="NegDouble.html" title="An AnyVal for negative Doubles.">NegDouble</a></li><li class="current-entities indented3"><a href="NegFiniteDouble$.html" title="The companion object for NegFiniteDouble that offers factory methods that produce NegFiniteDoubles, implicit widening conversions from NegFiniteDouble to other numeric types, and maximum and minimum constant values for NegFiniteDouble." class="object"></a> <a href="NegFiniteDouble.html" title="An AnyVal for finite negative Doubles." class="class"></a><a href="NegFiniteDouble.html" title="An AnyVal for finite negative Doubles.">NegFiniteDouble</a></li><li class="current-entities indented3"><a href="NegFiniteFloat$.html" title="The companion object for NegFiniteFloat that offers factory methods that produce NegFiniteFloats, implicit widening conversions from NegFiniteFloat to other numeric types, and maximum and minimum constant values for NegFiniteFloat." class="object"></a> <a href="NegFiniteFloat.html" title="An AnyVal for finite negative Floats." class="class"></a><a href="NegFiniteFloat.html" title="An AnyVal for finite negative Floats.">NegFiniteFloat</a></li><li class="current-entities indented3"><a href="NegFloat$.html" title="The companion object for NegFloat that offers factory methods that produce NegFloats, implicit widening conversions from NegFloat to other numeric types, and maximum and minimum constant values for NegFloat." class="object"></a> <a href="NegFloat.html" title="An AnyVal for megative Floats." class="class"></a><a href="NegFloat.html" title="An AnyVal for megative Floats.">NegFloat</a></li><li class="current-entities indented3"><a href="NegInt$.html" title="The companion object for NegInt that offers factory methods that produce NegInts, implicit widening conversions from NegInt to other numeric types, and maximum and minimum constant values for NegInt." class="object"></a> <a href="NegInt.html" title="An AnyVal for negative Ints." class="class"></a><a href="NegInt.html" title="An AnyVal for negative Ints.">NegInt</a></li><li class="current-entities indented3"><a href="NegLong$.html" title="The companion object for NegLong that offers factory methods that produce NegLongs, implicit widening conversions from NegLong to other numeric types, and maximum and minimum constant values for NegLong." class="object"></a> <a href="NegLong.html" title="An AnyVal for negative Longs." class="class"></a><a href="NegLong.html" title="An AnyVal for negative Longs.">NegLong</a></li><li class="current-entities indented3"><a href="NegZDouble$.html" title="The companion object for NegZDouble that offers factory methods that produce NegZDoubles, implicit widening conversions from NegZDouble to other numeric types, and maximum and minimum constant values for NegZDouble." class="object"></a> <a href="NegZDouble.html" title="An AnyVal for non-positive Doubles." class="class"></a><a href="NegZDouble.html" title="An AnyVal for non-positive Doubles.">NegZDouble</a></li><li class="current-entities indented3"><a href="NegZFiniteDouble$.html" title="The companion object for NegZFiniteDouble that offers factory methods that produce NegZFiniteDoubles, implicit widening conversions from NegZFiniteDouble to other numeric types, and maximum and minimum constant values for NegZFiniteDouble." class="object"></a> <a href="NegZFiniteDouble.html" title="An AnyVal for finite non-positive Doubles." class="class"></a><a href="NegZFiniteDouble.html" title="An AnyVal for finite non-positive Doubles.">NegZFiniteDouble</a></li><li class="current-entities indented3"><a href="NegZFiniteFloat$.html" title="The companion object for NegZFiniteFloat that offers factory methods that produce NegZFiniteFloats, implicit widening conversions from NegZFiniteFloat to other numeric types, and maximum and minimum constant values for NegZFiniteFloat." class="object"></a> <a href="NegZFiniteFloat.html" title="An AnyVal for finite non-positive Floats." class="class"></a><a href="NegZFiniteFloat.html" title="An AnyVal for finite non-positive Floats.">NegZFiniteFloat</a></li><li class="current-entities indented3"><a href="NegZFloat$.html" title="The companion object for NegZFloat that offers factory methods that produce NegZFloats, implicit widening conversions from NegZFloat to other numeric types, and maximum and minimum constant values for NegZFloat." class="object"></a> <a href="NegZFloat.html" title="An AnyVal for non-positive Floats." class="class"></a><a href="NegZFloat.html" title="An AnyVal for non-positive Floats.">NegZFloat</a></li><li class="current-entities indented3"><a href="NegZInt$.html" title="The companion object for NegZInt that offers factory methods that produce NegZInts, implicit widening conversions from NegZInt to other numeric types, and maximum and minimum constant values for NegZInt." class="object"></a> <a href="NegZInt.html" title="An AnyVal for non-positive Ints." class="class"></a><a href="NegZInt.html" title="An AnyVal for non-positive Ints.">NegZInt</a></li><li class="current-entities indented3"><a href="NegZLong$.html" title="The companion object for NegZLong that offers factory methods that produce NegZLongs, implicit widening conversions from NegZLong to other numeric types, and maximum and minimum constant values for NegZLong." class="object"></a> <a href="NegZLong.html" title="An AnyVal for non-positive Longs." class="class"></a><a href="NegZLong.html" title="An AnyVal for non-positive Longs.">NegZLong</a></li><li class="current-entities indented3"><a href="NonEmptyArray$.html" title="Companion object for class NonEmptyArray." class="object"></a> <a href="NonEmptyArray.html" title="A non-empty array: an ordered, mutable, non-empty collection of elements with IndexedSeq performance characteristics." class="class"></a><a href="NonEmptyArray.html" title="A non-empty array: an ordered, mutable, non-empty collection of elements with IndexedSeq performance characteristics.">NonEmptyArray</a></li><li class="current-entities indented3"><a href="NonEmptyList$.html" title="Companion object for class NonEmptyList." class="object"></a> <a href="NonEmptyList.html" title="A non-empty list: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics." class="class"></a><a href="NonEmptyList.html" title="A non-empty list: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics.">NonEmptyList</a></li><li class="current-entities indented3"><a href="NonEmptyMap$.html" title="Companion object for class NonEmptyMap." class="object"></a> <a href="NonEmptyMap.html" title="A non-empty map: an ordered, immutable, non-empty collection of key-value tuples with LinearSeq performance characteristics." class="class"></a><a href="NonEmptyMap.html" title="A non-empty map: an ordered, immutable, non-empty collection of key-value tuples with LinearSeq performance characteristics.">NonEmptyMap</a></li><li class="current-entities indented3"><a href="NonEmptySet$.html" title="Companion object for class NonEmptySet." class="object"></a> <a href="NonEmptySet.html" title="A non-empty Set: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics." class="class"></a><a href="NonEmptySet.html" title="A non-empty Set: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics.">NonEmptySet</a></li><li class="current-entities indented3"><a href="NonEmptyString$.html" title="Companion object for class NonEmptyString." class="object"></a> <a href="NonEmptyString.html" title="A non-empty list: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics." class="class"></a><a href="NonEmptyString.html" title="A non-empty list: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics.">NonEmptyString</a></li><li class="current-entities indented3"><a href="NonEmptyVector$.html" title="Companion object for class NonEmptyVector." class="object"></a> <a href="NonEmptyVector.html" title="A non-empty list: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics." class="class"></a><a href="NonEmptyVector.html" title="A non-empty list: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics.">NonEmptyVector</a></li><li class="current-entities indented3"><a href="NonZeroDouble$.html" title="The companion object for NonZeroDouble that offers factory methods that produce NonZeroDoubles, implicit widening conversions from NonZeroDouble to other numeric types, and maximum and minimum constant values for NonZeroDouble." class="object"></a> <a href="NonZeroDouble.html" title="An AnyVal for non-zero Doubles." class="class"></a><a href="NonZeroDouble.html" title="An AnyVal for non-zero Doubles.">NonZeroDouble</a></li><li class="current-entities indented3"><a href="NonZeroFiniteDouble$.html" title="The companion object for NonZeroFiniteDouble that offers factory methods that produce NonZeroFiniteDoubles, implicit widening conversions from NonZeroFiniteDouble to other numeric types, and maximum and minimum constant values for NonZeroFiniteDouble." class="object"></a> <a href="NonZeroFiniteDouble.html" title="An AnyVal for finite non-zero Doubles." class="class"></a><a href="NonZeroFiniteDouble.html" title="An AnyVal for finite non-zero Doubles.">NonZeroFiniteDouble</a></li><li class="current-entities indented3"><a href="NonZeroFiniteFloat$.html" title="The companion object for NonZeroFiniteFloat that offers factory methods that produce NonZeroFiniteFloats, implicit widening conversions from NonZeroFiniteFloat to other numeric types, and maximum and minimum constant values for NonZeroFiniteFloat." class="object"></a> <a href="NonZeroFiniteFloat.html" title="An AnyVal for finite non-zero Floats." class="class"></a><a href="NonZeroFiniteFloat.html" title="An AnyVal for finite non-zero Floats.">NonZeroFiniteFloat</a></li><li class="current-entities indented3"><a href="NonZeroFloat$.html" title="The companion object for NonZeroFloat that offers factory methods that produce NonZeroFloats, implicit widening conversions from NonZeroFloat to other numeric types, and maximum and minimum constant values for NonZeroFloat." class="object"></a> <a href="NonZeroFloat.html" title="An AnyVal for non-zero Floats." class="class"></a><a href="NonZeroFloat.html" title="An AnyVal for non-zero Floats.">NonZeroFloat</a></li><li class="current-entities indented3"><a href="NonZeroInt$.html" title="The companion object for NonZeroInt that offers factory methods that produce NonZeroInts, implicit widening conversions from NonZeroInt to other numeric types, and maximum and minimum constant values for NonZeroInt." class="object"></a> <a href="NonZeroInt.html" title="An AnyVal for non-zero Ints." class="class"></a><a href="NonZeroInt.html" title="An AnyVal for non-zero Ints.">NonZeroInt</a></li><li class="current-entities indented3"><a href="NonZeroLong$.html" title="The companion object for NonZeroLong that offers factory methods that produce NonZeroLongs, implicit widening conversions from NonZeroLong to other numeric types, and maximum and minimum constant values for NonZeroLong." class="object"></a> <a href="NonZeroLong.html" title="An AnyVal for non-zero Longs." class="class"></a><a href="NonZeroLong.html" title="An AnyVal for non-zero Longs.">NonZeroLong</a></li><li class="current-entities indented3"><a href="NumericChar$.html" title="The companion object for NumericChar that offers factory methods that produce NumericChars and maximum and minimum constant values for NumericChar." class="object"></a> <a href="NumericChar.html" title="An AnyVal for numeric Chars." class="class"></a><a href="NumericChar.html" title="An AnyVal for numeric Chars.">NumericChar</a></li><li class="current-entities indented3"><a href="NumericString$.html" title="The companion object for NumericString that offers factory methods that produce NumericStrings." class="object"></a> <a href="NumericString.html" title="An AnyVal for numeric Strings." class="class"></a><a href="NumericString.html" title="An AnyVal for numeric Strings.">NumericString</a></li><li class="current-entities indented3"><a href="PosDouble$.html" title="The companion object for PosDouble that offers factory methods that produce PosDoubles, implicit widening conversions from PosDouble to other numeric types, and maximum and minimum constant values for PosDouble." class="object"></a> <a href="PosDouble.html" title="An AnyVal for positive Doubles." class="class"></a><a href="PosDouble.html" title="An AnyVal for positive Doubles.">PosDouble</a></li><li class="current-entities indented3"><a href="PosFiniteDouble$.html" title="The companion object for PosFiniteDouble that offers factory methods that produce PosFiniteDoubles, implicit widening conversions from PosFiniteDouble to other numeric types, and maximum and minimum constant values for PosFiniteDouble." class="object"></a> <a href="PosFiniteDouble.html" title="An AnyVal for finite positive Doubles." class="class"></a><a href="PosFiniteDouble.html" title="An AnyVal for finite positive Doubles.">PosFiniteDouble</a></li><li class="current-entities indented3"><a href="PosFiniteFloat$.html" title="The companion object for PosFiniteFloat that offers factory methods that produce PosFiniteFloats, implicit widening conversions from PosFiniteFloat to other numeric types, and maximum and minimum constant values for PosFiniteFloat." class="object"></a> <a href="PosFiniteFloat.html" title="An AnyVal for finite positive Floats." class="class"></a><a href="PosFiniteFloat.html" title="An AnyVal for finite positive Floats.">PosFiniteFloat</a></li><li class="current-entities indented3"><a href="PosFloat$.html" title="The companion object for PosFloat that offers factory methods that produce PosFloats, implicit widening conversions from PosFloat to other numeric types, and maximum and minimum constant values for PosFloat." class="object"></a> <a href="PosFloat.html" title="An AnyVal for positive Floats." class="class"></a><a href="PosFloat.html" title="An AnyVal for positive Floats.">PosFloat</a></li><li class="current-entities indented3"><a href="PosInt$.html" title="The companion object for PosInt that offers factory methods that produce PosInts, implicit widening conversions from PosInt to other numeric types, and maximum and minimum constant values for PosInt." class="object"></a> <a href="PosInt.html" title="An AnyVal for positive Ints." class="class"></a><a href="PosInt.html" title="An AnyVal for positive Ints.">PosInt</a></li><li class="current-entities indented3"><a href="PosLong$.html" title="The companion object for PosLong that offers factory methods that produce PosLongs, implicit widening conversions from PosLong to other numeric types, and maximum and minimum constant values for PosLong." class="object"></a> <a href="PosLong.html" title="An AnyVal for positive Longs." class="class"></a><a href="PosLong.html" title="An AnyVal for positive Longs.">PosLong</a></li><li class="current-entities indented3"><a href="PosZDouble$.html" title="The companion object for PosZDouble that offers factory methods that produce PosZDoubles, implicit widening conversions from PosZDouble to other numeric types, and maximum and minimum constant values for PosZDouble." class="object"></a> <a href="PosZDouble.html" title="An AnyVal for non-negative Doubles." class="class"></a><a href="PosZDouble.html" title="An AnyVal for non-negative Doubles.">PosZDouble</a></li><li class="current-entities indented3"><a href="PosZFiniteDouble$.html" title="The companion object for PosZFiniteDouble that offers factory methods that produce PosZFiniteDoubles, implicit widening conversions from PosZFiniteDouble to other numeric types, and maximum and minimum constant values for PosZFiniteDouble." class="object"></a> <a href="PosZFiniteDouble.html" title="An AnyVal for finite non-negative Doubles." class="class"></a><a href="PosZFiniteDouble.html" title="An AnyVal for finite non-negative Doubles.">PosZFiniteDouble</a></li><li class="current-entities indented3"><a href="PosZFiniteFloat$.html" title="The companion object for PosZFiniteFloat that offers factory methods that produce PosZFiniteFloats, implicit widening conversions from PosZFiniteFloat to other numeric types, and maximum and minimum constant values for PosZFiniteFloat." class="object"></a> <a href="PosZFiniteFloat.html" title="An AnyVal for finite non-negative Floats." class="class"></a><a href="PosZFiniteFloat.html" title="An AnyVal for finite non-negative Floats.">PosZFiniteFloat</a></li><li class="current-entities indented3"><a href="PosZFloat$.html" title="The companion object for PosZFloat that offers factory methods that produce PosZFloats, implicit widening conversions from PosZFloat to other numeric types, and maximum and minimum constant values for PosZFloat." class="object"></a> <a href="PosZFloat.html" title="An AnyVal for non-negative Floats." class="class"></a><a href="PosZFloat.html" title="An AnyVal for non-negative Floats.">PosZFloat</a></li><li class="current-entities indented3"><a href="PosZInt$.html" title="The companion object for PosZInt that offers factory methods that produce PosZInts, implicit widening conversions from PosZInt to other numeric types, and maximum and minimum constant values for PosZInt." class="object"></a> <a href="PosZInt.html" title="An AnyVal for non-negative Ints." class="class"></a><a href="PosZInt.html" title="An AnyVal for non-negative Ints.">PosZInt</a></li><li class="current-entities indented3"><a href="PosZLong$.html" title="The companion object for PosZLong that offers factory methods that produce PosZLongs, implicit widening conversions from PosZLong to other numeric types, and maximum and minimum constant values for PosZLong." class="object"></a> <a href="PosZLong.html" title="An AnyVal for non-negative Longs." class="class"></a><a href="PosZLong.html" title="An AnyVal for non-negative Longs.">PosZLong</a></li><li class="indented3 " name="org.scalactic.exceptions" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="exceptions" class="anchorToMember"></a><a id="exceptions:exceptions" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/exceptions/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../exceptions/index.html" title=""><span class="name">exceptions</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="org.scalactic" id="org.scalactic" class="extype">scalactic</a></dd></dl></div></li><li class="indented3 " name="org.scalactic.source" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="source" class="anchorToMember"></a><a id="source:source" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/source/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../source/index.html" title=""><span class="name">source</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="org.scalactic" id="org.scalactic" class="extype">scalactic</a></dd></dl></div></li></ul></div></div><div id="content"><body class="package value">

<!-- Top of doc.scalactic.org [javascript] -->

<script id="adsArtimaScript" type="text/javascript" src="https://www.artima.com/assets/javascripts/3cbad67e7fa9539151489fd25cf64fdd-ads.js?product=Scalactic"></script>
<div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../../index.html" name="org" id="org" class="extype">org</a>.<a href="../index.html" name="org.scalactic" id="org.scalactic" class="extype">scalactic</a></p><h1>anyvals<span class="permalink"><a href="../../../org/scalactic/anyvals/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">anyvals</span></span></h4><div id="comment" class="fullcommenttop"></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="org.scalactic.anyvals.CompileTimeAssertions" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="CompileTimeAssertionsextendsAnyRef" class="anchorToMember"></a><a id="CompileTimeAssertions:CompileTimeAssertions" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/CompileTimeAssertions.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="CompileTimeAssertions.html" title="Trait providing assertion methods that can be called at compile time from macros to validate literals in source code."><span class="name">CompileTimeAssertions</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Trait providing assertion methods that can be called at compile time from macros
to validate literals in source code.</p><div class="fullcomment"><div class="comment cmt"><p>Trait providing assertion methods that can be called at compile time from macros
to validate literals in source code.</p><p>The intent of <code>CompileTimeAssertions</code> is to make it easier to create
<code>AnyVal</code>s that restrict the values of types for which Scala supports
literals: <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Char</code>,
and <code>String</code>. For example, if you are using odd integers in many places
in your code, you might have validity checks scattered throughout your code. Here's
an example of a method that both requires an odd <code>Int</code> is passed (as a
<em>precondition</em>, and ensures an odd * <code>Int</code> is returned (as
a <em>postcondition</em>):</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> nextOdd(i: <span class="stType">Int</span>): <span class="stType">Int</span> = {
  <span class="stReserved">def</span> isOdd(x: <span class="stType">Int</span>): <span class="stType">Boolean</span> = x.abs % <span class="stLiteral">2</span> == <span class="stLiteral">1</span>
  require(isOdd(i))
  (i + <span class="stLiteral">2</span>) ensuring (isOdd(_))
}
</pre></p><p>In either the precondition or postcondition check fails, an exception will
be thrown at runtime. If you have many methods like this you may want to
create a type to represent an odd <code>Int</code>, so that the checking
for validity errors is isolated in just one place. By using an <code>AnyVal</code>
you can avoid boxing the <code>Int</code>, which may be more efficient.
This might look like:</p><p><pre class="stHighlighted">
<span class="stReserved">final</span> <span class="stReserved">class</span> <span class="stType">OddInt</span> <span class="stReserved">private</span> (<span class="stReserved">val</span> value: <span class="stType">Int</span>) <span class="stReserved">extends</span> <span class="stType">AnyVal</span> {
  <span class="stReserved">override</span> <span class="stReserved">def</span> toString: <span class="stType">String</span> = s<span class="stQuotedString">"OddInt($value)"</span>
}
<br/><span class="stReserved">object</span> <span class="stType">OddInt</span> {
  <span class="stReserved">def</span> apply(value: <span class="stType">Int</span>): <span class="stType">OddInt</span> = {
    require(value.abs % <span class="stLiteral">2</span> == <span class="stLiteral">1</span>)
    <span class="stReserved">new</span> <span class="stType">OddInt</span>(value)
  }
}
</pre></p><p>An <code>AnyVal</code> cannot have any constructor code, so to ensure that
any <code>Int</code> passed to the <code>OddInt</code> constructor is actually
odd, the constructor must be private. That way the only way to construct a
new <code>OddInt</code> is via the <code>apply</code> factory method in the
<code>OddInt</code> companion object, which can require that the value be
odd. This design eliminates the need for placing <code>require</code> and
<code>ensuring</code> clauses anywhere else that odd <code>Int</code>s are
needed, because the type promises the constraint. The <code>nextOdd</code>
method could, therefore, be rewritten as:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> nextOdd(oi: <span class="stType">OddInt</span>): <span class="stType">OddInt</span> = <span class="stType">OddInt</span>(oi.value + <span class="stLiteral">2</span>)
</pre></p><p>Using the compile-time assertions provided by this trait, you can construct
a factory method implemented via a macro that causes a compile failure
if <code>OddInt.apply</code> is passed anything besides an odd
<code>Int</code> literal. Class <code>OddInt</code> would look exactly the
same as before:</p><p><pre class="stHighlighted">
<span class="stReserved">final</span> <span class="stReserved">class</span> <span class="stType">OddInt</span> <span class="stReserved">private</span> (<span class="stReserved">val</span> value: <span class="stType">Int</span>) <span class="stReserved">extends</span> <span class="stType">AnyVal</span> {
  <span class="stReserved">override</span> <span class="stReserved">def</span> toString: <span class="stType">String</span> = s<span class="stQuotedString">"OddInt($value)"</span>
}
</pre></p><p>In the companion object, however, the <code>apply</code> method would
be implemented in terms of a macro. Because the <code>apply</code> method
will only work with literals, you'll need a second method that can work
an any expression of type <code>Int</code>. We recommend a <code>from</code> method
that returns an <code>Option[OddInt]</code> that returns <code>Some[OddInt}</code> if the passed <code>Int</code> is odd,
else returns <code>None</code>, and an <code>ensuringValid</code> method that returns an <code>OddInt</code>
if the passed <code>Int</code> is valid, else throws <code>AssertionError</code>.</p><p><pre class="stHighlighted">
<span class="stReserved">object</span> <span class="stType">OddInt</span> {
<br/>  <span class="stLineComment">// The from factory method validates at run time</span>
  <span class="stReserved">def</span> from(value: <span class="stType">Int</span>): <span class="stType">Option[OddInt]</span> =
    <span class="stReserved">if</span> (OddIntMacro.isValid(value)) <span class="stType">Some</span>(<span class="stReserved">new</span> <span class="stType">OddInt</span>(value)) <span class="stReserved">else</span> <span class="stType">None</span>
<br/>  <span class="stLineComment">// The ensuringValid factory method validates at run time, but throws</span>
  <span class="stLineComment">// an AssertionError if invalid</span>
  <span class="stReserved">def</span> ensuringValid(value: <span class="stType">Int</span>): <span class="stType">OddInt</span> =
    <span class="stReserved">if</span> (OddIntMacro.isValid(value)) <span class="stReserved">new</span> <span class="stType">OddInt</span>(value) <span class="stReserved">else</span> {
      <span class="stReserved">throw</span> <span class="stReserved">new</span> <span class="stType">AssertionError</span>(s<span class="stQuotedString">"$value was not a valid OddInt"</span>)
    }
<br/>  <span class="stLineComment">// The apply factory method validates at compile time</span>
  <span class="stReserved">import</span> scala.language.experimental.macros
  <span class="stReserved">def</span> apply(value: <span class="stType">Int</span>): <span class="stType">OddInt</span> = macro OddIntMacro.apply
}
</pre></p><p>The <code>apply</code> method refers to a macro implementation method in class
<code>PosIntMacro</code>. The macro implementation of any such method can look
very similar to this one. The only changes you'd need to make is the
<code>isValid</code> method implementation and the text of the error messages.</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalactic.anyvals.CompileTimeAssertions
<span class="stReserved">import</span> reflect.macros.Context
<br/><span class="stReserved">object</span> <span class="stType">OddIntMacro</span> <span class="stReserved">extends</span> <span class="stType">CompileTimeAssertions</span> {
<br/>  <span class="stLineComment">// Validation method used at both compile- and run-time</span>
  <span class="stReserved">def</span> isValid(i: <span class="stType">Int</span>): <span class="stType">Boolean</span> = i.abs % <span class="stLiteral">2</span> == <span class="stLiteral">1</span>
<br/>  <span class="stLineComment">// Apply macro that performs a compile-time assertion</span>
  <span class="stReserved">def</span> apply(c: <span class="stType">Context</span>)(value: <span class="stType">c.Expr[Int]</span>): <span class="stType">c.Expr[OddInt]</span> = {
<br/>    <span class="stLineComment">// Prepare potential compiler error messages</span>
    <span class="stReserved">val</span> notValidMsg = <span class="stQuotedString">"OddInt.apply can only be invoked on odd Int literals, like OddInt(3)."</span>
    <span class="stReserved">val</span> notLiteralMsg = <span class="stQuotedString">"OddInt.apply can only be invoked on Int literals, like "</span> +
          <span class="stQuotedString">"OddInt(3). Please use OddInt.from instead."</span>
<br/>    <span class="stLineComment">// Validate via a compile-time assertion</span>
    ensureValidIntLiteral(c)(value, notValidMsg, notLiteralMsg)(isValid)
<br/>    <span class="stLineComment">// Validated, so rewrite the apply call to a from call</span>
    c.universe.reify { OddInt.ensuringValid(value.splice) }
  }
}
</pre></p><p>The <code>isValid</code> method just takes the underlying type and returns <code>true</code> if it is valid,
else <code>false</code>. This method is placed here so the same valiation code can be used both in
the <code>from</code> method at runtime and the <code>apply</code> macro at compile time. The <code>apply</code>
actually does just two things. It calls a <code>ensureValidIntLiteral</code>, performing a compile-time assertion
that value passed to <code>apply</code> is an <code>Int</code> literal that is valid (in this case, odd).
If the assertion fails, <code>ensureValidIntLiteral</code> will complete abruptly with an exception that will
contain an appropriate error message (one of the two you passed in) and cause a compiler error with that message.
If the assertion succeeds, <code>ensureValidIntLiteral</code> will just return normally. The next line of code
will then execute. This line of code must construct an AST (abstract syntax tree) of code that will replace
the <code>OddInt.apply</code> invocation. We invoke the other factory method that either returns an <code>OddInt</code>
or throws an <code>AssertionError</code>, since we've proven at compile time that the call will succeed.</p><p>You may wish to use quasi-quotes instead of reify. The reason we use reify is that this also works on 2.10 without
any additional plugin (i.e., you don't need macro paradise), and Scalactic supports 2.10.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.FiniteDouble" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="FiniteDoubleextendsAnyVal" class="anchorToMember"></a><a id="FiniteDouble:FiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/FiniteDouble.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="FiniteDouble.html" title="An AnyVal for finite Doubles."><span class="name">FiniteDouble</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite <code>Double</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite <code>Double</code>s.</p><p>Because <code>FiniteDouble</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Double</code>, being
boxed only when a <code>Double</code> would have been boxed.</p><p>The <code>FiniteDouble.apply</code> factory method is
implemented in terms of a macro that checks literals for
validity at compile time. Calling
<code>FiniteDouble.apply</code> with a literal
<code>Double</code> value will either produce a valid
<code>FiniteDouble</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; FiniteDouble(1.1)
res1: org.scalactic.anyvals.FiniteDouble = FiniteDouble(1.1)

scala&gt; FiniteDouble(Finite.PositiveInfinity)
&lt;console&gt;:14: error: FiniteDouble.apply can only be invoked on a finite (i != Double.NegativeInfinity && i != Double.PositiveInfinity && !i.isNaN) floating point literal, like FiniteDouble(1.1).
              FiniteDouble(Finite.PositiveInfinity)
                       ^
</pre></p><p><code>FiniteDouble.apply</code> cannot be used if the value
being passed is a variable (<em>i.e.</em>, not a literal),
because the macro cannot determine the validity of variables
at compile time (just literals). If you try to pass a
variable to <code>FiniteDouble.apply</code>, you'll get a
compiler error that suggests you use a different factor
method, <code>FiniteDouble.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1.1
x: Double = 1.1

scala&gt; FiniteDouble(x)
&lt;console&gt;:15: error: FiniteDouble.apply can only be invoked on a floating point literal, like FiniteDouble(1.1). Please use FiniteDouble.from instead.
              FiniteDouble(x)
                       ^
</pre></p><p>The <code>FiniteDouble.from</code> factory method will inspect
the value at runtime and return an
<code>Option[FiniteDouble]</code>. If the value is valid,
<code>FiniteDouble.from</code> will return a
<code>Some[FiniteDouble]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; FiniteDouble.from(x)
res4: Option[org.scalactic.anyvals.FiniteDouble] = Some(FiniteDouble(1.1))

scala&gt; val y = Finite.PositiveInfinity
y: Double = Finite.PositiveInfinity

scala&gt; FiniteDouble.from(y)
res5: Option[org.scalactic.anyvals.FiniteDouble] = None
</pre></p><p>The <code>FiniteDouble.apply</code> factory method is marked
implicit, so that you can pass literal <code>Double</code>s
into methods that require <code>FiniteDouble</code>, and get the
same compile-time checking you get when calling
<code>FiniteDouble.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: FiniteDouble): Double = Double.MaxValue - pos
invert: (pos: org.scalactic.anyvals.FiniteDouble)Double

scala&gt; invert(1.1)
res6: Double = 1.7976931348623157E308

scala&gt; invert(Double.MaxValue)
res8: Double = 0.0

scala&gt; invert(Finite.PositiveInfinity)
&lt;console&gt;:15: error: FiniteDouble.apply can only be invoked on a finite (i != Double.NegativeInfinity && i != Double.PositiveInfinity && !i.isNaN) floating point literal, like FiniteDouble(1.1).
              invert(Finite.PositiveInfinity)
                     ^

</pre></p><p>This example also demonstrates that the
<code>FiniteDouble</code> companion object also defines implicit
widening conversions when a similar conversion is provided in
Scala. This makes it convenient to use a
<code>FiniteDouble</code> where a <code>Double</code> is
needed. An example is the subtraction in the body of the
<code>invert</code> method defined above,
<code>Double.MaxValue - pos</code>. Although
<code>Double.MaxValue</code> is a <code>Double</code>, which
has no <code>-</code> method that takes a
<code>FiniteDouble</code> (the type of <code>pos</code>), you
can still subtract <code>pos</code>, because the
<code>FiniteDouble</code> will be implicitly widened to
<code>Double</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.FiniteFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="FiniteFloatextendsAnyVal" class="anchorToMember"></a><a id="FiniteFloat:FiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/FiniteFloat.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="FiniteFloat.html" title="An AnyVal for finite Floats."><span class="name">FiniteFloat</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite <code>Float</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite <code>Float</code>s.</p><p>Because <code>FiniteFloat</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Float</code>, being
boxed only when an <code>Float</code> would have been boxed.</p><p>The <code>FiniteFloat.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>FiniteFloat.apply</code> with a
literal <code>Float</code> value will either produce a valid
<code>FiniteFloat</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; FiniteFloat(42.1fF)
res0: org.scalactic.anyvals.FiniteFloat = FiniteFloat(42.1f)

scala&gt; FiniteFloat(Float.PositiveInfinityF)
&lt;console&gt;:14: error: FiniteFloat.apply can only be invoked on a finite (i != Float.NegativeInfinity && i != Float.PositiveInfinity && !i.isNaN) floating point literal, like FiniteFloat(42.1fF).
              FiniteFloat(42.1fF)
                      ^
</pre></p><p><code>FiniteFloat.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>FiniteFloat.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>FiniteFloat.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 42.1fF
x: Float = 42.1f

scala&gt; FiniteFloat(x)
&lt;console&gt;:15: error: FiniteFloat.apply can only be invoked on a floating point literal, like FiniteFloat(42.1fF). Please use FiniteFloat.from instead.
              FiniteFloat(x)
                      ^
</pre></p><p>The <code>FiniteFloat.from</code> factory method will inspect
the value at runtime and return an
<code>Option[FiniteFloat]</code>. If the value is valid,
<code>FiniteFloat.from</code> will return a
<code>Some[FiniteFloat]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; FiniteFloat.from(x)
res3: Option[org.scalactic.anyvals.FiniteFloat] = Some(FiniteFloat(42.1f))

scala&gt; val y = Float.PositiveInfinityF
y: Float = Float.PositiveInfinity

scala&gt; FiniteFloat.from(y)
res4: Option[org.scalactic.anyvals.FiniteFloat] = None
</pre></p><p>The <code>FiniteFloat.apply</code> factory method is marked
implicit, so that you can pass literal <code>Float</code>s
into methods that require <code>FiniteFloat</code>, and get the
same compile-time checking you get when calling
<code>FiniteFloat.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: FiniteFloat): Float = Float.MaxValue - pos
invert: (pos: org.scalactic.anyvals.FiniteFloat)Float

scala&gt; invert(42.1fF)
res5: Float = 3.4028235E38

scala&gt; invert(Float.MaxValue)
res6: Float = 0.0

scala&gt; invert(Float.PositiveInfinityF)
&lt;console&gt;:15: error: FiniteFloat.apply can only be invoked on a finite (i != Float.NegativeInfinity && i != Float.PositiveInfinity && !i.isNaN) floating point literal, like FiniteFloat(42.1fF).
              invert(0.0F)
                     ^

scala&gt; invert(Float.PositiveInfinityF)
&lt;console&gt;:15: error: FiniteFloat.apply can only be invoked on a finite (i != Float.NegativeInfinity && i != Float.PositiveInfinity && !i.isNaN) floating point literal, like FiniteFloat(42.1fF).
              invert(Float.PositiveInfinityF)
                      ^

</pre></p><p>This example also demonstrates that the <code>FiniteFloat</code>
companion object also defines implicit widening conversions
when no loss of precision will occur. This makes it convenient to use a
<code>FiniteFloat</code> where a <code>Float</code> or wider
type is needed. An example is the subtraction in the body of
the <code>invert</code> method defined above,
<code>Float.MaxValue - pos</code>. Although
<code>Float.MaxValue</code> is a <code>Float</code>, which
has no <code>-</code> method that takes a
<code>FiniteFloat</code> (the type of <code>pos</code>), you can
still subtract <code>pos</code>, because the
<code>FiniteFloat</code> will be implicitly widened to
<code>Float</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegDouble" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegDoubleextendsAnyVal" class="anchorToMember"></a><a id="NegDouble:NegDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegDouble.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegDouble.html" title="An AnyVal for negative Doubles."><span class="name">NegDouble</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for negative <code>Double</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for negative <code>Double</code>s.</p><p>Because <code>NegDouble</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Double</code>, being
boxed only when a <code>Double</code> would have been boxed.</p><p>The <code>NegDouble.apply</code> factory method is
implemented in terms of a macro that checks literals for
validity at compile time. Calling
<code>NegDouble.apply</code> with a literal
<code>Double</code> value will either produce a valid
<code>NegDouble</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegDouble(-1.1)
res1: org.scalactic.anyvals.NegDouble = NegDouble(-1.1)

scala&gt; NegDouble(1.1)
&lt;console&gt;:14: error: NegDouble.apply can only be invoked on a negative (i < 0.0) floating point literal, like NegDouble(-1.1).
              NegDouble(1.1)
                       ^
</pre></p><p><code>NegDouble.apply</code> cannot be used if the value
being passed is a variable (<em>i.e.</em>, not a literal),
because the macro cannot determine the validity of variables
at compile time (just literals). If you try to pass a
variable to <code>NegDouble.apply</code>, you'll get a
compiler error that suggests you use a different factor
method, <code>NegDouble.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = -1.1
x: Double = -1.1

scala&gt; NegDouble(x)
&lt;console&gt;:15: error: NegDouble.apply can only be invoked on a floating point literal, like NegDouble(-1.1). Please use NegDouble.from instead.
              NegDouble(x)
                       ^
</pre></p><p>The <code>NegDouble.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NegDouble]</code>. If the value is valid,
<code>NegDouble.from</code> will return a
<code>Some[NegDouble]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NegDouble.from(x)
res4: Option[org.scalactic.anyvals.NegDouble] = Some(NegDouble(-1.1))

scala&gt; val y = 1.1
y: Double = 1.1

scala&gt; NegDouble.from(y)
res5: Option[org.scalactic.anyvals.NegDouble] = None
</pre></p><p>The <code>NegDouble.apply</code> factory method is marked
implicit, so that you can pass literal <code>Double</code>s
into methods that require <code>NegDouble</code>, and get the
same compile-time checking you get when calling
<code>NegDouble.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegDouble): Double = Double.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegDouble)Double

scala&gt; invert(1.1)
res6: Double = 1.7976931348623157E308

scala&gt; invert(Double.MaxValue)
res8: Double = 0.0

scala&gt; invert(1.1)
&lt;console&gt;:15: error: NegDouble.apply can only be invoked on a negative (i < 0.0) floating point literal, like NegDouble(-1.1).
              invert(1.1)
                     ^

</pre></p><p>This example also demonstrates that the
<code>NegDouble</code> companion object also defines implicit
widening conversions when a similar conversion is provided in
Scala. This makes it convenient to use a
<code>NegDouble</code> where a <code>Double</code> is
needed. An example is the subtraction in the body of the
<code>invert</code> method defined above,
<code>Double.MaxValue - pos</code>. Although
<code>Double.MaxValue</code> is a <code>Double</code>, which
has no <code>-</code> method that takes a
<code>NegDouble</code> (the type of <code>pos</code>), you
can still subtract <code>pos</code>, because the
<code>NegDouble</code> will be implicitly widened to
<code>Double</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegFiniteDouble" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegFiniteDoubleextendsAnyVal" class="anchorToMember"></a><a id="NegFiniteDouble:NegFiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegFiniteDouble.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegFiniteDouble.html" title="An AnyVal for finite negative Doubles."><span class="name">NegFiniteDouble</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite negative <code>Double</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite negative <code>Double</code>s.</p><p>Because <code>NegFiniteDouble</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Double</code>, being
boxed only when a <code>Double</code> would have been boxed.</p><p>The <code>NegFiniteDouble.apply</code> factory method is
implemented in terms of a macro that checks literals for
validity at compile time. Calling
<code>NegFiniteDouble.apply</code> with a literal
<code>Double</code> value will either produce a valid
<code>NegFiniteDouble</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegFiniteDouble(-1.1)
res1: org.scalactic.anyvals.NegFiniteDouble = NegFiniteDouble(-1.1)

scala&gt; NegFiniteDouble(1.1)
&lt;console&gt;:14: error: NegFiniteDouble.apply can only be invoked on a finite negative (i < 0.0  && i != Double.NegativeInfinity) floating point literal, like NegFiniteDouble(-1.1).
              NegFiniteDouble(1.1)
                       ^
</pre></p><p><code>NegFiniteDouble.apply</code> cannot be used if the value
being passed is a variable (<em>i.e.</em>, not a literal),
because the macro cannot determine the validity of variables
at compile time (just literals). If you try to pass a
variable to <code>NegFiniteDouble.apply</code>, you'll get a
compiler error that suggests you use a different factor
method, <code>NegFiniteDouble.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = -1.1
x: Double = -1.1

scala&gt; NegFiniteDouble(x)
&lt;console&gt;:15: error: NegFiniteDouble.apply can only be invoked on a floating point literal, like NegFiniteDouble(-1.1). Please use NegFiniteDouble.from instead.
              NegFiniteDouble(x)
                       ^
</pre></p><p>The <code>NegFiniteDouble.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NegFiniteDouble]</code>. If the value is valid,
<code>NegFiniteDouble.from</code> will return a
<code>Some[NegFiniteDouble]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NegFiniteDouble.from(x)
res4: Option[org.scalactic.anyvals.NegFiniteDouble] = Some(NegFiniteDouble(-1.1))

scala&gt; val y = 1.1
y: Double = 1.1

scala&gt; NegFiniteDouble.from(y)
res5: Option[org.scalactic.anyvals.NegFiniteDouble] = None
</pre></p><p>The <code>NegFiniteDouble.apply</code> factory method is marked
implicit, so that you can pass literal <code>Double</code>s
into methods that require <code>NegFiniteDouble</code>, and get the
same compile-time checking you get when calling
<code>NegFiniteDouble.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegFiniteDouble): Double = Double.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegFiniteDouble)Double

scala&gt; invert(1.1)
res6: Double = 1.7976931348623157E308

scala&gt; invert(Double.MaxValue)
res8: Double = 0.0

scala&gt; invert(1.1)
&lt;console&gt;:15: error: NegFiniteDouble.apply can only be invoked on a finite negative (i < 0.0  && i != Double.NegativeInfinity) floating point literal, like NegFiniteDouble(-1.1).
              invert(1.1)
                     ^

</pre></p><p>This example also demonstrates that the
<code>NegFiniteDouble</code> companion object also defines implicit
widening conversions when a similar conversion is provided in
Scala. This makes it convenient to use a
<code>NegFiniteDouble</code> where a <code>Double</code> is
needed. An example is the subtraction in the body of the
<code>invert</code> method defined above,
<code>Double.MaxValue - pos</code>. Although
<code>Double.MaxValue</code> is a <code>Double</code>, which
has no <code>-</code> method that takes a
<code>NegFiniteDouble</code> (the type of <code>pos</code>), you
can still subtract <code>pos</code>, because the
<code>NegFiniteDouble</code> will be implicitly widened to
<code>Double</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegFiniteFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegFiniteFloatextendsAnyVal" class="anchorToMember"></a><a id="NegFiniteFloat:NegFiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegFiniteFloat.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegFiniteFloat.html" title="An AnyVal for finite negative Floats."><span class="name">NegFiniteFloat</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite negative <code>Float</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite negative <code>Float</code>s.</p><p>Note: a <code>NegFiniteFloat</code> may not equal 0.0. If you want negative number or 0, use <a href="NegZFiniteFloat.html" name="org.scalactic.anyvals.NegZFiniteFloat" id="org.scalactic.anyvals.NegZFiniteFloat" class="extype">NegZFiniteFloat</a>.</p><p>Because <code>NegFiniteFloat</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Float</code>, being
boxed only when an <code>Float</code> would have been boxed.</p><p>The <code>NegFiniteFloat.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>NegFiniteFloat.apply</code> with a
literal <code>Float</code> value will either produce a valid
<code>NegFiniteFloat</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegFiniteFloat(-42.1fF)
res0: org.scalactic.anyvals.NegFiniteFloat = NegFiniteFloat(-42.1f)

scala&gt; NegFiniteFloat(0.0fF)
&lt;console&gt;:14: error: NegFiniteFloat.apply can only be invoked on a finite negative (i < 0.0f && i != Float.NegativeInfinity) floating point literal, like NegFiniteFloat(-42.1fF).
              NegFiniteFloat(-42.1fF)
                      ^
</pre></p><p><code>NegFiniteFloat.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>NegFiniteFloat.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>NegFiniteFloat.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = -42.1fF
x: Float = -42.1f

scala&gt; NegFiniteFloat(x)
&lt;console&gt;:15: error: NegFiniteFloat.apply can only be invoked on a floating point literal, like NegFiniteFloat(-42.1fF). Please use NegFiniteFloat.from instead.
              NegFiniteFloat(x)
                      ^
</pre></p><p>The <code>NegFiniteFloat.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NegFiniteFloat]</code>. If the value is valid,
<code>NegFiniteFloat.from</code> will return a
<code>Some[NegFiniteFloat]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NegFiniteFloat.from(x)
res3: Option[org.scalactic.anyvals.NegFiniteFloat] = Some(NegFiniteFloat(-42.1f))

scala&gt; val y = 0.0fF
y: Float = 0.0f

scala&gt; NegFiniteFloat.from(y)
res4: Option[org.scalactic.anyvals.NegFiniteFloat] = None
</pre></p><p>The <code>NegFiniteFloat.apply</code> factory method is marked
implicit, so that you can pass literal <code>Float</code>s
into methods that require <code>NegFiniteFloat</code>, and get the
same compile-time checking you get when calling
<code>NegFiniteFloat.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegFiniteFloat): Float = Float.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegFiniteFloat)Float

scala&gt; invert(-42.1fF)
res5: Float = 3.4028235E38

scala&gt; invert(Float.MaxValue)
res6: Float = 0.0

scala&gt; invert(0.0fF)
&lt;console&gt;:15: error: NegFiniteFloat.apply can only be invoked on a finite negative (i < 0.0f && i != Float.NegativeInfinity) floating point literal, like NegFiniteFloat(-42.1fF).
              invert(0.0F)
                     ^

scala&gt; invert(0.0fF)
&lt;console&gt;:15: error: NegFiniteFloat.apply can only be invoked on a finite negative (i < 0.0f && i != Float.NegativeInfinity) floating point literal, like NegFiniteFloat(-42.1fF).
              invert(0.0fF)
                      ^

</pre></p><p>This example also demonstrates that the <code>NegFiniteFloat</code>
companion object also defines implicit widening conversions
when no loss of precision will occur. This makes it convenient to use a
<code>NegFiniteFloat</code> where a <code>Float</code> or wider
type is needed. An example is the subtraction in the body of
the <code>invert</code> method defined above,
<code>Float.MaxValue - pos</code>. Although
<code>Float.MaxValue</code> is a <code>Float</code>, which
has no <code>-</code> method that takes a
<code>NegFiniteFloat</code> (the type of <code>pos</code>), you can
still subtract <code>pos</code>, because the
<code>NegFiniteFloat</code> will be implicitly widened to
<code>Float</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegFloatextendsAnyVal" class="anchorToMember"></a><a id="NegFloat:NegFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegFloat.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegFloat.html" title="An AnyVal for megative Floats."><span class="name">NegFloat</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for megative <code>Float</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for megative <code>Float</code>s.</p><p>Note: a <code>NegFloat</code> may not equal 0.0. If you want negative number or 0, use <a href="NegZFloat.html" name="org.scalactic.anyvals.NegZFloat" id="org.scalactic.anyvals.NegZFloat" class="extype">NegZFloat</a>.</p><p>Because <code>NegFloat</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Float</code>, being
boxed only when an <code>Float</code> would have been boxed.</p><p>The <code>NegFloat.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>NegFloat.apply</code> with a
literal <code>Float</code> value will either produce a valid
<code>NegFloat</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegFloat(-42.1fF)
res0: org.scalactic.anyvals.NegFloat = NegFloat(-42.1f)

scala&gt; NegFloat(0.0fF)
&lt;console&gt;:14: error: NegFloat.apply can only be invoked on a megative (i < 0.0f) floating point literal, like NegFloat(-42.1fF).
              NegFloat(-42.1fF)
                      ^
</pre></p><p><code>NegFloat.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>NegFloat.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>NegFloat.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = -42.1fF
x: Float = -42.1f

scala&gt; NegFloat(x)
&lt;console&gt;:15: error: NegFloat.apply can only be invoked on a floating point literal, like NegFloat(-42.1fF). Please use NegFloat.from instead.
              NegFloat(x)
                      ^
</pre></p><p>The <code>NegFloat.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NegFloat]</code>. If the value is valid,
<code>NegFloat.from</code> will return a
<code>Some[NegFloat]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NegFloat.from(x)
res3: Option[org.scalactic.anyvals.NegFloat] = Some(NegFloat(-42.1f))

scala&gt; val y = 0.0fF
y: Float = 0.0f

scala&gt; NegFloat.from(y)
res4: Option[org.scalactic.anyvals.NegFloat] = None
</pre></p><p>The <code>NegFloat.apply</code> factory method is marked
implicit, so that you can pass literal <code>Float</code>s
into methods that require <code>NegFloat</code>, and get the
same compile-time checking you get when calling
<code>NegFloat.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegFloat): Float = Float.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegFloat)Float

scala&gt; invert(-42.1fF)
res5: Float = 3.4028235E38

scala&gt; invert(Float.MaxValue)
res6: Float = 0.0

scala&gt; invert(0.0fF)
&lt;console&gt;:15: error: NegFloat.apply can only be invoked on a megative (i < 0.0f) floating point literal, like NegFloat(-42.1fF).
              invert(0.0F)
                     ^

scala&gt; invert(0.0fF)
&lt;console&gt;:15: error: NegFloat.apply can only be invoked on a megative (i < 0.0f) floating point literal, like NegFloat(-42.1fF).
              invert(0.0fF)
                      ^

</pre></p><p>This example also demonstrates that the <code>NegFloat</code>
companion object also defines implicit widening conversions
when no loss of precision will occur. This makes it convenient to use a
<code>NegFloat</code> where a <code>Float</code> or wider
type is needed. An example is the subtraction in the body of
the <code>invert</code> method defined above,
<code>Float.MaxValue - pos</code>. Although
<code>Float.MaxValue</code> is a <code>Float</code>, which
has no <code>-</code> method that takes a
<code>NegFloat</code> (the type of <code>pos</code>), you can
still subtract <code>pos</code>, because the
<code>NegFloat</code> will be implicitly widened to
<code>Float</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegInt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegIntextendsAnyVal" class="anchorToMember"></a><a id="NegInt:NegInt" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegInt.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegInt.html" title="An AnyVal for negative Ints."><span class="name">NegInt</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for negative <code>Int</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for negative <code>Int</code>s.</p><p>Note: a <code>NegInt</code> may not equal 0. If you want negative number or 0, use <a href="NegZInt.html" name="org.scalactic.anyvals.NegZInt" id="org.scalactic.anyvals.NegZInt" class="extype">NegZInt</a>.</p><p>Because <code>NegInt</code> is an <code>AnyVal</code> it will usually be
as efficient as an <code>Int</code>, being boxed only when an <code>Int</code>
would have been boxed.</p><p>The <code>NegInt.apply</code> factory method is implemented in terms of a macro that
checks literals for validity at compile time. Calling <code>NegInt.apply</code> with
a literal <code>Int</code> value will either produce a valid <code>NegInt</code> instance
at run time or an error at compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegInt(-42)
res0: org.scalactic.anyvals.NegInt = NegInt(-42)

scala&gt; NegInt(0)
&lt;console&gt;:14: error: NegInt.apply can only be invoked on a negative (i < 0) literal, like NegInt(-42).
              NegInt(0)
                    ^
</pre></p><p><code>NegInt.apply</code> cannot be used if the value being passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at compile time (just literals). If you try to pass a variable
to <code>NegInt.apply</code>, you'll get a compiler error that suggests you use a different factor method,
<code>NegInt.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1
x: Int = 1

scala&gt; NegInt(x)
&lt;console&gt;:15: error: NegInt.apply can only be invoked on a negative integer literal, like NegInt(-42). Please use NegInt.from instead.
              NegInt(x)
                    ^
</pre></p><p>The <code>NegInt.from</code> factory method will inspect the value at runtime and return an <code>Option[NegInt]</code>. If
the value is valid, <code>NegInt.from</code> will return a <code>Some[NegInt]</code>, else it will return a <code>None</code>.
Here's an example:</p><p><pre class="stREPL">
scala&gt; NegInt.from(x)
res3: Option[org.scalactic.anyvals.NegInt] = Some(NegInt(1))

scala&gt; val y = 0
y: Int = 0

scala&gt; NegInt.from(y)
res4: Option[org.scalactic.anyvals.NegInt] = None
</pre></p><p>The <code>NegInt.apply</code> factory method is marked implicit, so that you can pass literal <code>Int</code>s
into methods that require <code>NegInt</code>, and get the same compile-time checking you get when calling
<code>NegInt.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegInt): Int = Int.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegInt)Int

scala&gt; invert(1)
res0: Int = 2147483646

scala&gt; invert(Int.MaxValue)
res1: Int = 0

scala&gt; invert(0)
&lt;console&gt;:15: error: NegInt.apply can only be invoked on a negative (i < 0) integer literal, like NegInt(-42).
              invert(0)
                     ^

scala&gt; invert(-1)
&lt;console&gt;:15: error: NegInt.apply can only be invoked on a negative (i < 0) integer literal, like NegInt(-42).
              invert(-1)
                      ^

</pre></p><p>This example also demonstrates that the <code>NegInt</code> companion object also defines implicit widening conversions
when either no loss of precision will occur or a similar conversion is provided in Scala. (For example, the implicit
conversion from <code>Int</code> to </code>Float</code> in Scala can lose precision.) This makes it convenient to
use a <code>NegInt</code> where an <code>Int</code> or wider type is needed. An example is the subtraction in the body
of the <code>invert</code> method defined above, <code>Int.MaxValue - pos</code>. Although <code>Int.MaxValue</code> is
an <code>Int</code>, which has no <code>-</code> method that takes a <code>NegInt</code> (the type of <code>pos</code>),
you can still subtract <code>pos</code>, because the <code>NegInt</code> will be implicitly widened to <code>Int</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegLong" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegLongextendsAnyVal" class="anchorToMember"></a><a id="NegLong:NegLong" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegLong.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegLong.html" title="An AnyVal for negative Longs."><span class="name">NegLong</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for negative <code>Long</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for negative <code>Long</code>s.</p><p>Note: a <code>NegLong</code> may not equal 0. If you want negative number or 0, use <a href="NegZLong.html" name="org.scalactic.anyvals.NegZLong" id="org.scalactic.anyvals.NegZLong" class="extype">NegZLong</a>.</p><p>Because <code>NegLong</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Long</code>, being
boxed only when an <code>Long</code> would have been boxed.</p><p>The <code>NegLong.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>NegLong.apply</code> with a
literal <code>Long</code> value will either produce a valid
<code>NegLong</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegLong(-42L)
res0: org.scalactic.anyvals.NegLong = NegLong(-42L)

scala&gt; NegLong(0L)
&lt;console&gt;:14: error: NegLong.apply can only be invoked on a negative (i < 0L) integer literal, like NegLong(-42L).
              NegLong(0L)
                     ^
</pre></p><p><code>NegLong.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>NegLong.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>NegLong.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = -42LL
x: Long = -42L

scala&gt; NegLong(x)
&lt;console&gt;:15: error: NegLong.apply can only be invoked on an long literal, like NegLong(-42L). Please use NegLong.from instead.
              NegLong(x)
                     ^
</pre></p><p>The <code>NegLong.from</code> factory method will inspect the
value at runtime and return an
<code>Option[NegLong]</code>. If the value is valid,
<code>NegLong.from</code> will return a
<code>Some[NegLong]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NegLong.from(x)
res3: Option[org.scalactic.anyvals.NegLong] = Some(NegLong(-42L))

scala&gt; val y = 0LL
y: Long = 0L

scala&gt; NegLong.from(y)
res4: Option[org.scalactic.anyvals.NegLong] = None
</pre></p><p>The <code>NegLong.apply</code> factory method is marked
implicit, so that you can pass literal <code>Long</code>s
into methods that require <code>NegLong</code>, and get the
same compile-time checking you get when calling
<code>NegLong.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegLong): Long = Long.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegLong)Long

scala&gt; invert(1L)
res5: Long = 9223372036854775806

scala&gt; invert(Long.MaxValue)
res6: Long = 0

scala&gt; invert(0LL)
&lt;console&gt;:15: error: NegLong.apply can only be invoked on a negative (i < 0L) integer literal, like NegLong(-42LL).
              invert(0LL)
                     ^

</pre></p><p>This example also demonstrates that the <code>NegLong</code>
companion object also defines implicit widening conversions
when either no loss of precision will occur or a similar
conversion is provided in Scala. (For example, the implicit
conversion from <code>Long</code> to </code>Double</code> in
Scala can lose precision.) This makes it convenient to use a
<code>NegLong</code> where a <code>Long</code> or wider type
is needed. An example is the subtraction in the body of the
<code>invert</code> method defined above, <code>Long.MaxValue
- pos</code>. Although <code>Long.MaxValue</code> is a
<code>Long</code>, which has no <code>-</code> method that
takes a <code>NegLong</code> (the type of <code>pos</code>),
you can still subtract <code>pos</code>, because the
<code>NegLong</code> will be implicitly widened to
<code>Long</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegZDouble" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegZDoubleextendsAnyVal" class="anchorToMember"></a><a id="NegZDouble:NegZDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZDouble.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegZDouble.html" title="An AnyVal for non-positive Doubles."><span class="name">NegZDouble</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-positive <code>Double</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-positive <code>Double</code>s.</p><p>Because <code>NegZDouble</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Double</code>, being
boxed only when a <code>Double</code> would have been boxed.</p><p>The <code>NegZDouble.apply</code> factory method is
implemented in terms of a macro that checks literals for
validity at compile time. Calling
<code>NegZDouble.apply</code> with a literal
<code>Double</code> value will either produce a valid
<code>NegZDouble</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegZDouble(-1.1)
res1: org.scalactic.anyvals.NegZDouble = NegZDouble(-1.1)

scala&gt; NegZDouble(1.1)
&lt;console&gt;:14: error: NegZDouble.apply can only be invoked on a non-positive (i <= 0.0) floating point literal, like NegZDouble(-1.1).
              NegZDouble(1.1)
                       ^
</pre></p><p><code>NegZDouble.apply</code> cannot be used if the value
being passed is a variable (<em>i.e.</em>, not a literal),
because the macro cannot determine the validity of variables
at compile time (just literals). If you try to pass a
variable to <code>NegZDouble.apply</code>, you'll get a
compiler error that suggests you use a different factor
method, <code>NegZDouble.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = -1.1
x: Double = -1.1

scala&gt; NegZDouble(x)
&lt;console&gt;:15: error: NegZDouble.apply can only be invoked on a floating point literal, like NegZDouble(-1.1). Please use NegZDouble.from instead.
              NegZDouble(x)
                       ^
</pre></p><p>The <code>NegZDouble.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NegZDouble]</code>. If the value is valid,
<code>NegZDouble.from</code> will return a
<code>Some[NegZDouble]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NegZDouble.from(x)
res4: Option[org.scalactic.anyvals.NegZDouble] = Some(NegZDouble(-1.1))

scala&gt; val y = 1.1
y: Double = 1.1

scala&gt; NegZDouble.from(y)
res5: Option[org.scalactic.anyvals.NegZDouble] = None
</pre></p><p>The <code>NegZDouble.apply</code> factory method is marked
implicit, so that you can pass literal <code>Double</code>s
into methods that require <code>NegZDouble</code>, and get the
same compile-time checking you get when calling
<code>NegZDouble.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegZDouble): Double = Double.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegZDouble)Double

scala&gt; invert(1.1)
res6: Double = 1.7976931348623157E308

scala&gt; invert(Double.MaxValue)
res8: Double = 0.0

scala&gt; invert(1.1)
&lt;console&gt;:15: error: NegZDouble.apply can only be invoked on a non-positive (i <= 0.0) floating point literal, like NegZDouble(-1.1).
              invert(1.1)
                     ^

</pre></p><p>This example also demonstrates that the
<code>NegZDouble</code> companion object also defines implicit
widening conversions when a similar conversion is provided in
Scala. This makes it convenient to use a
<code>NegZDouble</code> where a <code>Double</code> is
needed. An example is the subtraction in the body of the
<code>invert</code> method defined above,
<code>Double.MaxValue - pos</code>. Although
<code>Double.MaxValue</code> is a <code>Double</code>, which
has no <code>-</code> method that takes a
<code>NegZDouble</code> (the type of <code>pos</code>), you
can still subtract <code>pos</code>, because the
<code>NegZDouble</code> will be implicitly widened to
<code>Double</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegZFiniteDouble" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegZFiniteDoubleextendsAnyVal" class="anchorToMember"></a><a id="NegZFiniteDouble:NegZFiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZFiniteDouble.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegZFiniteDouble.html" title="An AnyVal for finite non-positive Doubles."><span class="name">NegZFiniteDouble</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite non-positive <code>Double</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite non-positive <code>Double</code>s.</p><p>Because <code>NegZFiniteDouble</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Double</code>, being
boxed only when a <code>Double</code> would have been boxed.</p><p>The <code>NegZFiniteDouble.apply</code> factory method is
implemented in terms of a macro that checks literals for
validity at compile time. Calling
<code>NegZFiniteDouble.apply</code> with a literal
<code>Double</code> value will either produce a valid
<code>NegZFiniteDouble</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegZFiniteDouble(-1.1)
res1: org.scalactic.anyvals.NegZFiniteDouble = NegZFiniteDouble(-1.1)

scala&gt; NegZFiniteDouble(1.1)
&lt;console&gt;:14: error: NegZFiniteDouble.apply can only be invoked on a finite non-positive (i <= 0.0 && i != Double.NegativeInfinity) floating point literal, like NegZFiniteDouble(-1.1).
              NegZFiniteDouble(1.1)
                       ^
</pre></p><p><code>NegZFiniteDouble.apply</code> cannot be used if the value
being passed is a variable (<em>i.e.</em>, not a literal),
because the macro cannot determine the validity of variables
at compile time (just literals). If you try to pass a
variable to <code>NegZFiniteDouble.apply</code>, you'll get a
compiler error that suggests you use a different factor
method, <code>NegZFiniteDouble.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = -1.1
x: Double = -1.1

scala&gt; NegZFiniteDouble(x)
&lt;console&gt;:15: error: NegZFiniteDouble.apply can only be invoked on a floating point literal, like NegZFiniteDouble(-1.1). Please use NegZFiniteDouble.from instead.
              NegZFiniteDouble(x)
                       ^
</pre></p><p>The <code>NegZFiniteDouble.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NegZFiniteDouble]</code>. If the value is valid,
<code>NegZFiniteDouble.from</code> will return a
<code>Some[NegZFiniteDouble]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NegZFiniteDouble.from(x)
res4: Option[org.scalactic.anyvals.NegZFiniteDouble] = Some(NegZFiniteDouble(-1.1))

scala&gt; val y = 1.1
y: Double = 1.1

scala&gt; NegZFiniteDouble.from(y)
res5: Option[org.scalactic.anyvals.NegZFiniteDouble] = None
</pre></p><p>The <code>NegZFiniteDouble.apply</code> factory method is marked
implicit, so that you can pass literal <code>Double</code>s
into methods that require <code>NegZFiniteDouble</code>, and get the
same compile-time checking you get when calling
<code>NegZFiniteDouble.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegZFiniteDouble): Double = Double.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegZFiniteDouble)Double

scala&gt; invert(1.1)
res6: Double = 1.7976931348623157E308

scala&gt; invert(Double.MaxValue)
res8: Double = 0.0

scala&gt; invert(1.1)
&lt;console&gt;:15: error: NegZFiniteDouble.apply can only be invoked on a finite non-positive (i <= 0.0 && i != Double.NegativeInfinity) floating point literal, like NegZFiniteDouble(-1.1).
              invert(1.1)
                     ^

</pre></p><p>This example also demonstrates that the
<code>NegZFiniteDouble</code> companion object also defines implicit
widening conversions when a similar conversion is provided in
Scala. This makes it convenient to use a
<code>NegZFiniteDouble</code> where a <code>Double</code> is
needed. An example is the subtraction in the body of the
<code>invert</code> method defined above,
<code>Double.MaxValue - pos</code>. Although
<code>Double.MaxValue</code> is a <code>Double</code>, which
has no <code>-</code> method that takes a
<code>NegZFiniteDouble</code> (the type of <code>pos</code>), you
can still subtract <code>pos</code>, because the
<code>NegZFiniteDouble</code> will be implicitly widened to
<code>Double</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegZFiniteFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegZFiniteFloatextendsAnyVal" class="anchorToMember"></a><a id="NegZFiniteFloat:NegZFiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZFiniteFloat.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegZFiniteFloat.html" title="An AnyVal for finite non-positive Floats."><span class="name">NegZFiniteFloat</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite non-positive <code>Float</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite non-positive <code>Float</code>s.</p><p>Because <code>NegZFiniteFloat</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Float</code>, being
boxed only when an <code>Float</code> would have been boxed.</p><p>The <code>NegZFiniteFloat.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>NegZFiniteFloat.apply</code> with a
literal <code>Float</code> value will either produce a valid
<code>NegZFiniteFloat</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegZFiniteFloat(-1.1fF)
res0: org.scalactic.anyvals.NegZFiniteFloat = NegZFiniteFloat(-1.1f)

scala&gt; NegZFiniteFloat(1.1fF)
&lt;console&gt;:14: error: NegZFiniteFloat.apply can only be invoked on a finite non-positive (i <= 0.0f && i != Float.NegativeInfinity) floating point literal, like NegZFiniteFloat(-1.1fF).
              NegZFiniteFloat(-1.1fF)
                      ^
</pre></p><p><code>NegZFiniteFloat.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>NegZFiniteFloat.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>NegZFiniteFloat.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = -1.1fF
x: Float = -1.1f

scala&gt; NegZFiniteFloat(x)
&lt;console&gt;:15: error: NegZFiniteFloat.apply can only be invoked on a floating point literal, like NegZFiniteFloat(-1.1fF). Please use NegZFiniteFloat.from instead.
              NegZFiniteFloat(x)
                      ^
</pre></p><p>The <code>NegZFiniteFloat.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NegZFiniteFloat]</code>. If the value is valid,
<code>NegZFiniteFloat.from</code> will return a
<code>Some[NegZFiniteFloat]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NegZFiniteFloat.from(x)
res3: Option[org.scalactic.anyvals.NegZFiniteFloat] = Some(NegZFiniteFloat(-1.1f))

scala&gt; val y = 1.1fF
y: Float = 1.1f

scala&gt; NegZFiniteFloat.from(y)
res4: Option[org.scalactic.anyvals.NegZFiniteFloat] = None
</pre></p><p>The <code>NegZFiniteFloat.apply</code> factory method is marked
implicit, so that you can pass literal <code>Float</code>s
into methods that require <code>NegZFiniteFloat</code>, and get the
same compile-time checking you get when calling
<code>NegZFiniteFloat.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegZFiniteFloat): Float = Float.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegZFiniteFloat)Float

scala&gt; invert(-1.1fF)
res5: Float = 3.4028235E38

scala&gt; invert(Float.MaxValue)
res6: Float = 0.0

scala&gt; invert(1.1fF)
&lt;console&gt;:15: error: NegZFiniteFloat.apply can only be invoked on a finite non-positive (i <= 0.0f && i != Float.NegativeInfinity) floating point literal, like NegZFiniteFloat(-1.1fF).
              invert(0.0F)
                     ^

scala&gt; invert(1.1fF)
&lt;console&gt;:15: error: NegZFiniteFloat.apply can only be invoked on a finite non-positive (i <= 0.0f && i != Float.NegativeInfinity) floating point literal, like NegZFiniteFloat(-1.1fF).
              invert(1.1fF)
                      ^

</pre></p><p>This example also demonstrates that the <code>NegZFiniteFloat</code>
companion object also defines implicit widening conversions
when no loss of precision will occur. This makes it convenient to use a
<code>NegZFiniteFloat</code> where a <code>Float</code> or wider
type is needed. An example is the subtraction in the body of
the <code>invert</code> method defined above,
<code>Float.MaxValue - pos</code>. Although
<code>Float.MaxValue</code> is a <code>Float</code>, which
has no <code>-</code> method that takes a
<code>NegZFiniteFloat</code> (the type of <code>pos</code>), you can
still subtract <code>pos</code>, because the
<code>NegZFiniteFloat</code> will be implicitly widened to
<code>Float</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegZFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegZFloatextendsAnyVal" class="anchorToMember"></a><a id="NegZFloat:NegZFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZFloat.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegZFloat.html" title="An AnyVal for non-positive Floats."><span class="name">NegZFloat</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-positive <code>Float</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-positive <code>Float</code>s.</p><p>Because <code>NegZFloat</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Float</code>, being
boxed only when an <code>Float</code> would have been boxed.</p><p>The <code>NegZFloat.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>NegZFloat.apply</code> with a
literal <code>Float</code> value will either produce a valid
<code>NegZFloat</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegZFloat(-1.1fF)
res0: org.scalactic.anyvals.NegZFloat = NegZFloat(-1.1f)

scala&gt; NegZFloat(1.1fF)
&lt;console&gt;:14: error: NegZFloat.apply can only be invoked on a non-positive (i <= 0.0f) floating point literal, like NegZFloat(-1.1fF).
              NegZFloat(-1.1fF)
                      ^
</pre></p><p><code>NegZFloat.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>NegZFloat.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>NegZFloat.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = -1.1fF
x: Float = -1.1f

scala&gt; NegZFloat(x)
&lt;console&gt;:15: error: NegZFloat.apply can only be invoked on a floating point literal, like NegZFloat(-1.1fF). Please use NegZFloat.from instead.
              NegZFloat(x)
                      ^
</pre></p><p>The <code>NegZFloat.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NegZFloat]</code>. If the value is valid,
<code>NegZFloat.from</code> will return a
<code>Some[NegZFloat]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NegZFloat.from(x)
res3: Option[org.scalactic.anyvals.NegZFloat] = Some(NegZFloat(-1.1f))

scala&gt; val y = 1.1fF
y: Float = 1.1f

scala&gt; NegZFloat.from(y)
res4: Option[org.scalactic.anyvals.NegZFloat] = None
</pre></p><p>The <code>NegZFloat.apply</code> factory method is marked
implicit, so that you can pass literal <code>Float</code>s
into methods that require <code>NegZFloat</code>, and get the
same compile-time checking you get when calling
<code>NegZFloat.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegZFloat): Float = Float.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegZFloat)Float

scala&gt; invert(-1.1fF)
res5: Float = 3.4028235E38

scala&gt; invert(Float.MaxValue)
res6: Float = 0.0

scala&gt; invert(1.1fF)
&lt;console&gt;:15: error: NegZFloat.apply can only be invoked on a non-positive (i <= 0.0f) floating point literal, like NegZFloat(-1.1fF).
              invert(0.0F)
                     ^

scala&gt; invert(1.1fF)
&lt;console&gt;:15: error: NegZFloat.apply can only be invoked on a non-positive (i <= 0.0f) floating point literal, like NegZFloat(-1.1fF).
              invert(1.1fF)
                      ^

</pre></p><p>This example also demonstrates that the <code>NegZFloat</code>
companion object also defines implicit widening conversions
when no loss of precision will occur. This makes it convenient to use a
<code>NegZFloat</code> where a <code>Float</code> or wider
type is needed. An example is the subtraction in the body of
the <code>invert</code> method defined above,
<code>Float.MaxValue - pos</code>. Although
<code>Float.MaxValue</code> is a <code>Float</code>, which
has no <code>-</code> method that takes a
<code>NegZFloat</code> (the type of <code>pos</code>), you can
still subtract <code>pos</code>, because the
<code>NegZFloat</code> will be implicitly widened to
<code>Float</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegZInt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegZIntextendsAnyVal" class="anchorToMember"></a><a id="NegZInt:NegZInt" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZInt.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegZInt.html" title="An AnyVal for non-positive Ints."><span class="name">NegZInt</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-positive <code>Int</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-positive <code>Int</code>s.</p><p>Because <code>NegZInt</code> is an <code>AnyVal</code> it will usually be
as efficient as an <code>Int</code>, being boxed only when an <code>Int</code>
would have been boxed.</p><p>The <code>NegZInt.apply</code> factory method is implemented in terms of a macro that
checks literals for validity at compile time. Calling <code>NegZInt.apply</code> with
a literal <code>Int</code> value will either produce a valid <code>NegZInt</code> instance
at run time or an error at compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegZInt(-42)
res0: org.scalactic.anyvals.NegZInt = NegZInt(-42)

scala&gt; NegZInt(1)
&lt;console&gt;:14: error: NegZInt.apply can only be invoked on a non-positive (i <= 0) literal, like NegZInt(-42).
              NegZInt(1)
                    ^
</pre></p><p><code>NegZInt.apply</code> cannot be used if the value being passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at compile time (just literals). If you try to pass a variable
to <code>NegZInt.apply</code>, you'll get a compiler error that suggests you use a different factor method,
<code>NegZInt.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1
x: Int = 1

scala&gt; NegZInt(x)
&lt;console&gt;:15: error: NegZInt.apply can only be invoked on a non-positive integer literal, like NegZInt(-42). Please use NegZInt.from instead.
              NegZInt(x)
                    ^
</pre></p><p>The <code>NegZInt.from</code> factory method will inspect the value at runtime and return an <code>Option[NegZInt]</code>. If
the value is valid, <code>NegZInt.from</code> will return a <code>Some[NegZInt]</code>, else it will return a <code>None</code>.
Here's an example:</p><p><pre class="stREPL">
scala&gt; NegZInt.from(x)
res3: Option[org.scalactic.anyvals.NegZInt] = Some(NegZInt(1))

scala&gt; val y = 0
y: Int = 0

scala&gt; NegZInt.from(y)
res4: Option[org.scalactic.anyvals.NegZInt] = None
</pre></p><p>The <code>NegZInt.apply</code> factory method is marked implicit, so that you can pass literal <code>Int</code>s
into methods that require <code>NegZInt</code>, and get the same compile-time checking you get when calling
<code>NegZInt.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegZInt): Int = Int.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegZInt)Int

scala&gt; invert(1)
res0: Int = 2147483646

scala&gt; invert(Int.MaxValue)
res1: Int = 0

scala&gt; invert(0)
&lt;console&gt;:15: error: NegZInt.apply can only be invoked on a non-positive (i <= 0) integer literal, like NegZInt(-42).
              invert(0)
                     ^

scala&gt; invert(-1)
&lt;console&gt;:15: error: NegZInt.apply can only be invoked on a non-positive (i <= 0) integer literal, like NegZInt(-42).
              invert(-1)
                      ^

</pre></p><p>This example also demonstrates that the <code>NegZInt</code> companion object also defines implicit widening conversions
when either no loss of precision will occur or a similar conversion is provided in Scala. (For example, the implicit
conversion from <code>Int</code> to </code>Float</code> in Scala can lose precision.) This makes it convenient to
use a <code>NegZInt</code> where an <code>Int</code> or wider type is needed. An example is the subtraction in the body
of the <code>invert</code> method defined above, <code>Int.MaxValue - pos</code>. Although <code>Int.MaxValue</code> is
an <code>Int</code>, which has no <code>-</code> method that takes a <code>NegZInt</code> (the type of <code>pos</code>),
you can still subtract <code>pos</code>, because the <code>NegZInt</code> will be implicitly widened to <code>Int</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NegZLong" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NegZLongextendsAnyVal" class="anchorToMember"></a><a id="NegZLong:NegZLong" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZLong.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NegZLong.html" title="An AnyVal for non-positive Longs."><span class="name">NegZLong</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-positive <code>Long</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-positive <code>Long</code>s.</p><p>Because <code>NegZLong</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Long</code>, being
boxed only when an <code>Long</code> would have been boxed.</p><p>The <code>NegZLong.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>NegZLong.apply</code> with a
literal <code>Long</code> value will either produce a valid
<code>NegZLong</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NegZLong(-42L)
res0: org.scalactic.anyvals.NegZLong = NegZLong(-42L)

scala&gt; NegZLong(-1L)
&lt;console&gt;:14: error: NegZLong.apply can only be invoked on a non-positive (i <= 0L) integer literal, like NegZLong(-42L).
              NegZLong(-1L)
                     ^
</pre></p><p><code>NegZLong.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>NegZLong.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>NegZLong.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = -42L
x: Long = -42

scala&gt; NegZLong(x)
&lt;console&gt;:15: error: NegZLong.apply can only be invoked on an long literal, like NegZLong(-42L). Please use NegZLong.from instead.
              NegZLong(x)
                     ^
</pre></p><p>The <code>NegZLong.from</code> factory method will inspect the
value at runtime and return an
<code>Option[NegZLong]</code>. If the value is valid,
<code>NegZLong.from</code> will return a
<code>Some[NegZLong]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NegZLong.from(x)
res3: Option[org.scalactic.anyvals.NegZLong] = Some(NegZLong(-42))

scala&gt; val y = 1L
y: Long = 1

scala&gt; NegZLong.from(y)
res4: Option[org.scalactic.anyvals.NegZLong] = None
</pre></p><p>The <code>NegZLong.apply</code> factory method is marked
implicit, so that you can pass literal <code>Long</code>s
into methods that require <code>NegZLong</code>, and get the
same compile-time checking you get when calling
<code>NegZLong.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NegZLong): Long = Long.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NegZLong)Long

scala&gt; invert(1L)
res5: Long = 9223372036854775806

scala&gt; invert(Long.MaxValue)
res6: Long = 0

scala&gt; invert(1L)
&lt;console&gt;:15: error: NegZLong.apply can only be invoked on a non-positive (i <= 0L) integer literal, like NegZLong(-42L).
              invert(1L)
                     ^

</pre></p><p>This example also demonstrates that the <code>NegZLong</code>
companion object also defines implicit widening conversions
when either no loss of precision will occur or a similar
conversion is provided in Scala. (For example, the implicit
conversion from <code>Long</code> to </code>Double</code> in
Scala can lose precision.) This makes it convenient to use a
<code>NegZLong</code> where a <code>Long</code> or wider type
is needed. An example is the subtraction in the body of the
<code>invert</code> method defined above, <code>Long.MaxValue
- pos</code>. Although <code>Long.MaxValue</code> is a
<code>Long</code>, which has no <code>-</code> method that
takes a <code>NegZLong</code> (the type of <code>pos</code>),
you can still subtract <code>pos</code>, because the
<code>NegZLong</code> will be implicitly widened to
<code>Long</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptyArray" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonEmptyArray[T]extendsAnyVal" class="anchorToMember"></a><a id="NonEmptyArray[T]:NonEmptyArray[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptyArray.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonEmptyArray.html" title="A non-empty array: an ordered, mutable, non-empty collection of elements with IndexedSeq performance characteristics."><span class="name">NonEmptyArray</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">A non-empty array: an ordered, mutable, non-empty collection of elements with <code>IndexedSeq</code> performance characteristics.</p><div class="fullcomment"><div class="comment cmt"><p>A non-empty array: an ordered, mutable, non-empty collection of elements with <code>IndexedSeq</code> performance characteristics.</p><p>The purpose of <code>NonEmptyArray</code> is to allow you to express in a type that an <code>Array</code> is non-empty, thereby eliminating the
need for (and potential exception from) a run-time check for non-emptiness. For a non-empty immutable sequence with <code>IndexedSeq</code>
performance, see <a href="Every.html"><code>Every</code></a>.</p><h4> Constructing <code>NonEmptyArray</code>s </h4><p>You can construct a <code>NonEmptyArray</code> by passing one or more elements to the <code>NonEmptyArray.apply</code> factory method:</p><p><pre class="stHighlighted">
scala&gt; <span class="stType">NonEmptyArray</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
res0: <span class="stType">org.scalactic.anyvals.NonEmptyArray[Int]</span> = <span class="stType">NonEmptyArray</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><h4> Working with <code>NonEmptyArray</code>s </h4><p><code>NonEmptyArray</code> does not extend Scala's <code>Seq</code> or <code>Traversable</code> traits because these require that
implementations may be empty. For example, if you invoke <code>tail</code> on a <code>Seq</code> that contains just one element,
you'll get an empty <code>Seq</code>:</p><p><pre class="stREPL">
scala&gt; Array(1).tail
res6: Array[Int] = Array()
</pre></p><p>On the other hand, many useful methods exist on <code>Seq</code> that when invoked on a non-empty <code>Seq</code> are guaranteed
to not result in an empty <code>Seq</code>. For convenience, <code>NonEmptyArray</code> defines a method corresponding to every such <code>Seq</code>
method. Here are some examples:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptyArray</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).map(_ + <span class="stLiteral">1</span>)                        <span class="stLineComment">// Result: NonEmptyArray(2, 3, 4)</span>
<span class="stType">NonEmptyArray</span>(<span class="stLiteral">1</span>).map(_ + <span class="stLiteral">1</span>)                              <span class="stLineComment">// Result: NonEmptyArray(2)</span>
<span class="stType">NonEmptyArray</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).containsSlice(<span class="stType">NonEmptyArray</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>)) <span class="stLineComment">// Result: true</span>
<span class="stType">NonEmptyArray</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).containsSlice(<span class="stType">NonEmptyArray</span>(<span class="stLiteral">3</span>, <span class="stLiteral">4</span>)) <span class="stLineComment">// Result: false</span>
<span class="stType">NonEmptyArray</span>(-<span class="stLiteral">1</span>, -<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>).minBy(_.abs)              <span class="stLineComment">// Result: -1</span>
</pre></p><p><code>NonEmptyArray</code> does <em>not</em> currently define any methods corresponding to <code>Seq</code> methods that could result in
an empty <code>Seq</code>. However, an implicit converison from <code>NonEmptyArray</code> to <code>Array</code>
is defined in the <code>NonEmptyArray</code> companion object that will be applied if you attempt to call one of the missing methods. As a
result, you can invoke <code>filter</code> on an <code>NonEmptyArray</code>, even though <code>filter</code> could result
in an empty sequence&mdash;but the result type will be <code>Array</code> instead of <code>NonEmptyArray</code>:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptyArray</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).filter(_ &lt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: Array(1, 2, 3)</span>
<span class="stType">NonEmptyArray</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).filter(_ &gt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: Array()</span>
</pre></p><p>You can use <code>NonEmptyArray</code>s in <code>for</code> expressions. The result will be an <code>NonEmptyArray</code> unless
you use a filter (an <code>if</code> clause). Because filters are desugared to invocations of <code>filter</code>, the
result type will switch to a <code>Array</code> at that point. Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalactic.anyvals._
import org.scalactic.anyvals._

scala&gt; for (i &lt;- NonEmptyArray(1, 2, 3)) yield i + 1
res0: org.scalactic.anyvals.NonEmptyArray[Int] = NonEmptyArray(2, 3, 4)

scala&gt; for (i &lt;- NonEmptyArray(1, 2, 3) if i &lt; 10) yield i + 1
res1: Array[Int] = Array(2, 3, 4)

scala&gt; for {
     |   i &lt;- NonEmptyArray(1, 2, 3)
     |   j &lt;- NonEmptyArray('a', 'b', 'c')
     | } yield (i, j)
res3: org.scalactic.anyvals.NonEmptyArray[(Int, Char)] =
        NonEmptyArray((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))

scala&gt; for {
     |   i &lt;- NonEmptyArray(1, 2, 3) if i &lt; 10
     |   j &lt;- NonEmptyArray('a', 'b', 'c')
     | } yield (i, j)
res6: Array[(Int, Char)] =
        Array((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))
</pre>
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the type of elements contained in this <code>NonEmptyArray</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptyList" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonEmptyList[+T]extendsAnyVal" class="anchorToMember"></a><a id="NonEmptyList[+T]:NonEmptyList[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptyList.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonEmptyList.html" title="A non-empty list: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics."><span class="name">NonEmptyList</span></a><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">A non-empty list: an ordered, immutable, non-empty collection of elements with <code>LinearSeq</code> performance characteristics.</p><div class="fullcomment"><div class="comment cmt"><p>A non-empty list: an ordered, immutable, non-empty collection of elements with <code>LinearSeq</code> performance characteristics.</p><p>The purpose of <code>NonEmptyList</code> is to allow you to express in a type that a <code>List</code> is non-empty, thereby eliminating the
need for (and potential exception from) a run-time check for non-emptiness. For a non-empty sequence with <code>IndexedSeq</code>
performance, see <a href="Every.html"><code>Every</code></a>.</p><h4> Constructing <code>NonEmptyList</code>s </h4><p>You can construct a <code>NonEmptyList</code> by passing one or more elements to the <code>NonEmptyList.apply</code> factory method:</p><p><pre class="stHighlighted">
scala&gt; <span class="stType">NonEmptyList</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
res0: <span class="stType">org.scalactic.anyvals.NonEmptyList[Int]</span> = <span class="stType">NonEmptyList</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>Alternatively you can <em>cons</em> elements onto the <code>End</code> singleton object, similar to making a <code>List</code> starting with <code>Nil</code>:</p><p><pre class="stHighlighted">
scala&gt; <span class="stLiteral">1</span> :: <span class="stLiteral">2</span> :: <span class="stLiteral">3</span> :: <span class="stType">Nil</span>
res0: <span class="stType">List[Int]</span> = <span class="stType">List</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
<br/>scala&gt; <span class="stLiteral">1</span> :: <span class="stLiteral">2</span> :: <span class="stLiteral">3</span> :: <span class="stType">End</span>
res1: <span class="stType">org.scalactic.NonEmptyList[Int]</span> = <span class="stType">NonEmptyList</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>Note that although <code>Nil</code> is a <code>List[Nothing]</code>, <code>End</code> is
not a <code>NonEmptyList[Nothing]</code>, because no empty <code>NonEmptyList</code> exists. (A non-empty list is a series
of connected links; if you have no links, you have no non-empty list.)</p><p><pre class="stHighlighted">
scala&gt; <span class="stReserved">val</span> nil: <span class="stType">List[Nothing]</span> = <span class="stType">Nil</span>
nil: <span class="stType">List[Nothing]</span> = <span class="stType">List</span>()
<br/>scala&gt; <span class="stReserved">val</span> nada: <span class="stType">NonEmptyList[Nothing]</span> = <span class="stType">End</span>
&lt;console&gt;:<span class="stLiteral">16</span>: error: <span class="stReserved">type</span> mismatch;
found   : org.scalactic.anyvals.End.type
required: <span class="stType">org.scalactic.anyvals.NonEmptyList[Nothing]</span>
       <span class="stReserved">val</span> nada: <span class="stType">NonEmptyList[Nothing]</span> = <span class="stType">End</span>
                                         ^
</pre></p><h4> Working with <code>NonEmptyList</code>s </h4><p><code>NonEmptyList</code> does not extend Scala's <code>Seq</code> or <code>Traversable</code> traits because these require that
implementations may be empty. For example, if you invoke <code>tail</code> on a <code>Seq</code> that contains just one element,
you'll get an empty <code>Seq</code>:</p><p><pre class="stREPL">
scala&gt; List(1).tail
res6: List[Int] = List()
</pre></p><p>On the other hand, many useful methods exist on <code>Seq</code> that when invoked on a non-empty <code>Seq</code> are guaranteed
to not result in an empty <code>Seq</code>. For convenience, <code>NonEmptyList</code> defines a method corresponding to every such <code>Seq</code>
method. Here are some examples:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptyList</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).map(_ + <span class="stLiteral">1</span>)                        <span class="stLineComment">// Result: NonEmptyList(2, 3, 4)</span>
<span class="stType">NonEmptyList</span>(<span class="stLiteral">1</span>).map(_ + <span class="stLiteral">1</span>)                              <span class="stLineComment">// Result: NonEmptyList(2)</span>
<span class="stType">NonEmptyList</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).containsSlice(<span class="stType">NonEmptyList</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>)) <span class="stLineComment">// Result: true</span>
<span class="stType">NonEmptyList</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).containsSlice(<span class="stType">NonEmptyList</span>(<span class="stLiteral">3</span>, <span class="stLiteral">4</span>)) <span class="stLineComment">// Result: false</span>
<span class="stType">NonEmptyList</span>(-<span class="stLiteral">1</span>, -<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>).minBy(_.abs)              <span class="stLineComment">// Result: -1</span>
</pre></p><p><code>NonEmptyList</code> does <em>not</em> currently define any methods corresponding to <code>Seq</code> methods that could result in
an empty <code>Seq</code>. However, an implicit converison from <code>NonEmptyList</code> to <code>List</code>
is defined in the <code>NonEmptyList</code> companion object that will be applied if you attempt to call one of the missing methods. As a
result, you can invoke <code>filter</code> on an <code>NonEmptyList</code>, even though <code>filter</code> could result
in an empty sequence&mdash;but the result type will be <code>List</code> instead of <code>NonEmptyList</code>:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptyList</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).filter(_ &lt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: List(1, 2, 3)</span>
<span class="stType">NonEmptyList</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).filter(_ &gt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: List()</span>
</pre></p><p>You can use <code>NonEmptyList</code>s in <code>for</code> expressions. The result will be an <code>NonEmptyList</code> unless
you use a filter (an <code>if</code> clause). Because filters are desugared to invocations of <code>filter</code>, the
result type will switch to a <code>List</code> at that point. Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalactic.anyvals._
import org.scalactic.anyvals._

scala&gt; for (i &lt;- NonEmptyList(1, 2, 3)) yield i + 1
res0: org.scalactic.anyvals.NonEmptyList[Int] = NonEmptyList(2, 3, 4)

scala&gt; for (i &lt;- NonEmptyList(1, 2, 3) if i &lt; 10) yield i + 1
res1: List[Int] = List(2, 3, 4)

scala&gt; for {
     |   i &lt;- NonEmptyList(1, 2, 3)
     |   j &lt;- NonEmptyList('a', 'b', 'c')
     | } yield (i, j)
res3: org.scalactic.anyvals.NonEmptyList[(Int, Char)] =
        NonEmptyList((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))

scala&gt; for {
     |   i &lt;- NonEmptyList(1, 2, 3) if i &lt; 10
     |   j &lt;- NonEmptyList('a', 'b', 'c')
     | } yield (i, j)
res6: List[(Int, Char)] =
        List((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))
</pre>
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the type of elements contained in this <code>NonEmptyList</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptyMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonEmptyMap[K,+V]extendsAnyVal" class="anchorToMember"></a><a id="NonEmptyMap[K,+V]:NonEmptyMap[K,V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptyMap.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonEmptyMap.html" title="A non-empty map: an ordered, immutable, non-empty collection of key-value tuples with LinearSeq performance characteristics."><span class="name">NonEmptyMap</span></a><span class="tparams">[<span name="K">K</span>, <span name="V">+V</span>]</span><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">A non-empty map: an ordered, immutable, non-empty collection of key-value tuples with <code>LinearSeq</code> performance characteristics.</p><div class="fullcomment"><div class="comment cmt"><p>A non-empty map: an ordered, immutable, non-empty collection of key-value tuples with <code>LinearSeq</code> performance characteristics.</p><p>The purpose of <code>NonEmptyMap</code> is to allow you to express in a type that a <code>Map</code> is non-empty, thereby eliminating the
need for (and potential exception from) a run-time check for non-emptiness. For a non-empty sequence with <code>IndexedSeq</code>
performance, see <a href="Every.html"><code>Every</code></a>.</p><h4> Constructing <code>NonEmptyMap</code>s </h4><p>You can construct a <code>NonEmptyMap</code> by passing one or more elements to the <code>NonEmptyMap.apply</code> factory method:</p><p><pre class="stHighlighted">
scala&gt; <span class="stType">NonEmptyMap</span>(<span class="stLiteral">1</span> -> <span class="stQuotedString">"one"</span>, <span class="stLiteral">2</span> -> <span class="stQuotedString">"two"</span>, <span class="stLiteral">3</span> -> <span class="stQuotedString">"three"</span>)
res0: <span class="stType">org.scalactic.anyvals.NonEmptyMap[Int, String]</span> = <span class="stType">NonEmptyMap</span>(<span class="stLiteral">1</span> -> <span class="stQuotedString">"one"</span>, <span class="stLiteral">2</span> -> <span class="stQuotedString">"two"</span>, <span class="stLiteral">3</span> -> <span class="stQuotedString">"three"</span>)
</pre></p><h4> Working with <code>NonEmptyMap</code>s </h4><p><code>NonEmptyMap</code> does not extend Scala's <code>Map</code> or <code>Traversable</code> traits because these require that
implementations may be empty. For example, if you invoke <code>tail</code> on a <code>Seq</code> that contains just one element,
you'll get an empty <code>Seq</code>:</p><p><pre class="stREPL">
scala&gt; Map(1 -> "one").tail
res6: Map[Int] = Map()
</pre></p><p>On the other hand, many useful methods exist on <code>Map</code> that when invoked on a non-empty <code>Seq</code> are guaranteed
to not result in an empty <code>Map</code>. For convenience, <code>NonEmptyMap</code> defines a method corresponding to every such <code>Map</code>
method. Here are an example:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptyMap</span>(<span class="stLiteral">1</span> -> <span class="stQuotedString">"one"</span>, <span class="stLiteral">2</span> -> <span class="stQuotedString">"two"</span>, <span class="stLiteral">3</span> -> <span class="stQuotedString">"three"</span>).map(t => (t._1 + <span class="stLiteral">1</span>, t._2))                        <span class="stLineComment">// Result: NonEmptyMap(2 -> "one", 3 -> "two", 4 -> "three")</span>
</pre></p><p><code>NonEmptyMap</code> does <em>not</em> currently define any methods corresponding to <code>Map</code> methods that could result in
an empty <code>Map</code>. However, an implicit converison from <code>NonEmptyMap</code> to <code>Map</code>
is defined in the <code>NonEmptyMap</code> companion object that will be applied if you attempt to call one of the missing methods. As a
result, you can invoke <code>filter</code> on an <code>NonEmptyMap</code>, even though <code>filter</code> could result
in an empty map&mdash;but the result type will be <code>Map</code> instead of <code>NonEmptyMap</code>:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptyMap</span>(<span class="stLiteral">1</span> -> <span class="stQuotedString">"one"</span>, <span class="stLiteral">2</span> -> <span class="stQuotedString">"two"</span>, <span class="stLiteral">3</span> -> <span class="stQuotedString">"three"</span>).filter(_._1 &lt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: Map(1 -> "one", 2 -> "two", 3 -> "three")</span>
<span class="stType">NonEmptyMap</span>(<span class="stLiteral">1</span> -> <span class="stQuotedString">"one"</span>, <span class="stLiteral">2</span> -> <span class="stQuotedString">"two"</span>, <span class="stLiteral">3</span> -> <span class="stQuotedString">"three"</span>).filter(_._ <span class="stLiteral">1</span>&gt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: Map()</span>
</pre></p><p>You can use <code>NonEmptyMap</code>s in <code>for</code> expressions. The result will be an <code>NonEmptyMap</code> unless
you use a filter (an <code>if</code> clause). Because filters are desugared to invocations of <code>filter</code>, the
result type will switch to a <code>Map</code> at that point. Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalactic.anyvals._
import org.scalactic.anyvals._

scala&gt; for ((i, j) &lt;- NonEmptyMap(1 -> "one", 2 -> "two", 3 -> "three")) yield (i + 1, j)
res0: org.scalactic.anyvals.NonEmptyMap[Int, String] = NonEmptyMap(2 -> "one", 3 -> "two", 4 -> "three")

scala&gt; for ((i, j) &lt;- NonEmptyMap(1, 2, 3) if i &lt; 10) yield (i + 1, j)
res1: Map[Int, String] = Map(2 -> "one", 3 -> "two", 4 -> "three")
</pre>
</p></div><dl class="paramcmts block"><dt class="tparam">K</dt><dd class="cmt"><p>the type of key contained in this <code>NonEmptyMap</code></p></dd><dt class="tparam">V</dt><dd class="cmt"><p>the type of value contained in this <code>NonEmptyMap</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptySet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonEmptySet[T]extendsAnyVal" class="anchorToMember"></a><a id="NonEmptySet[T]:NonEmptySet[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptySet.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonEmptySet.html" title="A non-empty Set: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics."><span class="name">NonEmptySet</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">A non-empty Set: an ordered, immutable, non-empty collection of elements with <code>LinearSeq</code> performance characteristics.</p><div class="fullcomment"><div class="comment cmt"><p>A non-empty Set: an ordered, immutable, non-empty collection of elements with <code>LinearSeq</code> performance characteristics.</p><p>The purpose of <code>NonEmptySet</code> is to allow you to express in a type that a <code>Set</code> is non-empty, thereby eliminating the
need for (and potential exception from) a run-time check for non-emptiness. For a non-empty sequence with <code>IndexedSeq</code>
performance, see <a href="Every.html"><code>Every</code></a>.</p><h4> Constructing <code>NonEmptySet</code>s </h4><p>You can construct a <code>NonEmptySet</code> by passing one or more elements to the <code>NonEmptySet.apply</code> factory method:</p><p><pre class="stHighlighted">
scala&gt; <span class="stType">NonEmptySet</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
res0: <span class="stType">org.scalactic.anyvals.NonEmptySet[Int]</span> = <span class="stType">NonEmptySet</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>Alternatively you can <em>cons</em> elements onto the <code>End</code> singleton object, similar to making a <code>Set</code> starting with <code>Nil</code>:</p><p><pre class="stHighlighted">
scala&gt; <span class="stLiteral">1</span> :: <span class="stLiteral">2</span> :: <span class="stLiteral">3</span> :: <span class="stType">Nil</span>
res0: <span class="stType">Set[Int]</span> = <span class="stType">Set</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
<br/>scala&gt; <span class="stLiteral">1</span> :: <span class="stLiteral">2</span> :: <span class="stLiteral">3</span> :: <span class="stType">End</span>
res1: <span class="stType">org.scalactic.NonEmptySet[Int]</span> = <span class="stType">NonEmptySet</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>Note that although <code>Nil</code> is a <code>Set[Nothing]</code>, <code>End</code> is
not a <code>NonEmptySet[Nothing]</code>, because no empty <code>NonEmptySet</code> exists. (A non-empty Set is a series
of connected links; if you have no links, you have no non-empty Set.)</p><p><pre class="stHighlighted">
scala&gt; <span class="stReserved">val</span> nil: <span class="stType">Set[Nothing]</span> = <span class="stType">Nil</span>
nil: <span class="stType">Set[Nothing]</span> = <span class="stType">Set</span>()
<br/>scala&gt; <span class="stReserved">val</span> nada: <span class="stType">NonEmptySet[Nothing]</span> = <span class="stType">End</span>
&lt;console&gt;:<span class="stLiteral">16</span>: error: <span class="stReserved">type</span> mismatch;
found   : org.scalactic.anyvals.End.type
required: <span class="stType">org.scalactic.anyvals.NonEmptySet[Nothing]</span>
       <span class="stReserved">val</span> nada: <span class="stType">NonEmptySet[Nothing]</span> = <span class="stType">End</span>
                                         ^
</pre></p><h4> Working with <code>NonEmptySet</code>s </h4><p><code>NonEmptySet</code> does not extend Scala's <code>Seq</code> or <code>Traversable</code> traits because these require that
implementations may be empty. For example, if you invoke <code>tail</code> on a <code>Seq</code> that contains just one element,
you'll get an empty <code>Seq</code>:</p><p><pre class="stREPL">
scala&gt; Set(1).tail
res6: Set[Int] = Set()
</pre></p><p>On the other hand, many useful methods exist on <code>Seq</code> that when invoked on a non-empty <code>Seq</code> are guaranteed
to not result in an empty <code>Seq</code>. For convenience, <code>NonEmptySet</code> defines a method corresponding to every such <code>Seq</code>
method. Here are some examples:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptySet</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).map(_ + <span class="stLiteral">1</span>)                        <span class="stLineComment">// Result: NonEmptySet(2, 3, 4)</span>
<span class="stType">NonEmptySet</span>(<span class="stLiteral">1</span>).map(_ + <span class="stLiteral">1</span>)                              <span class="stLineComment">// Result: NonEmptySet(2)</span>
<span class="stType">NonEmptySet</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).containsSlice(<span class="stType">NonEmptySet</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>)) <span class="stLineComment">// Result: true</span>
<span class="stType">NonEmptySet</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).containsSlice(<span class="stType">NonEmptySet</span>(<span class="stLiteral">3</span>, <span class="stLiteral">4</span>)) <span class="stLineComment">// Result: false</span>
<span class="stType">NonEmptySet</span>(-<span class="stLiteral">1</span>, -<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>).minBy(_.abs)              <span class="stLineComment">// Result: -1</span>
</pre></p><p><code>NonEmptySet</code> does <em>not</em> currently define any methods corresponding to <code>Seq</code> methods that could result in
an empty <code>Seq</code>. However, an implicit converison from <code>NonEmptySet</code> to <code>Set</code>
is defined in the <code>NonEmptySet</code> companion object that will be applied if you attempt to call one of the missing methods. As a
result, you can invoke <code>filter</code> on an <code>NonEmptySet</code>, even though <code>filter</code> could result
in an empty sequence&mdash;but the result type will be <code>Set</code> instead of <code>NonEmptySet</code>:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptySet</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).filter(_ &lt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: Set(1, 2, 3)</span>
<span class="stType">NonEmptySet</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).filter(_ &gt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: Set()</span>
</pre></p><p>You can use <code>NonEmptySet</code>s in <code>for</code> expressions. The result will be an <code>NonEmptySet</code> unless
you use a filter (an <code>if</code> clause). Because filters are desugared to invocations of <code>filter</code>, the
result type will switch to a <code>Set</code> at that point. Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalactic.anyvals._
import org.scalactic.anyvals._

scala&gt; for (i &lt;- NonEmptySet(1, 2, 3)) yield i + 1
res0: org.scalactic.anyvals.NonEmptySet[Int] = NonEmptySet(2, 3, 4)

scala&gt; for (i &lt;- NonEmptySet(1, 2, 3) if i &lt; 10) yield i + 1
res1: Set[Int] = Set(2, 3, 4)

scala&gt; for {
     |   i &lt;- NonEmptySet(1, 2, 3)
     |   j &lt;- NonEmptySet('a', 'b', 'c')
     | } yield (i, j)
res3: org.scalactic.anyvals.NonEmptySet[(Int, Char)] =
        NonEmptySet((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))

scala&gt; for {
     |   i &lt;- NonEmptySet(1, 2, 3) if i &lt; 10
     |   j &lt;- NonEmptySet('a', 'b', 'c')
     | } yield (i, j)
res6: Set[(Int, Char)] =
        Set((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))
</pre>
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the type of elements contained in this <code>NonEmptySet</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptyString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonEmptyStringextendsAnyVal" class="anchorToMember"></a><a id="NonEmptyString:NonEmptyString" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptyString.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonEmptyString.html" title="A non-empty list: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics."><span class="name">NonEmptyString</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">A non-empty list: an ordered, immutable, non-empty collection of elements with <code>LinearSeq</code> performance characteristics.</p><div class="fullcomment"><div class="comment cmt"><p>A non-empty list: an ordered, immutable, non-empty collection of elements with <code>LinearSeq</code> performance characteristics.</p><p>The purpose of <code>NonEmptyString</code> is to allow you to express in a type that a <code>String</code> is non-empty, thereby eliminating the
need for (and potential exception from) a run-time check for non-emptiness. For a non-empty sequence with <code>IndexedSeq</code>
performance, see <a href="Every.html"><code>Every</code></a>.</p><h4> Constructing <code>NonEmptyString</code>s </h4><p>You can construct a <code>NonEmptyString</code> by passing one or more elements to the <code>NonEmptyString.apply</code> factory method:</p><p><pre class="stHighlighted">
scala&gt; <span class="stType">NonEmptyString</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
res0: <span class="stType">org.scalactic.anyvals.NonEmptyString[Int]</span> = <span class="stType">NonEmptyString</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>Alternatively you can <em>cons</em> elements onto the <code>End</code> singleton object, similar to making a <code>String</code> starting with <code>Nil</code>:</p><p><pre class="stHighlighted">
scala&gt; <span class="stLiteral">1</span> :: <span class="stLiteral">2</span> :: <span class="stLiteral">3</span> :: <span class="stType">Nil</span>
res0: <span class="stType">String[Int]</span> = <span class="stType">String</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
<br/>scala&gt; <span class="stLiteral">1</span> :: <span class="stLiteral">2</span> :: <span class="stLiteral">3</span> :: <span class="stType">End</span>
res1: <span class="stType">org.scalactic.NonEmptyString[Int]</span> = <span class="stType">NonEmptyString</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>Note that although <code>Nil</code> is a <code>String[Nothing]</code>, <code>End</code> is
not a <code>NonEmptyString[Nothing]</code>, because no empty <code>NonEmptyString</code> exists. (A non-empty list is a series
of connected links; if you have no links, you have no non-empty list.)</p><p><pre class="stHighlighted">
scala&gt; <span class="stReserved">val</span> nil: <span class="stType">String[Nothing]</span> = <span class="stType">Nil</span>
nil: <span class="stType">String[Nothing]</span> = <span class="stType">String</span>()
<br/>scala&gt; <span class="stReserved">val</span> nada: <span class="stType">NonEmptyString[Nothing]</span> = <span class="stType">End</span>
&lt;console&gt;:<span class="stLiteral">16</span>: error: <span class="stReserved">type</span> mismatch;
found   : org.scalactic.anyvals.End.type
required: <span class="stType">org.scalactic.anyvals.NonEmptyString[Nothing]</span>
       <span class="stReserved">val</span> nada: <span class="stType">NonEmptyString[Nothing]</span> = <span class="stType">End</span>
                                         ^
</pre></p><h4> Working with <code>NonEmptyString</code>s </h4><p><code>NonEmptyString</code> does not extend Scala's <code>Seq</code> or <code>Traversable</code> traits because these require that
implementations may be empty. For example, if you invoke <code>tail</code> on a <code>Seq</code> that contains just one element,
you'll get an empty <code>Seq</code>:</p><p><pre class="stREPL">
scala&gt; String(1).tail
res6: String[Int] = String()
</pre></p><p>On the other hand, many useful methods exist on <code>Seq</code> that when invoked on a non-empty <code>Seq</code> are guaranteed
to not result in an empty <code>Seq</code>. For convenience, <code>NonEmptyString</code> defines a method corresponding to every such <code>Seq</code>
method. Here are some examples:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptyString</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).map(_ + <span class="stLiteral">1</span>)                        <span class="stLineComment">// Result: NonEmptyString(2, 3, 4)</span>
<span class="stType">NonEmptyString</span>(<span class="stLiteral">1</span>).map(_ + <span class="stLiteral">1</span>)                              <span class="stLineComment">// Result: NonEmptyString(2)</span>
<span class="stType">NonEmptyString</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).containsSlice(<span class="stType">NonEmptyString</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>)) <span class="stLineComment">// Result: true</span>
<span class="stType">NonEmptyString</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).containsSlice(<span class="stType">NonEmptyString</span>(<span class="stLiteral">3</span>, <span class="stLiteral">4</span>)) <span class="stLineComment">// Result: false</span>
<span class="stType">NonEmptyString</span>(-<span class="stLiteral">1</span>, -<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>).minBy(_.abs)              <span class="stLineComment">// Result: -1</span>
</pre></p><p><code>NonEmptyString</code> does <em>not</em> currently define any methods corresponding to <code>Seq</code> methods that could result in
an empty <code>Seq</code>. However, an implicit converison from <code>NonEmptyString</code> to <code>String</code>
is defined in the <code>NonEmptyString</code> companion object that will be applied if you attempt to call one of the missing methods. As a
result, you can invoke <code>filter</code> on an <code>NonEmptyString</code>, even though <code>filter</code> could result
in an empty sequence&mdash;but the result type will be <code>String</code> instead of <code>NonEmptyString</code>:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptyString</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).filter(_ &lt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: String(1, 2, 3)</span>
<span class="stType">NonEmptyString</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).filter(_ &gt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: String()</span>
</pre></p><p>You can use <code>NonEmptyString</code>s in <code>for</code> expressions. The result will be an <code>NonEmptyString</code> unless
you use a filter (an <code>if</code> clause). Because filters are desugared to invocations of <code>filter</code>, the
result type will switch to a <code>String</code> at that point. Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalactic.anyvals._
import org.scalactic.anyvals._

scala&gt; for (i &lt;- NonEmptyString(1, 2, 3)) yield i + 1
res0: org.scalactic.anyvals.NonEmptyString[Int] = NonEmptyString(2, 3, 4)

scala&gt; for (i &lt;- NonEmptyString(1, 2, 3) if i &lt; 10) yield i + 1
res1: String[Int] = String(2, 3, 4)

scala&gt; for {
     |   i &lt;- NonEmptyString(1, 2, 3)
     |   j &lt;- NonEmptyString('a', 'b', 'c')
     | } yield (i, j)
res3: org.scalactic.anyvals.NonEmptyString[(Int, Char)] =
        NonEmptyString((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))

scala&gt; for {
     |   i &lt;- NonEmptyString(1, 2, 3) if i &lt; 10
     |   j &lt;- NonEmptyString('a', 'b', 'c')
     | } yield (i, j)
res6: String[(Int, Char)] =
        String((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))
</pre></p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptyVector" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonEmptyVector[+T]extendsAnyVal" class="anchorToMember"></a><a id="NonEmptyVector[+T]:NonEmptyVector[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptyVector.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonEmptyVector.html" title="A non-empty list: an ordered, immutable, non-empty collection of elements with LinearSeq performance characteristics."><span class="name">NonEmptyVector</span></a><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">A non-empty list: an ordered, immutable, non-empty collection of elements with <code>LinearSeq</code> performance characteristics.</p><div class="fullcomment"><div class="comment cmt"><p>A non-empty list: an ordered, immutable, non-empty collection of elements with <code>LinearSeq</code> performance characteristics.</p><p>The purpose of <code>NonEmptyVector</code> is to allow you to express in a type that a <code>Vector</code> is non-empty, thereby eliminating the
need for (and potential exception from) a run-time check for non-emptiness. For a non-empty sequence with <code>IndexedSeq</code>
performance, see <a href="Every.html"><code>Every</code></a>.</p><h4> Constructing <code>NonEmptyVector</code>s </h4><p>You can construct a <code>NonEmptyVector</code> by passing one or more elements to the <code>NonEmptyVector.apply</code> factory method:</p><p><pre class="stHighlighted">
scala&gt; <span class="stType">NonEmptyVector</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
res0: <span class="stType">org.scalactic.anyvals.NonEmptyVector[Int]</span> = <span class="stType">NonEmptyVector</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>Alternatively you can <em>cons</em> elements onto the <code>End</code> singleton object, similar to making a <code>Vector</code> starting with <code>Nil</code>:</p><p><pre class="stHighlighted">
scala&gt; <span class="stLiteral">1</span> :: <span class="stLiteral">2</span> :: <span class="stLiteral">3</span> :: <span class="stType">Nil</span>
res0: <span class="stType">Vector[Int]</span> = <span class="stType">Vector</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
<br/>scala&gt; <span class="stLiteral">1</span> :: <span class="stLiteral">2</span> :: <span class="stLiteral">3</span> :: <span class="stType">End</span>
res1: <span class="stType">org.scalactic.NonEmptyVector[Int]</span> = <span class="stType">NonEmptyVector</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>)
</pre></p><p>Note that although <code>Nil</code> is a <code>Vector[Nothing]</code>, <code>End</code> is
not a <code>NonEmptyVector[Nothing]</code>, because no empty <code>NonEmptyVector</code> exists. (A non-empty list is a series
of connected links; if you have no links, you have no non-empty list.)</p><p><pre class="stHighlighted">
scala&gt; <span class="stReserved">val</span> nil: <span class="stType">Vector[Nothing]</span> = <span class="stType">Nil</span>
nil: <span class="stType">Vector[Nothing]</span> = <span class="stType">Vector</span>()
<br/>scala&gt; <span class="stReserved">val</span> nada: <span class="stType">NonEmptyVector[Nothing]</span> = <span class="stType">End</span>
&lt;console&gt;:<span class="stLiteral">16</span>: error: <span class="stReserved">type</span> mismatch;
found   : org.scalactic.anyvals.End.type
required: <span class="stType">org.scalactic.anyvals.NonEmptyVector[Nothing]</span>
       <span class="stReserved">val</span> nada: <span class="stType">NonEmptyVector[Nothing]</span> = <span class="stType">End</span>
                                         ^
</pre></p><h4> Working with <code>NonEmptyVector</code>s </h4><p><code>NonEmptyVector</code> does not extend Scala's <code>Seq</code> or <code>Traversable</code> traits because these require that
implementations may be empty. For example, if you invoke <code>tail</code> on a <code>Seq</code> that contains just one element,
you'll get an empty <code>Seq</code>:</p><p><pre class="stREPL">
scala&gt; Vector(1).tail
res6: Vector[Int] = Vector()
</pre></p><p>On the other hand, many useful methods exist on <code>Seq</code> that when invoked on a non-empty <code>Seq</code> are guaranteed
to not result in an empty <code>Seq</code>. For convenience, <code>NonEmptyVector</code> defines a method corresponding to every such <code>Seq</code>
method. Here are some examples:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptyVector</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).map(_ + <span class="stLiteral">1</span>)                        <span class="stLineComment">// Result: NonEmptyVector(2, 3, 4)</span>
<span class="stType">NonEmptyVector</span>(<span class="stLiteral">1</span>).map(_ + <span class="stLiteral">1</span>)                              <span class="stLineComment">// Result: NonEmptyVector(2)</span>
<span class="stType">NonEmptyVector</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).containsSlice(<span class="stType">NonEmptyVector</span>(<span class="stLiteral">2</span>, <span class="stLiteral">3</span>)) <span class="stLineComment">// Result: true</span>
<span class="stType">NonEmptyVector</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).containsSlice(<span class="stType">NonEmptyVector</span>(<span class="stLiteral">3</span>, <span class="stLiteral">4</span>)) <span class="stLineComment">// Result: false</span>
<span class="stType">NonEmptyVector</span>(-<span class="stLiteral">1</span>, -<span class="stLiteral">2</span>, <span class="stLiteral">3</span>, <span class="stLiteral">4</span>, <span class="stLiteral">5</span>).minBy(_.abs)              <span class="stLineComment">// Result: -1</span>
</pre></p><p><code>NonEmptyVector</code> does <em>not</em> currently define any methods corresponding to <code>Seq</code> methods that could result in
an empty <code>Seq</code>. However, an implicit converison from <code>NonEmptyVector</code> to <code>Vector</code>
is defined in the <code>NonEmptyVector</code> companion object that will be applied if you attempt to call one of the missing methods. As a
result, you can invoke <code>filter</code> on an <code>NonEmptyVector</code>, even though <code>filter</code> could result
in an empty sequence&mdash;but the result type will be <code>Vector</code> instead of <code>NonEmptyVector</code>:</p><p><pre class="stHighlighted">
<span class="stType">NonEmptyVector</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).filter(_ &lt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: Vector(1, 2, 3)</span>
<span class="stType">NonEmptyVector</span>(<span class="stLiteral">1</span>, <span class="stLiteral">2</span>, <span class="stLiteral">3</span>).filter(_ &gt; <span class="stLiteral">10</span>) <span class="stLineComment">// Result: Vector()</span>
</pre></p><p>You can use <code>NonEmptyVector</code>s in <code>for</code> expressions. The result will be an <code>NonEmptyVector</code> unless
you use a filter (an <code>if</code> clause). Because filters are desugared to invocations of <code>filter</code>, the
result type will switch to a <code>Vector</code> at that point. Here are some examples:</p><p><pre class="stREPL">
scala&gt; import org.scalactic.anyvals._
import org.scalactic.anyvals._

scala&gt; for (i &lt;- NonEmptyVector(1, 2, 3)) yield i + 1
res0: org.scalactic.anyvals.NonEmptyVector[Int] = NonEmptyVector(2, 3, 4)

scala&gt; for (i &lt;- NonEmptyVector(1, 2, 3) if i &lt; 10) yield i + 1
res1: Vector[Int] = Vector(2, 3, 4)

scala&gt; for {
     |   i &lt;- NonEmptyVector(1, 2, 3)
     |   j &lt;- NonEmptyVector('a', 'b', 'c')
     | } yield (i, j)
res3: org.scalactic.anyvals.NonEmptyVector[(Int, Char)] =
        NonEmptyVector((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))

scala&gt; for {
     |   i &lt;- NonEmptyVector(1, 2, 3) if i &lt; 10
     |   j &lt;- NonEmptyVector('a', 'b', 'c')
     | } yield (i, j)
res6: Vector[(Int, Char)] =
        Vector((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))
</pre>
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the type of elements contained in this <code>NonEmptyVector</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroDouble" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonZeroDoubleextendsAnyVal" class="anchorToMember"></a><a id="NonZeroDouble:NonZeroDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroDouble.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonZeroDouble.html" title="An AnyVal for non-zero Doubles."><span class="name">NonZeroDouble</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-zero <code>Double</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-zero <code>Double</code>s.</p><p>Note: a <code>NonZeroDouble</code> may not equal 0.0.</p><p>Because <code>NonZeroDouble</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Double</code>, being
boxed only when a <code>Double</code> would have been boxed.</p><p>The <code>NonZeroDouble.apply</code> factory method is
implemented in terms of a macro that checks literals for
validity at compile time. Calling
<code>NonZeroDouble.apply</code> with a literal
<code>Double</code> value will either produce a valid
<code>NonZeroDouble</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NonZeroDouble(1.1)
res1: org.scalactic.anyvals.NonZeroDouble = NonZeroDouble(1.1)

scala&gt; NonZeroDouble(0.0)
&lt;console&gt;:14: error: NonZeroDouble.apply can only be invoked on a non-zero (i != 0.0 && !i.isNaN) floating point literal, like NonZeroDouble(1.1).
              NonZeroDouble(0.0)
                       ^
</pre></p><p><code>NonZeroDouble.apply</code> cannot be used if the value
being passed is a variable (<em>i.e.</em>, not a literal),
because the macro cannot determine the validity of variables
at compile time (just literals). If you try to pass a
variable to <code>NonZeroDouble.apply</code>, you'll get a
compiler error that suggests you use a different factor
method, <code>NonZeroDouble.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1.1
x: Double = 1.1

scala&gt; NonZeroDouble(x)
&lt;console&gt;:15: error: NonZeroDouble.apply can only be invoked on a floating point literal, like NonZeroDouble(1.1). Please use NonZeroDouble.from instead.
              NonZeroDouble(x)
                       ^
</pre></p><p>The <code>NonZeroDouble.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NonZeroDouble]</code>. If the value is valid,
<code>NonZeroDouble.from</code> will return a
<code>Some[NonZeroDouble]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NonZeroDouble.from(x)
res4: Option[org.scalactic.anyvals.NonZeroDouble] = Some(NonZeroDouble(1.1))

scala&gt; val y = 0.0
y: Double = 0.0

scala&gt; NonZeroDouble.from(y)
res5: Option[org.scalactic.anyvals.NonZeroDouble] = None
</pre></p><p>The <code>NonZeroDouble.apply</code> factory method is marked
implicit, so that you can pass literal <code>Double</code>s
into methods that require <code>NonZeroDouble</code>, and get the
same compile-time checking you get when calling
<code>NonZeroDouble.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NonZeroDouble): Double = Double.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NonZeroDouble)Double

scala&gt; invert(1.1)
res6: Double = 1.7976931348623157E308

scala&gt; invert(Double.MaxValue)
res8: Double = 0.0

scala&gt; invert(0.0)
&lt;console&gt;:15: error: NonZeroDouble.apply can only be invoked on a non-zero (i != 0.0 && !i.isNaN) floating point literal, like NonZeroDouble(1.1).
              invert(0.0)
                     ^

</pre></p><p>This example also demonstrates that the
<code>NonZeroDouble</code> companion object also defines implicit
widening conversions when a similar conversion is provided in
Scala. This makes it convenient to use a
<code>NonZeroDouble</code> where a <code>Double</code> is
needed. An example is the subtraction in the body of the
<code>invert</code> method defined above,
<code>Double.MaxValue - pos</code>. Although
<code>Double.MaxValue</code> is a <code>Double</code>, which
has no <code>-</code> method that takes a
<code>NonZeroDouble</code> (the type of <code>pos</code>), you
can still subtract <code>pos</code>, because the
<code>NonZeroDouble</code> will be implicitly widened to
<code>Double</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroFiniteDouble" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonZeroFiniteDoubleextendsAnyVal" class="anchorToMember"></a><a id="NonZeroFiniteDouble:NonZeroFiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroFiniteDouble.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonZeroFiniteDouble.html" title="An AnyVal for finite non-zero Doubles."><span class="name">NonZeroFiniteDouble</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite non-zero <code>Double</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite non-zero <code>Double</code>s.</p><p>Note: a <code>NonZeroFiniteDouble</code> may not equal 0.0.</p><p>Because <code>NonZeroFiniteDouble</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Double</code>, being
boxed only when a <code>Double</code> would have been boxed.</p><p>The <code>NonZeroFiniteDouble.apply</code> factory method is
implemented in terms of a macro that checks literals for
validity at compile time. Calling
<code>NonZeroFiniteDouble.apply</code> with a literal
<code>Double</code> value will either produce a valid
<code>NonZeroFiniteDouble</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NonZeroFiniteDouble(1.1)
res1: org.scalactic.anyvals.NonZeroFiniteDouble = NonZeroFiniteDouble(1.1)

scala&gt; NonZeroFiniteDouble(0.0)
&lt;console&gt;:14: error: NonZeroFiniteDouble.apply can only be invoked on a finite non-zero (i != 0.0 && !i.isNaN && i != Double.PositiveInfinity && i != Double.NegativeInfinity) floating point literal, like NonZeroFiniteDouble(1.1).
              NonZeroFiniteDouble(0.0)
                       ^
</pre></p><p><code>NonZeroFiniteDouble.apply</code> cannot be used if the value
being passed is a variable (<em>i.e.</em>, not a literal),
because the macro cannot determine the validity of variables
at compile time (just literals). If you try to pass a
variable to <code>NonZeroFiniteDouble.apply</code>, you'll get a
compiler error that suggests you use a different factor
method, <code>NonZeroFiniteDouble.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1.1
x: Double = 1.1

scala&gt; NonZeroFiniteDouble(x)
&lt;console&gt;:15: error: NonZeroFiniteDouble.apply can only be invoked on a floating point literal, like NonZeroFiniteDouble(1.1). Please use NonZeroFiniteDouble.from instead.
              NonZeroFiniteDouble(x)
                       ^
</pre></p><p>The <code>NonZeroFiniteDouble.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NonZeroFiniteDouble]</code>. If the value is valid,
<code>NonZeroFiniteDouble.from</code> will return a
<code>Some[NonZeroFiniteDouble]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NonZeroFiniteDouble.from(x)
res4: Option[org.scalactic.anyvals.NonZeroFiniteDouble] = Some(NonZeroFiniteDouble(1.1))

scala&gt; val y = 0.0
y: Double = 0.0

scala&gt; NonZeroFiniteDouble.from(y)
res5: Option[org.scalactic.anyvals.NonZeroFiniteDouble] = None
</pre></p><p>The <code>NonZeroFiniteDouble.apply</code> factory method is marked
implicit, so that you can pass literal <code>Double</code>s
into methods that require <code>NonZeroFiniteDouble</code>, and get the
same compile-time checking you get when calling
<code>NonZeroFiniteDouble.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NonZeroFiniteDouble): Double = Double.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NonZeroFiniteDouble)Double

scala&gt; invert(1.1)
res6: Double = 1.7976931348623157E308

scala&gt; invert(Double.MaxValue)
res8: Double = 0.0

scala&gt; invert(0.0)
&lt;console&gt;:15: error: NonZeroFiniteDouble.apply can only be invoked on a finite non-zero (i != 0.0 && !i.isNaN && i != Double.PositiveInfinity && i != Double.NegativeInfinity) floating point literal, like NonZeroFiniteDouble(1.1).
              invert(0.0)
                     ^

</pre></p><p>This example also demonstrates that the
<code>NonZeroFiniteDouble</code> companion object also defines implicit
widening conversions when a similar conversion is provided in
Scala. This makes it convenient to use a
<code>NonZeroFiniteDouble</code> where a <code>Double</code> is
needed. An example is the subtraction in the body of the
<code>invert</code> method defined above,
<code>Double.MaxValue - pos</code>. Although
<code>Double.MaxValue</code> is a <code>Double</code>, which
has no <code>-</code> method that takes a
<code>NonZeroFiniteDouble</code> (the type of <code>pos</code>), you
can still subtract <code>pos</code>, because the
<code>NonZeroFiniteDouble</code> will be implicitly widened to
<code>Double</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroFiniteFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonZeroFiniteFloatextendsAnyVal" class="anchorToMember"></a><a id="NonZeroFiniteFloat:NonZeroFiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroFiniteFloat.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonZeroFiniteFloat.html" title="An AnyVal for finite non-zero Floats."><span class="name">NonZeroFiniteFloat</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite non-zero <code>Float</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite non-zero <code>Float</code>s.</p><p>Note: a <code>NonZeroFiniteFloat</code> may not equal 0.0.</p><p>Because <code>NonZeroFiniteFloat</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Float</code>, being
boxed only when an <code>Float</code> would have been boxed.</p><p>The <code>NonZeroFiniteFloat.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>NonZeroFiniteFloat.apply</code> with a
literal <code>Float</code> value will either produce a valid
<code>NonZeroFiniteFloat</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NonZeroFiniteFloat(1.1F)
res0: org.scalactic.anyvals.NonZeroFiniteFloat = NonZeroFiniteFloat(1.1)

scala&gt; NonZeroFiniteFloat(0.0F)
&lt;console&gt;:14: error: NonZeroFiniteFloat.apply can only be invoked on a finite non-zero (i != 0.0f && !i.isNaN && i != Float.PositiveInfinity && i != Float.NegativeInfinity) floating point literal, like NonZeroFiniteFloat(1.1F).
              NonZeroFiniteFloat(1.1F)
                      ^
</pre></p><p><code>NonZeroFiniteFloat.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>NonZeroFiniteFloat.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>NonZeroFiniteFloat.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1.1F
x: Float = 1.1

scala&gt; NonZeroFiniteFloat(x)
&lt;console&gt;:15: error: NonZeroFiniteFloat.apply can only be invoked on a floating point literal, like NonZeroFiniteFloat(1.1F). Please use NonZeroFiniteFloat.from instead.
              NonZeroFiniteFloat(x)
                      ^
</pre></p><p>The <code>NonZeroFiniteFloat.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NonZeroFiniteFloat]</code>. If the value is valid,
<code>NonZeroFiniteFloat.from</code> will return a
<code>Some[NonZeroFiniteFloat]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NonZeroFiniteFloat.from(x)
res3: Option[org.scalactic.anyvals.NonZeroFiniteFloat] = Some(NonZeroFiniteFloat(1.1))

scala&gt; val y = 0.0F
y: Float = 0.0

scala&gt; NonZeroFiniteFloat.from(y)
res4: Option[org.scalactic.anyvals.NonZeroFiniteFloat] = None
</pre></p><p>The <code>NonZeroFiniteFloat.apply</code> factory method is marked
implicit, so that you can pass literal <code>Float</code>s
into methods that require <code>NonZeroFiniteFloat</code>, and get the
same compile-time checking you get when calling
<code>NonZeroFiniteFloat.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NonZeroFiniteFloat): Float = Float.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NonZeroFiniteFloat)Float

scala&gt; invert(1.1F)
res5: Float = 3.4028235E38

scala&gt; invert(Float.MaxValue)
res6: Float = 0.0

scala&gt; invert(0.0F)
&lt;console&gt;:15: error: NonZeroFiniteFloat.apply can only be invoked on a finite non-zero (i != 0.0f && !i.isNaN && i != Float.PositiveInfinity && i != Float.NegativeInfinity) floating point literal, like NonZeroFiniteFloat(1.1F).
              invert(0.0F)
                     ^

scala&gt; invert(0.0F)
&lt;console&gt;:15: error: NonZeroFiniteFloat.apply can only be invoked on a finite non-zero (i != 0.0f && !i.isNaN && i != Float.PositiveInfinity && i != Float.NegativeInfinity) floating point literal, like NonZeroFiniteFloat(1.1F).
              invert(0.0F)
                      ^

</pre></p><p>This example also demonstrates that the <code>NonZeroFiniteFloat</code>
companion object also defines implicit widening conversions
when no loss of precision will occur. This makes it convenient to use a
<code>NonZeroFiniteFloat</code> where a <code>Float</code> or wider
type is needed. An example is the subtraction in the body of
the <code>invert</code> method defined above,
<code>Float.MaxValue - pos</code>. Although
<code>Float.MaxValue</code> is a <code>Float</code>, which
has no <code>-</code> method that takes a
<code>NonZeroFiniteFloat</code> (the type of <code>pos</code>), you can
still subtract <code>pos</code>, because the
<code>NonZeroFiniteFloat</code> will be implicitly widened to
<code>Float</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonZeroFloatextendsAnyVal" class="anchorToMember"></a><a id="NonZeroFloat:NonZeroFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroFloat.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonZeroFloat.html" title="An AnyVal for non-zero Floats."><span class="name">NonZeroFloat</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-zero <code>Float</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-zero <code>Float</code>s.</p><p>Note: a <code>NonZeroFloat</code> may not equal 0.0.</p><p>Because <code>NonZeroFloat</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Float</code>, being
boxed only when an <code>Float</code> would have been boxed.</p><p>The <code>NonZeroFloat.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>NonZeroFloat.apply</code> with a
literal <code>Float</code> value will either produce a valid
<code>NonZeroFloat</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NonZeroFloat(1.1F)
res0: org.scalactic.anyvals.NonZeroFloat = NonZeroFloat(1.1)

scala&gt; NonZeroFloat(0.0F)
&lt;console&gt;:14: error: NonZeroFloat.apply can only be invoked on a non-zero (i != 0.0f && !i.isNaN) floating point literal, like NonZeroFloat(1.1F).
              NonZeroFloat(1.1F)
                      ^
</pre></p><p><code>NonZeroFloat.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>NonZeroFloat.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>NonZeroFloat.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1.1F
x: Float = 1.1

scala&gt; NonZeroFloat(x)
&lt;console&gt;:15: error: NonZeroFloat.apply can only be invoked on a floating point literal, like NonZeroFloat(1.1F). Please use NonZeroFloat.from instead.
              NonZeroFloat(x)
                      ^
</pre></p><p>The <code>NonZeroFloat.from</code> factory method will inspect
the value at runtime and return an
<code>Option[NonZeroFloat]</code>. If the value is valid,
<code>NonZeroFloat.from</code> will return a
<code>Some[NonZeroFloat]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NonZeroFloat.from(x)
res3: Option[org.scalactic.anyvals.NonZeroFloat] = Some(NonZeroFloat(1.1))

scala&gt; val y = 0.0F
y: Float = 0.0

scala&gt; NonZeroFloat.from(y)
res4: Option[org.scalactic.anyvals.NonZeroFloat] = None
</pre></p><p>The <code>NonZeroFloat.apply</code> factory method is marked
implicit, so that you can pass literal <code>Float</code>s
into methods that require <code>NonZeroFloat</code>, and get the
same compile-time checking you get when calling
<code>NonZeroFloat.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NonZeroFloat): Float = Float.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NonZeroFloat)Float

scala&gt; invert(1.1F)
res5: Float = 3.4028235E38

scala&gt; invert(Float.MaxValue)
res6: Float = 0.0

scala&gt; invert(0.0F)
&lt;console&gt;:15: error: NonZeroFloat.apply can only be invoked on a non-zero (i != 0.0f && !i.isNaN) floating point literal, like NonZeroFloat(1.1F).
              invert(0.0F)
                     ^

scala&gt; invert(0.0F)
&lt;console&gt;:15: error: NonZeroFloat.apply can only be invoked on a non-zero (i != 0.0f && !i.isNaN) floating point literal, like NonZeroFloat(1.1F).
              invert(0.0F)
                      ^

</pre></p><p>This example also demonstrates that the <code>NonZeroFloat</code>
companion object also defines implicit widening conversions
when no loss of precision will occur. This makes it convenient to use a
<code>NonZeroFloat</code> where a <code>Float</code> or wider
type is needed. An example is the subtraction in the body of
the <code>invert</code> method defined above,
<code>Float.MaxValue - pos</code>. Although
<code>Float.MaxValue</code> is a <code>Float</code>, which
has no <code>-</code> method that takes a
<code>NonZeroFloat</code> (the type of <code>pos</code>), you can
still subtract <code>pos</code>, because the
<code>NonZeroFloat</code> will be implicitly widened to
<code>Float</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroInt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonZeroIntextendsAnyVal" class="anchorToMember"></a><a id="NonZeroInt:NonZeroInt" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroInt.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonZeroInt.html" title="An AnyVal for non-zero Ints."><span class="name">NonZeroInt</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-zero <code>Int</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-zero <code>Int</code>s.</p><p>Note: a <code>NonZeroInt</code> may not equal 0.</p><p>Because <code>NonZeroInt</code> is an <code>AnyVal</code> it will usually be
as efficient as an <code>Int</code>, being boxed only when an <code>Int</code>
would have been boxed.</p><p>The <code>NonZeroInt.apply</code> factory method is implemented in terms of a macro that
checks literals for validity at compile time. Calling <code>NonZeroInt.apply</code> with
a literal <code>Int</code> value will either produce a valid <code>NonZeroInt</code> instance
at run time or an error at compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NonZeroInt(42)
res0: org.scalactic.anyvals.NonZeroInt = NonZeroInt(42)

scala&gt; NonZeroInt(0)
&lt;console&gt;:14: error: NonZeroInt.apply can only be invoked on a non-zero (i != 0) literal, like NonZeroInt(42).
              NonZeroInt(0)
                    ^
</pre></p><p><code>NonZeroInt.apply</code> cannot be used if the value being passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at compile time (just literals). If you try to pass a variable
to <code>NonZeroInt.apply</code>, you'll get a compiler error that suggests you use a different factor method,
<code>NonZeroInt.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1
x: Int = 1

scala&gt; NonZeroInt(x)
&lt;console&gt;:15: error: NonZeroInt.apply can only be invoked on a non-zero integer literal, like NonZeroInt(42). Please use NonZeroInt.from instead.
              NonZeroInt(x)
                    ^
</pre></p><p>The <code>NonZeroInt.from</code> factory method will inspect the value at runtime and return an <code>Option[NonZeroInt]</code>. If
the value is valid, <code>NonZeroInt.from</code> will return a <code>Some[NonZeroInt]</code>, else it will return a <code>None</code>.
Here's an example:</p><p><pre class="stREPL">
scala&gt; NonZeroInt.from(x)
res3: Option[org.scalactic.anyvals.NonZeroInt] = Some(NonZeroInt(1))

scala&gt; val y = 0
y: Int = 0

scala&gt; NonZeroInt.from(y)
res4: Option[org.scalactic.anyvals.NonZeroInt] = None
</pre></p><p>The <code>NonZeroInt.apply</code> factory method is marked implicit, so that you can pass literal <code>Int</code>s
into methods that require <code>NonZeroInt</code>, and get the same compile-time checking you get when calling
<code>NonZeroInt.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NonZeroInt): Int = Int.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NonZeroInt)Int

scala&gt; invert(1)
res0: Int = 2147483646

scala&gt; invert(Int.MaxValue)
res1: Int = 0

scala&gt; invert(0)
&lt;console&gt;:15: error: NonZeroInt.apply can only be invoked on a non-zero (i != 0) integer literal, like NonZeroInt(42).
              invert(0)
                     ^

scala&gt; invert(-1)
&lt;console&gt;:15: error: NonZeroInt.apply can only be invoked on a non-zero (i != 0) integer literal, like NonZeroInt(42).
              invert(-1)
                      ^

</pre></p><p>This example also demonstrates that the <code>NonZeroInt</code> companion object also defines implicit widening conversions
when either no loss of precision will occur or a similar conversion is provided in Scala. (For example, the implicit
conversion from <code>Int</code> to </code>Float</code> in Scala can lose precision.) This makes it convenient to
use a <code>NonZeroInt</code> where an <code>Int</code> or wider type is needed. An example is the subtraction in the body
of the <code>invert</code> method defined above, <code>Int.MaxValue - pos</code>. Although <code>Int.MaxValue</code> is
an <code>Int</code>, which has no <code>-</code> method that takes a <code>NonZeroInt</code> (the type of <code>pos</code>),
you can still subtract <code>pos</code>, because the <code>NonZeroInt</code> will be implicitly widened to <code>Int</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroLong" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonZeroLongextendsAnyVal" class="anchorToMember"></a><a id="NonZeroLong:NonZeroLong" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroLong.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NonZeroLong.html" title="An AnyVal for non-zero Longs."><span class="name">NonZeroLong</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-zero <code>Long</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-zero <code>Long</code>s.</p><p>Note: a <code>NonZeroLong</code> may not equal 0.</p><p>Because <code>NonZeroLong</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Long</code>, being
boxed only when an <code>Long</code> would have been boxed.</p><p>The <code>NonZeroLong.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>NonZeroLong.apply</code> with a
literal <code>Long</code> value will either produce a valid
<code>NonZeroLong</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NonZeroLong(42)
res0: org.scalactic.anyvals.NonZeroLong = NonZeroLong(42)

scala&gt; NonZeroLong(0)
&lt;console&gt;:14: error: NonZeroLong.apply can only be invoked on a non-zero (i != 0L) integer literal, like NonZeroLong(42).
              NonZeroLong(0)
                     ^
</pre></p><p><code>NonZeroLong.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>NonZeroLong.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>NonZeroLong.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 42L
x: Long = 42

scala&gt; NonZeroLong(x)
&lt;console&gt;:15: error: NonZeroLong.apply can only be invoked on an long literal, like NonZeroLong(42). Please use NonZeroLong.from instead.
              NonZeroLong(x)
                     ^
</pre></p><p>The <code>NonZeroLong.from</code> factory method will inspect the
value at runtime and return an
<code>Option[NonZeroLong]</code>. If the value is valid,
<code>NonZeroLong.from</code> will return a
<code>Some[NonZeroLong]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; NonZeroLong.from(x)
res3: Option[org.scalactic.anyvals.NonZeroLong] = Some(NonZeroLong(42))

scala&gt; val y = 0L
y: Long = 0

scala&gt; NonZeroLong.from(y)
res4: Option[org.scalactic.anyvals.NonZeroLong] = None
</pre></p><p>The <code>NonZeroLong.apply</code> factory method is marked
implicit, so that you can pass literal <code>Long</code>s
into methods that require <code>NonZeroLong</code>, and get the
same compile-time checking you get when calling
<code>NonZeroLong.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: NonZeroLong): Long = Long.MaxValue - pos
invert: (pos: org.scalactic.anyvals.NonZeroLong)Long

scala&gt; invert(1L)
res5: Long = 9223372036854775806

scala&gt; invert(Long.MaxValue)
res6: Long = 0

scala&gt; invert(0L)
&lt;console&gt;:15: error: NonZeroLong.apply can only be invoked on a non-zero (i != 0L) integer literal, like NonZeroLong(42L).
              invert(0L)
                     ^

</pre></p><p>This example also demonstrates that the <code>NonZeroLong</code>
companion object also defines implicit widening conversions
when either no loss of precision will occur or a similar
conversion is provided in Scala. (For example, the implicit
conversion from <code>Long</code> to </code>Double</code> in
Scala can lose precision.) This makes it convenient to use a
<code>NonZeroLong</code> where a <code>Long</code> or wider type
is needed. An example is the subtraction in the body of the
<code>invert</code> method defined above, <code>Long.MaxValue
- pos</code>. Although <code>Long.MaxValue</code> is a
<code>Long</code>, which has no <code>-</code> method that
takes a <code>NonZeroLong</code> (the type of <code>pos</code>),
you can still subtract <code>pos</code>, because the
<code>NonZeroLong</code> will be implicitly widened to
<code>Long</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NumericChar" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NumericCharextendsAnyVal" class="anchorToMember"></a><a id="NumericChar:NumericChar" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NumericChar.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NumericChar.html" title="An AnyVal for numeric Chars."><span class="name">NumericChar</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for numeric <code>Char</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for numeric <code>Char</code>s.</p><p>Note: a <code>NumericChar</code> has a value between '0' and '9'.</p><p>Because <code>NumericChar</code> is an <code>AnyVal</code> it will usually
be as efficient as a <code>Char</code>, being boxed only when a
<code>Char</code> would have been boxed.</p><p>The <code>NumericChar.apply</code> factory method is implemented in terms
of a macro that checks literals for validity at compile time. Calling
<code>NumericChar.apply</code> with a literal <code>Char</code> value will
either produce a valid <code>NumericChar</code> instance at run time or an
error at compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NumericChar('4')
res0: org.scalactic.anyvals.NumericChar = NumericChar('4')

scala&gt; NumericChar('a')
&lt;console&gt;:14: error: NumericChar.apply can only be invoked on Char literals that are numeric, like NumericChar('4').
              NumericChar('a')
                         ^
</pre></p><p><code>NumericChar.apply</code> cannot be used if the value being passed
is a variable (<em>i.e.</em>, not a literal), because the macro cannot
determine the validity of variables at compile time (just literals).
If you try to pass a variable to <code>NumericChar.apply</code>, you'll
get a compiler error that suggests you use a different factory method,
<code>NumericChar.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = '1'
x: Char = 1

scala&gt; NumericChar(x)
&lt;console&gt;:15: error: NumericChar.apply can only be invoked on Char literals that are numeric, like NumericChar('4'). Please use NumericChar.from instead.
              NumericChar(x)
                         ^
</pre></p><p>The <code>NumericChar.from</code> factory method will inspect the value at
runtime and return an <code>Option[NumericChar]</code>. If the value is
valid, <code>NumericChar.from</code> will return a
<code>Some[NumericChar]</code>, else it will return a <code>None</code>.
Here's an example:</p><p><pre class="stREPL">
scala&gt; NumericChar.from(x)
res3: Option[org.scalactic.anyvals.NumericChar] = Some(NumericChar('1'))

scala&gt; val y = 'a'
y: Char = a

scala&gt; NumericChar.from(y)
res4: Option[org.scalactic.anyvals.NumericChar] = None
</pre></p><p>The <code>NumericChar.apply</code> factory method is marked implicit, so
that you can pass literal <code>Char</code>s into methods that require
<code>NumericChar</code>, and get the same compile-time checking you get
when calling <code>NumericChar.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(ch: NumericChar): Char = ('9' - ch + '0').toChar
invert: (ch: org.scalactic.anyvals.NumericChar)Char

scala&gt; invert('1')
res6: Char = 8

scala&gt; scala> invert('9')
res7: Char = 0

scala&gt; invert('a')
&lt;console&gt;:12: error: NumericChar.apply can only be invoked on Char literals that are numeric, like NumericChar('4').
              invert('a')
                     ^
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.NumericString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NumericStringextendsAnyVal" class="anchorToMember"></a><a id="NumericString:NumericString" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NumericString.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NumericString.html" title="An AnyVal for numeric Strings."><span class="name">NumericString</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for numeric <code>String</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for numeric <code>String</code>s.</p><p>Note: a <code>NumericString</code> contains only numeric digit characters.</p><p>Because <code>NumericString</code> is an <code>AnyVal</code>
it will usually be as efficient as a <code>String</code>, being
boxed only when a <code>String</code> would have been boxed.</p><p>The <code>NumericString.apply</code> factory method is implemented in
terms of a macro that checks literals for validity at compile time. Calling
<code>NumericString.apply</code> with a literal <code>String</code> value
will either produce a valid <code>NumericString</code> instance at run
time or an error at compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; NumericString("42")
res0: org.scalactic.anyvals.NumericString = NumericString(42)

scala&gt; NumericString("abc")
&lt;console&gt;:11: error: NumericString.apply can only be invoked on String literals that contain numeric characters, i.e., decimal digits '0' through '9', like "123".
              NumericString("abc")
                           ^
</pre></p><p><code>NumericString.apply</code> cannot be used if the value being passed
is a variable (<em>i.e.</em>, not a literal), because the macro cannot
determine the validity of variables at compile time (just literals). If
you try to pass a variable to <code>NumericString.apply</code>, you'll
get a compiler error that suggests you use a different factory method,
<code>NumericString.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = "1"
x: String = 1

scala&gt; NumericString(x)
&lt;console&gt;:15: error: NumericString.apply can only be invoked on String literals that contain only numeric characters, i.e., decimal digits '0' through '9', like "123" Please use NumericString.from instead.
              NumericString(x)
                           ^
</pre></p><p>The <code>NumericString.from</code> factory method will inspect the value
at runtime and return an <code>Option[NumericString]</code>. If
the value is valid, <code>NumericString.from</code> will return a
<code>Some[NumericString]</code>, else it will return a <code>None</code>.
Here's an example:</p><p><pre class="stREPL">
scala&gt; NumericString.from(x)
res3: Option[org.scalactic.anyvals.NumericString] = Some(NumericString(1))

scala&gt; val y = "a"
y: String = a

scala&gt; NumericString.from(y)
res4: Option[org.scalactic.anyvals.NumericString] = None
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosDouble" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosDoubleextendsAnyVal" class="anchorToMember"></a><a id="PosDouble:PosDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosDouble.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosDouble.html" title="An AnyVal for positive Doubles."><span class="name">PosDouble</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for positive <code>Double</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for positive <code>Double</code>s.</p><p>Because <code>PosDouble</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Double</code>, being
boxed only when a <code>Double</code> would have been boxed.</p><p>The <code>PosDouble.apply</code> factory method is
implemented in terms of a macro that checks literals for
validity at compile time. Calling
<code>PosDouble.apply</code> with a literal
<code>Double</code> value will either produce a valid
<code>PosDouble</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosDouble(1.1)
res1: org.scalactic.anyvals.PosDouble = PosDouble(1.1)

scala&gt; PosDouble(-1.1)
&lt;console&gt;:14: error: PosDouble.apply can only be invoked on a positive (i > 0.0) floating point literal, like PosDouble(1.1).
              PosDouble(-1.1)
                       ^
</pre></p><p><code>PosDouble.apply</code> cannot be used if the value
being passed is a variable (<em>i.e.</em>, not a literal),
because the macro cannot determine the validity of variables
at compile time (just literals). If you try to pass a
variable to <code>PosDouble.apply</code>, you'll get a
compiler error that suggests you use a different factor
method, <code>PosDouble.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1.1
x: Double = 1.1

scala&gt; PosDouble(x)
&lt;console&gt;:15: error: PosDouble.apply can only be invoked on a floating point literal, like PosDouble(1.1). Please use PosDouble.from instead.
              PosDouble(x)
                       ^
</pre></p><p>The <code>PosDouble.from</code> factory method will inspect
the value at runtime and return an
<code>Option[PosDouble]</code>. If the value is valid,
<code>PosDouble.from</code> will return a
<code>Some[PosDouble]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; PosDouble.from(x)
res4: Option[org.scalactic.anyvals.PosDouble] = Some(PosDouble(1.1))

scala&gt; val y = -1.1
y: Double = -1.1

scala&gt; PosDouble.from(y)
res5: Option[org.scalactic.anyvals.PosDouble] = None
</pre></p><p>The <code>PosDouble.apply</code> factory method is marked
implicit, so that you can pass literal <code>Double</code>s
into methods that require <code>PosDouble</code>, and get the
same compile-time checking you get when calling
<code>PosDouble.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosDouble): Double = Double.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosDouble)Double

scala&gt; invert(1.1)
res6: Double = 1.7976931348623157E308

scala&gt; invert(Double.MaxValue)
res8: Double = 0.0

scala&gt; invert(-1.1)
&lt;console&gt;:15: error: PosDouble.apply can only be invoked on a positive (i > 0.0) floating point literal, like PosDouble(1.1).
              invert(-1.1)
                     ^

</pre></p><p>This example also demonstrates that the
<code>PosDouble</code> companion object also defines implicit
widening conversions when a similar conversion is provided in
Scala. This makes it convenient to use a
<code>PosDouble</code> where a <code>Double</code> is
needed. An example is the subtraction in the body of the
<code>invert</code> method defined above,
<code>Double.MaxValue - pos</code>. Although
<code>Double.MaxValue</code> is a <code>Double</code>, which
has no <code>-</code> method that takes a
<code>PosDouble</code> (the type of <code>pos</code>), you
can still subtract <code>pos</code>, because the
<code>PosDouble</code> will be implicitly widened to
<code>Double</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosFiniteDouble" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosFiniteDoubleextendsAnyVal" class="anchorToMember"></a><a id="PosFiniteDouble:PosFiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosFiniteDouble.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosFiniteDouble.html" title="An AnyVal for finite positive Doubles."><span class="name">PosFiniteDouble</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite positive <code>Double</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite positive <code>Double</code>s.</p><p>Because <code>PosFiniteDouble</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Double</code>, being
boxed only when a <code>Double</code> would have been boxed.</p><p>The <code>PosFiniteDouble.apply</code> factory method is
implemented in terms of a macro that checks literals for
validity at compile time. Calling
<code>PosFiniteDouble.apply</code> with a literal
<code>Double</code> value will either produce a valid
<code>PosFiniteDouble</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosFiniteDouble(1.1)
res1: org.scalactic.anyvals.PosFiniteDouble = PosFiniteDouble(1.1)

scala&gt; PosFiniteDouble(-1.1)
&lt;console&gt;:14: error: PosFiniteDouble.apply can only be invoked on a finite positive (i > 0.0  && i != Double.PositiveInfinity) floating point literal, like PosFiniteDouble(1.1).
              PosFiniteDouble(-1.1)
                       ^
</pre></p><p><code>PosFiniteDouble.apply</code> cannot be used if the value
being passed is a variable (<em>i.e.</em>, not a literal),
because the macro cannot determine the validity of variables
at compile time (just literals). If you try to pass a
variable to <code>PosFiniteDouble.apply</code>, you'll get a
compiler error that suggests you use a different factor
method, <code>PosFiniteDouble.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1.1
x: Double = 1.1

scala&gt; PosFiniteDouble(x)
&lt;console&gt;:15: error: PosFiniteDouble.apply can only be invoked on a floating point literal, like PosFiniteDouble(1.1). Please use PosFiniteDouble.from instead.
              PosFiniteDouble(x)
                       ^
</pre></p><p>The <code>PosFiniteDouble.from</code> factory method will inspect
the value at runtime and return an
<code>Option[PosFiniteDouble]</code>. If the value is valid,
<code>PosFiniteDouble.from</code> will return a
<code>Some[PosFiniteDouble]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; PosFiniteDouble.from(x)
res4: Option[org.scalactic.anyvals.PosFiniteDouble] = Some(PosFiniteDouble(1.1))

scala&gt; val y = -1.1
y: Double = -1.1

scala&gt; PosFiniteDouble.from(y)
res5: Option[org.scalactic.anyvals.PosFiniteDouble] = None
</pre></p><p>The <code>PosFiniteDouble.apply</code> factory method is marked
implicit, so that you can pass literal <code>Double</code>s
into methods that require <code>PosFiniteDouble</code>, and get the
same compile-time checking you get when calling
<code>PosFiniteDouble.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosFiniteDouble): Double = Double.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosFiniteDouble)Double

scala&gt; invert(1.1)
res6: Double = 1.7976931348623157E308

scala&gt; invert(Double.MaxValue)
res8: Double = 0.0

scala&gt; invert(-1.1)
&lt;console&gt;:15: error: PosFiniteDouble.apply can only be invoked on a finite positive (i > 0.0  && i != Double.PositiveInfinity) floating point literal, like PosFiniteDouble(1.1).
              invert(-1.1)
                     ^

</pre></p><p>This example also demonstrates that the
<code>PosFiniteDouble</code> companion object also defines implicit
widening conversions when a similar conversion is provided in
Scala. This makes it convenient to use a
<code>PosFiniteDouble</code> where a <code>Double</code> is
needed. An example is the subtraction in the body of the
<code>invert</code> method defined above,
<code>Double.MaxValue - pos</code>. Although
<code>Double.MaxValue</code> is a <code>Double</code>, which
has no <code>-</code> method that takes a
<code>PosFiniteDouble</code> (the type of <code>pos</code>), you
can still subtract <code>pos</code>, because the
<code>PosFiniteDouble</code> will be implicitly widened to
<code>Double</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosFiniteFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosFiniteFloatextendsAnyVal" class="anchorToMember"></a><a id="PosFiniteFloat:PosFiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosFiniteFloat.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosFiniteFloat.html" title="An AnyVal for finite positive Floats."><span class="name">PosFiniteFloat</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite positive <code>Float</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite positive <code>Float</code>s.</p><p>Note: a <code>PosFiniteFloat</code> may not equal 0.0. If you want positive number or 0, use <a href="PosZFiniteFloat.html" name="org.scalactic.anyvals.PosZFiniteFloat" id="org.scalactic.anyvals.PosZFiniteFloat" class="extype">PosZFiniteFloat</a>.</p><p>Because <code>PosFiniteFloat</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Float</code>, being
boxed only when an <code>Float</code> would have been boxed.</p><p>The <code>PosFiniteFloat.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>PosFiniteFloat.apply</code> with a
literal <code>Float</code> value will either produce a valid
<code>PosFiniteFloat</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosFiniteFloat(42.1fF)
res0: org.scalactic.anyvals.PosFiniteFloat = PosFiniteFloat(42.1f)

scala&gt; PosFiniteFloat(0.0fF)
&lt;console&gt;:14: error: PosFiniteFloat.apply can only be invoked on a finite positive (i > 0.0f && i != Float.PositiveInfinity) floating point literal, like PosFiniteFloat(42.1fF).
              PosFiniteFloat(42.1fF)
                      ^
</pre></p><p><code>PosFiniteFloat.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>PosFiniteFloat.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>PosFiniteFloat.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 42.1fF
x: Float = 42.1f

scala&gt; PosFiniteFloat(x)
&lt;console&gt;:15: error: PosFiniteFloat.apply can only be invoked on a floating point literal, like PosFiniteFloat(42.1fF). Please use PosFiniteFloat.from instead.
              PosFiniteFloat(x)
                      ^
</pre></p><p>The <code>PosFiniteFloat.from</code> factory method will inspect
the value at runtime and return an
<code>Option[PosFiniteFloat]</code>. If the value is valid,
<code>PosFiniteFloat.from</code> will return a
<code>Some[PosFiniteFloat]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; PosFiniteFloat.from(x)
res3: Option[org.scalactic.anyvals.PosFiniteFloat] = Some(PosFiniteFloat(42.1f))

scala&gt; val y = 0.0fF
y: Float = 0.0f

scala&gt; PosFiniteFloat.from(y)
res4: Option[org.scalactic.anyvals.PosFiniteFloat] = None
</pre></p><p>The <code>PosFiniteFloat.apply</code> factory method is marked
implicit, so that you can pass literal <code>Float</code>s
into methods that require <code>PosFiniteFloat</code>, and get the
same compile-time checking you get when calling
<code>PosFiniteFloat.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosFiniteFloat): Float = Float.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosFiniteFloat)Float

scala&gt; invert(42.1fF)
res5: Float = 3.4028235E38

scala&gt; invert(Float.MaxValue)
res6: Float = 0.0

scala&gt; invert(0.0fF)
&lt;console&gt;:15: error: PosFiniteFloat.apply can only be invoked on a finite positive (i > 0.0f && i != Float.PositiveInfinity) floating point literal, like PosFiniteFloat(42.1fF).
              invert(0.0F)
                     ^

scala&gt; invert(0.0fF)
&lt;console&gt;:15: error: PosFiniteFloat.apply can only be invoked on a finite positive (i > 0.0f && i != Float.PositiveInfinity) floating point literal, like PosFiniteFloat(42.1fF).
              invert(0.0fF)
                      ^

</pre></p><p>This example also demonstrates that the <code>PosFiniteFloat</code>
companion object also defines implicit widening conversions
when no loss of precision will occur. This makes it convenient to use a
<code>PosFiniteFloat</code> where a <code>Float</code> or wider
type is needed. An example is the subtraction in the body of
the <code>invert</code> method defined above,
<code>Float.MaxValue - pos</code>. Although
<code>Float.MaxValue</code> is a <code>Float</code>, which
has no <code>-</code> method that takes a
<code>PosFiniteFloat</code> (the type of <code>pos</code>), you can
still subtract <code>pos</code>, because the
<code>PosFiniteFloat</code> will be implicitly widened to
<code>Float</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosFloatextendsAnyVal" class="anchorToMember"></a><a id="PosFloat:PosFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosFloat.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosFloat.html" title="An AnyVal for positive Floats."><span class="name">PosFloat</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for positive <code>Float</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for positive <code>Float</code>s.</p><p>Note: a <code>PosFloat</code> may not equal 0.0. If you want positive number or 0, use <a href="PosZFloat.html" name="org.scalactic.anyvals.PosZFloat" id="org.scalactic.anyvals.PosZFloat" class="extype">PosZFloat</a>.</p><p>Because <code>PosFloat</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Float</code>, being
boxed only when an <code>Float</code> would have been boxed.</p><p>The <code>PosFloat.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>PosFloat.apply</code> with a
literal <code>Float</code> value will either produce a valid
<code>PosFloat</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosFloat(42.1fF)
res0: org.scalactic.anyvals.PosFloat = PosFloat(42.1f)

scala&gt; PosFloat(0.0fF)
&lt;console&gt;:14: error: PosFloat.apply can only be invoked on a positive (i > 0.0f) floating point literal, like PosFloat(42.1fF).
              PosFloat(42.1fF)
                      ^
</pre></p><p><code>PosFloat.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>PosFloat.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>PosFloat.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 42.1fF
x: Float = 42.1f

scala&gt; PosFloat(x)
&lt;console&gt;:15: error: PosFloat.apply can only be invoked on a floating point literal, like PosFloat(42.1fF). Please use PosFloat.from instead.
              PosFloat(x)
                      ^
</pre></p><p>The <code>PosFloat.from</code> factory method will inspect
the value at runtime and return an
<code>Option[PosFloat]</code>. If the value is valid,
<code>PosFloat.from</code> will return a
<code>Some[PosFloat]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; PosFloat.from(x)
res3: Option[org.scalactic.anyvals.PosFloat] = Some(PosFloat(42.1f))

scala&gt; val y = 0.0fF
y: Float = 0.0f

scala&gt; PosFloat.from(y)
res4: Option[org.scalactic.anyvals.PosFloat] = None
</pre></p><p>The <code>PosFloat.apply</code> factory method is marked
implicit, so that you can pass literal <code>Float</code>s
into methods that require <code>PosFloat</code>, and get the
same compile-time checking you get when calling
<code>PosFloat.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosFloat): Float = Float.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosFloat)Float

scala&gt; invert(42.1fF)
res5: Float = 3.4028235E38

scala&gt; invert(Float.MaxValue)
res6: Float = 0.0

scala&gt; invert(0.0fF)
&lt;console&gt;:15: error: PosFloat.apply can only be invoked on a positive (i > 0.0f) floating point literal, like PosFloat(42.1fF).
              invert(0.0F)
                     ^

scala&gt; invert(0.0fF)
&lt;console&gt;:15: error: PosFloat.apply can only be invoked on a positive (i > 0.0f) floating point literal, like PosFloat(42.1fF).
              invert(0.0fF)
                      ^

</pre></p><p>This example also demonstrates that the <code>PosFloat</code>
companion object also defines implicit widening conversions
when no loss of precision will occur. This makes it convenient to use a
<code>PosFloat</code> where a <code>Float</code> or wider
type is needed. An example is the subtraction in the body of
the <code>invert</code> method defined above,
<code>Float.MaxValue - pos</code>. Although
<code>Float.MaxValue</code> is a <code>Float</code>, which
has no <code>-</code> method that takes a
<code>PosFloat</code> (the type of <code>pos</code>), you can
still subtract <code>pos</code>, because the
<code>PosFloat</code> will be implicitly widened to
<code>Float</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosInt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosIntextendsAnyVal" class="anchorToMember"></a><a id="PosInt:PosInt" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosInt.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosInt.html" title="An AnyVal for positive Ints."><span class="name">PosInt</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for positive <code>Int</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for positive <code>Int</code>s.</p><p>Note: a <code>PosInt</code> may not equal 0. If you want positive number or 0, use <a href="PosZInt.html" name="org.scalactic.anyvals.PosZInt" id="org.scalactic.anyvals.PosZInt" class="extype">PosZInt</a>.</p><p>Because <code>PosInt</code> is an <code>AnyVal</code> it will usually be
as efficient as an <code>Int</code>, being boxed only when an <code>Int</code>
would have been boxed.</p><p>The <code>PosInt.apply</code> factory method is implemented in terms of a macro that
checks literals for validity at compile time. Calling <code>PosInt.apply</code> with
a literal <code>Int</code> value will either produce a valid <code>PosInt</code> instance
at run time or an error at compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosInt(42)
res0: org.scalactic.anyvals.PosInt = PosInt(42)

scala&gt; PosInt(0)
&lt;console&gt;:14: error: PosInt.apply can only be invoked on a positive (i > 0) literal, like PosInt(42).
              PosInt(0)
                    ^
</pre></p><p><code>PosInt.apply</code> cannot be used if the value being passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at compile time (just literals). If you try to pass a variable
to <code>PosInt.apply</code>, you'll get a compiler error that suggests you use a different factor method,
<code>PosInt.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1
x: Int = 1

scala&gt; PosInt(x)
&lt;console&gt;:15: error: PosInt.apply can only be invoked on a positive integer literal, like PosInt(42). Please use PosInt.from instead.
              PosInt(x)
                    ^
</pre></p><p>The <code>PosInt.from</code> factory method will inspect the value at runtime and return an <code>Option[PosInt]</code>. If
the value is valid, <code>PosInt.from</code> will return a <code>Some[PosInt]</code>, else it will return a <code>None</code>.
Here's an example:</p><p><pre class="stREPL">
scala&gt; PosInt.from(x)
res3: Option[org.scalactic.anyvals.PosInt] = Some(PosInt(1))

scala&gt; val y = 0
y: Int = 0

scala&gt; PosInt.from(y)
res4: Option[org.scalactic.anyvals.PosInt] = None
</pre></p><p>The <code>PosInt.apply</code> factory method is marked implicit, so that you can pass literal <code>Int</code>s
into methods that require <code>PosInt</code>, and get the same compile-time checking you get when calling
<code>PosInt.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosInt): Int = Int.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosInt)Int

scala&gt; invert(1)
res0: Int = 2147483646

scala&gt; invert(Int.MaxValue)
res1: Int = 0

scala&gt; invert(0)
&lt;console&gt;:15: error: PosInt.apply can only be invoked on a positive (i > 0) integer literal, like PosInt(42).
              invert(0)
                     ^

scala&gt; invert(-1)
&lt;console&gt;:15: error: PosInt.apply can only be invoked on a positive (i > 0) integer literal, like PosInt(42).
              invert(-1)
                      ^

</pre></p><p>This example also demonstrates that the <code>PosInt</code> companion object also defines implicit widening conversions
when either no loss of precision will occur or a similar conversion is provided in Scala. (For example, the implicit
conversion from <code>Int</code> to </code>Float</code> in Scala can lose precision.) This makes it convenient to
use a <code>PosInt</code> where an <code>Int</code> or wider type is needed. An example is the subtraction in the body
of the <code>invert</code> method defined above, <code>Int.MaxValue - pos</code>. Although <code>Int.MaxValue</code> is
an <code>Int</code>, which has no <code>-</code> method that takes a <code>PosInt</code> (the type of <code>pos</code>),
you can still subtract <code>pos</code>, because the <code>PosInt</code> will be implicitly widened to <code>Int</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosLong" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosLongextendsAnyVal" class="anchorToMember"></a><a id="PosLong:PosLong" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosLong.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosLong.html" title="An AnyVal for positive Longs."><span class="name">PosLong</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for positive <code>Long</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for positive <code>Long</code>s.</p><p>Note: a <code>PosLong</code> may not equal 0. If you want positive number or 0, use <a href="PosZLong.html" name="org.scalactic.anyvals.PosZLong" id="org.scalactic.anyvals.PosZLong" class="extype">PosZLong</a>.</p><p>Because <code>PosLong</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Long</code>, being
boxed only when an <code>Long</code> would have been boxed.</p><p>The <code>PosLong.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>PosLong.apply</code> with a
literal <code>Long</code> value will either produce a valid
<code>PosLong</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosLong(42L)
res0: org.scalactic.anyvals.PosLong = PosLong(42L)

scala&gt; PosLong(0L)
&lt;console&gt;:14: error: PosLong.apply can only be invoked on a positive (i > 0L) integer literal, like PosLong(42L).
              PosLong(0L)
                     ^
</pre></p><p><code>PosLong.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>PosLong.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>PosLong.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 42LL
x: Long = 42L

scala&gt; PosLong(x)
&lt;console&gt;:15: error: PosLong.apply can only be invoked on an long literal, like PosLong(42L). Please use PosLong.from instead.
              PosLong(x)
                     ^
</pre></p><p>The <code>PosLong.from</code> factory method will inspect the
value at runtime and return an
<code>Option[PosLong]</code>. If the value is valid,
<code>PosLong.from</code> will return a
<code>Some[PosLong]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; PosLong.from(x)
res3: Option[org.scalactic.anyvals.PosLong] = Some(PosLong(42L))

scala&gt; val y = 0LL
y: Long = 0L

scala&gt; PosLong.from(y)
res4: Option[org.scalactic.anyvals.PosLong] = None
</pre></p><p>The <code>PosLong.apply</code> factory method is marked
implicit, so that you can pass literal <code>Long</code>s
into methods that require <code>PosLong</code>, and get the
same compile-time checking you get when calling
<code>PosLong.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosLong): Long = Long.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosLong)Long

scala&gt; invert(1L)
res5: Long = 9223372036854775806

scala&gt; invert(Long.MaxValue)
res6: Long = 0

scala&gt; invert(0LL)
&lt;console&gt;:15: error: PosLong.apply can only be invoked on a positive (i > 0L) integer literal, like PosLong(42LL).
              invert(0LL)
                     ^

</pre></p><p>This example also demonstrates that the <code>PosLong</code>
companion object also defines implicit widening conversions
when either no loss of precision will occur or a similar
conversion is provided in Scala. (For example, the implicit
conversion from <code>Long</code> to </code>Double</code> in
Scala can lose precision.) This makes it convenient to use a
<code>PosLong</code> where a <code>Long</code> or wider type
is needed. An example is the subtraction in the body of the
<code>invert</code> method defined above, <code>Long.MaxValue
- pos</code>. Although <code>Long.MaxValue</code> is a
<code>Long</code>, which has no <code>-</code> method that
takes a <code>PosLong</code> (the type of <code>pos</code>),
you can still subtract <code>pos</code>, because the
<code>PosLong</code> will be implicitly widened to
<code>Long</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosZDouble" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosZDoubleextendsAnyVal" class="anchorToMember"></a><a id="PosZDouble:PosZDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZDouble.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosZDouble.html" title="An AnyVal for non-negative Doubles."><span class="name">PosZDouble</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-negative <code>Double</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-negative <code>Double</code>s.</p><p>Because <code>PosZDouble</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Double</code>, being
boxed only when a <code>Double</code> would have been boxed.</p><p>The <code>PosZDouble.apply</code> factory method is
implemented in terms of a macro that checks literals for
validity at compile time. Calling
<code>PosZDouble.apply</code> with a literal
<code>Double</code> value will either produce a valid
<code>PosZDouble</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosZDouble(1.1)
res1: org.scalactic.anyvals.PosZDouble = PosZDouble(1.1)

scala&gt; PosZDouble(-1.1)
&lt;console&gt;:14: error: PosZDouble.apply can only be invoked on a non-negative (i >= 0.0) floating point literal, like PosZDouble(1.1).
              PosZDouble(-1.1)
                       ^
</pre></p><p><code>PosZDouble.apply</code> cannot be used if the value
being passed is a variable (<em>i.e.</em>, not a literal),
because the macro cannot determine the validity of variables
at compile time (just literals). If you try to pass a
variable to <code>PosZDouble.apply</code>, you'll get a
compiler error that suggests you use a different factor
method, <code>PosZDouble.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1.1
x: Double = 1.1

scala&gt; PosZDouble(x)
&lt;console&gt;:15: error: PosZDouble.apply can only be invoked on a floating point literal, like PosZDouble(1.1). Please use PosZDouble.from instead.
              PosZDouble(x)
                       ^
</pre></p><p>The <code>PosZDouble.from</code> factory method will inspect
the value at runtime and return an
<code>Option[PosZDouble]</code>. If the value is valid,
<code>PosZDouble.from</code> will return a
<code>Some[PosZDouble]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; PosZDouble.from(x)
res4: Option[org.scalactic.anyvals.PosZDouble] = Some(PosZDouble(1.1))

scala&gt; val y = -1.1
y: Double = -1.1

scala&gt; PosZDouble.from(y)
res5: Option[org.scalactic.anyvals.PosZDouble] = None
</pre></p><p>The <code>PosZDouble.apply</code> factory method is marked
implicit, so that you can pass literal <code>Double</code>s
into methods that require <code>PosZDouble</code>, and get the
same compile-time checking you get when calling
<code>PosZDouble.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosZDouble): Double = Double.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosZDouble)Double

scala&gt; invert(1.1)
res6: Double = 1.7976931348623157E308

scala&gt; invert(Double.MaxValue)
res8: Double = 0.0

scala&gt; invert(-1.1)
&lt;console&gt;:15: error: PosZDouble.apply can only be invoked on a non-negative (i >= 0.0) floating point literal, like PosZDouble(1.1).
              invert(-1.1)
                     ^

</pre></p><p>This example also demonstrates that the
<code>PosZDouble</code> companion object also defines implicit
widening conversions when a similar conversion is provided in
Scala. This makes it convenient to use a
<code>PosZDouble</code> where a <code>Double</code> is
needed. An example is the subtraction in the body of the
<code>invert</code> method defined above,
<code>Double.MaxValue - pos</code>. Although
<code>Double.MaxValue</code> is a <code>Double</code>, which
has no <code>-</code> method that takes a
<code>PosZDouble</code> (the type of <code>pos</code>), you
can still subtract <code>pos</code>, because the
<code>PosZDouble</code> will be implicitly widened to
<code>Double</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosZFiniteDouble" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosZFiniteDoubleextendsAnyVal" class="anchorToMember"></a><a id="PosZFiniteDouble:PosZFiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZFiniteDouble.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosZFiniteDouble.html" title="An AnyVal for finite non-negative Doubles."><span class="name">PosZFiniteDouble</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite non-negative <code>Double</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite non-negative <code>Double</code>s.</p><p>Because <code>PosZFiniteDouble</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Double</code>, being
boxed only when a <code>Double</code> would have been boxed.</p><p>The <code>PosZFiniteDouble.apply</code> factory method is
implemented in terms of a macro that checks literals for
validity at compile time. Calling
<code>PosZFiniteDouble.apply</code> with a literal
<code>Double</code> value will either produce a valid
<code>PosZFiniteDouble</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosZFiniteDouble(1.1)
res1: org.scalactic.anyvals.PosZFiniteDouble = PosZFiniteDouble(1.1)

scala&gt; PosZFiniteDouble(-1.1)
&lt;console&gt;:14: error: PosZFiniteDouble.apply can only be invoked on a finite non-negative (i >= 0.0 && i != Double.PositiveInfinity) floating point literal, like PosZFiniteDouble(1.1).
              PosZFiniteDouble(-1.1)
                       ^
</pre></p><p><code>PosZFiniteDouble.apply</code> cannot be used if the value
being passed is a variable (<em>i.e.</em>, not a literal),
because the macro cannot determine the validity of variables
at compile time (just literals). If you try to pass a
variable to <code>PosZFiniteDouble.apply</code>, you'll get a
compiler error that suggests you use a different factor
method, <code>PosZFiniteDouble.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1.1
x: Double = 1.1

scala&gt; PosZFiniteDouble(x)
&lt;console&gt;:15: error: PosZFiniteDouble.apply can only be invoked on a floating point literal, like PosZFiniteDouble(1.1). Please use PosZFiniteDouble.from instead.
              PosZFiniteDouble(x)
                       ^
</pre></p><p>The <code>PosZFiniteDouble.from</code> factory method will inspect
the value at runtime and return an
<code>Option[PosZFiniteDouble]</code>. If the value is valid,
<code>PosZFiniteDouble.from</code> will return a
<code>Some[PosZFiniteDouble]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; PosZFiniteDouble.from(x)
res4: Option[org.scalactic.anyvals.PosZFiniteDouble] = Some(PosZFiniteDouble(1.1))

scala&gt; val y = -1.1
y: Double = -1.1

scala&gt; PosZFiniteDouble.from(y)
res5: Option[org.scalactic.anyvals.PosZFiniteDouble] = None
</pre></p><p>The <code>PosZFiniteDouble.apply</code> factory method is marked
implicit, so that you can pass literal <code>Double</code>s
into methods that require <code>PosZFiniteDouble</code>, and get the
same compile-time checking you get when calling
<code>PosZFiniteDouble.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosZFiniteDouble): Double = Double.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosZFiniteDouble)Double

scala&gt; invert(1.1)
res6: Double = 1.7976931348623157E308

scala&gt; invert(Double.MaxValue)
res8: Double = 0.0

scala&gt; invert(-1.1)
&lt;console&gt;:15: error: PosZFiniteDouble.apply can only be invoked on a finite non-negative (i >= 0.0 && i != Double.PositiveInfinity) floating point literal, like PosZFiniteDouble(1.1).
              invert(-1.1)
                     ^

</pre></p><p>This example also demonstrates that the
<code>PosZFiniteDouble</code> companion object also defines implicit
widening conversions when a similar conversion is provided in
Scala. This makes it convenient to use a
<code>PosZFiniteDouble</code> where a <code>Double</code> is
needed. An example is the subtraction in the body of the
<code>invert</code> method defined above,
<code>Double.MaxValue - pos</code>. Although
<code>Double.MaxValue</code> is a <code>Double</code>, which
has no <code>-</code> method that takes a
<code>PosZFiniteDouble</code> (the type of <code>pos</code>), you
can still subtract <code>pos</code>, because the
<code>PosZFiniteDouble</code> will be implicitly widened to
<code>Double</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosZFiniteFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosZFiniteFloatextendsAnyVal" class="anchorToMember"></a><a id="PosZFiniteFloat:PosZFiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZFiniteFloat.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosZFiniteFloat.html" title="An AnyVal for finite non-negative Floats."><span class="name">PosZFiniteFloat</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for finite non-negative <code>Float</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for finite non-negative <code>Float</code>s.</p><p>Because <code>PosZFiniteFloat</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Float</code>, being
boxed only when an <code>Float</code> would have been boxed.</p><p>The <code>PosZFiniteFloat.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>PosZFiniteFloat.apply</code> with a
literal <code>Float</code> value will either produce a valid
<code>PosZFiniteFloat</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosZFiniteFloat(1.1fF)
res0: org.scalactic.anyvals.PosZFiniteFloat = PosZFiniteFloat(1.1f)

scala&gt; PosZFiniteFloat(-1.1fF)
&lt;console&gt;:14: error: PosZFiniteFloat.apply can only be invoked on a finite non-negative (i >= 0.0f && i != Float.PositiveInfinity) floating point literal, like PosZFiniteFloat(1.1fF).
              PosZFiniteFloat(1.1fF)
                      ^
</pre></p><p><code>PosZFiniteFloat.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>PosZFiniteFloat.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>PosZFiniteFloat.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1.1fF
x: Float = 1.1f

scala&gt; PosZFiniteFloat(x)
&lt;console&gt;:15: error: PosZFiniteFloat.apply can only be invoked on a floating point literal, like PosZFiniteFloat(1.1fF). Please use PosZFiniteFloat.from instead.
              PosZFiniteFloat(x)
                      ^
</pre></p><p>The <code>PosZFiniteFloat.from</code> factory method will inspect
the value at runtime and return an
<code>Option[PosZFiniteFloat]</code>. If the value is valid,
<code>PosZFiniteFloat.from</code> will return a
<code>Some[PosZFiniteFloat]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; PosZFiniteFloat.from(x)
res3: Option[org.scalactic.anyvals.PosZFiniteFloat] = Some(PosZFiniteFloat(1.1f))

scala&gt; val y = -1.1fF
y: Float = -1.1f

scala&gt; PosZFiniteFloat.from(y)
res4: Option[org.scalactic.anyvals.PosZFiniteFloat] = None
</pre></p><p>The <code>PosZFiniteFloat.apply</code> factory method is marked
implicit, so that you can pass literal <code>Float</code>s
into methods that require <code>PosZFiniteFloat</code>, and get the
same compile-time checking you get when calling
<code>PosZFiniteFloat.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosZFiniteFloat): Float = Float.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosZFiniteFloat)Float

scala&gt; invert(1.1fF)
res5: Float = 3.4028235E38

scala&gt; invert(Float.MaxValue)
res6: Float = 0.0

scala&gt; invert(-1.1fF)
&lt;console&gt;:15: error: PosZFiniteFloat.apply can only be invoked on a finite non-negative (i >= 0.0f && i != Float.PositiveInfinity) floating point literal, like PosZFiniteFloat(1.1fF).
              invert(0.0F)
                     ^

scala&gt; invert(-1.1fF)
&lt;console&gt;:15: error: PosZFiniteFloat.apply can only be invoked on a finite non-negative (i >= 0.0f && i != Float.PositiveInfinity) floating point literal, like PosZFiniteFloat(1.1fF).
              invert(-1.1fF)
                      ^

</pre></p><p>This example also demonstrates that the <code>PosZFiniteFloat</code>
companion object also defines implicit widening conversions
when no loss of precision will occur. This makes it convenient to use a
<code>PosZFiniteFloat</code> where a <code>Float</code> or wider
type is needed. An example is the subtraction in the body of
the <code>invert</code> method defined above,
<code>Float.MaxValue - pos</code>. Although
<code>Float.MaxValue</code> is a <code>Float</code>, which
has no <code>-</code> method that takes a
<code>PosZFiniteFloat</code> (the type of <code>pos</code>), you can
still subtract <code>pos</code>, because the
<code>PosZFiniteFloat</code> will be implicitly widened to
<code>Float</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosZFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosZFloatextendsAnyVal" class="anchorToMember"></a><a id="PosZFloat:PosZFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZFloat.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosZFloat.html" title="An AnyVal for non-negative Floats."><span class="name">PosZFloat</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-negative <code>Float</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-negative <code>Float</code>s.</p><p>Because <code>PosZFloat</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Float</code>, being
boxed only when an <code>Float</code> would have been boxed.</p><p>The <code>PosZFloat.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>PosZFloat.apply</code> with a
literal <code>Float</code> value will either produce a valid
<code>PosZFloat</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosZFloat(1.1fF)
res0: org.scalactic.anyvals.PosZFloat = PosZFloat(1.1f)

scala&gt; PosZFloat(-1.1fF)
&lt;console&gt;:14: error: PosZFloat.apply can only be invoked on a non-negative (i >= 0.0f) floating point literal, like PosZFloat(1.1fF).
              PosZFloat(1.1fF)
                      ^
</pre></p><p><code>PosZFloat.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>PosZFloat.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>PosZFloat.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1.1fF
x: Float = 1.1f

scala&gt; PosZFloat(x)
&lt;console&gt;:15: error: PosZFloat.apply can only be invoked on a floating point literal, like PosZFloat(1.1fF). Please use PosZFloat.from instead.
              PosZFloat(x)
                      ^
</pre></p><p>The <code>PosZFloat.from</code> factory method will inspect
the value at runtime and return an
<code>Option[PosZFloat]</code>. If the value is valid,
<code>PosZFloat.from</code> will return a
<code>Some[PosZFloat]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; PosZFloat.from(x)
res3: Option[org.scalactic.anyvals.PosZFloat] = Some(PosZFloat(1.1f))

scala&gt; val y = -1.1fF
y: Float = -1.1f

scala&gt; PosZFloat.from(y)
res4: Option[org.scalactic.anyvals.PosZFloat] = None
</pre></p><p>The <code>PosZFloat.apply</code> factory method is marked
implicit, so that you can pass literal <code>Float</code>s
into methods that require <code>PosZFloat</code>, and get the
same compile-time checking you get when calling
<code>PosZFloat.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosZFloat): Float = Float.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosZFloat)Float

scala&gt; invert(1.1fF)
res5: Float = 3.4028235E38

scala&gt; invert(Float.MaxValue)
res6: Float = 0.0

scala&gt; invert(-1.1fF)
&lt;console&gt;:15: error: PosZFloat.apply can only be invoked on a non-negative (i >= 0.0f) floating point literal, like PosZFloat(1.1fF).
              invert(0.0F)
                     ^

scala&gt; invert(-1.1fF)
&lt;console&gt;:15: error: PosZFloat.apply can only be invoked on a non-negative (i >= 0.0f) floating point literal, like PosZFloat(1.1fF).
              invert(-1.1fF)
                      ^

</pre></p><p>This example also demonstrates that the <code>PosZFloat</code>
companion object also defines implicit widening conversions
when no loss of precision will occur. This makes it convenient to use a
<code>PosZFloat</code> where a <code>Float</code> or wider
type is needed. An example is the subtraction in the body of
the <code>invert</code> method defined above,
<code>Float.MaxValue - pos</code>. Although
<code>Float.MaxValue</code> is a <code>Float</code>, which
has no <code>-</code> method that takes a
<code>PosZFloat</code> (the type of <code>pos</code>), you can
still subtract <code>pos</code>, because the
<code>PosZFloat</code> will be implicitly widened to
<code>Float</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosZInt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosZIntextendsAnyVal" class="anchorToMember"></a><a id="PosZInt:PosZInt" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZInt.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosZInt.html" title="An AnyVal for non-negative Ints."><span class="name">PosZInt</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-negative <code>Int</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-negative <code>Int</code>s.</p><p>Because <code>PosZInt</code> is an <code>AnyVal</code> it will usually be
as efficient as an <code>Int</code>, being boxed only when an <code>Int</code>
would have been boxed.</p><p>The <code>PosZInt.apply</code> factory method is implemented in terms of a macro that
checks literals for validity at compile time. Calling <code>PosZInt.apply</code> with
a literal <code>Int</code> value will either produce a valid <code>PosZInt</code> instance
at run time or an error at compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosZInt(42)
res0: org.scalactic.anyvals.PosZInt = PosZInt(42)

scala&gt; PosZInt(-1)
&lt;console&gt;:14: error: PosZInt.apply can only be invoked on a non-negative (i >= 0) literal, like PosZInt(42).
              PosZInt(-1)
                    ^
</pre></p><p><code>PosZInt.apply</code> cannot be used if the value being passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at compile time (just literals). If you try to pass a variable
to <code>PosZInt.apply</code>, you'll get a compiler error that suggests you use a different factor method,
<code>PosZInt.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 1
x: Int = 1

scala&gt; PosZInt(x)
&lt;console&gt;:15: error: PosZInt.apply can only be invoked on a non-negative integer literal, like PosZInt(42). Please use PosZInt.from instead.
              PosZInt(x)
                    ^
</pre></p><p>The <code>PosZInt.from</code> factory method will inspect the value at runtime and return an <code>Option[PosZInt]</code>. If
the value is valid, <code>PosZInt.from</code> will return a <code>Some[PosZInt]</code>, else it will return a <code>None</code>.
Here's an example:</p><p><pre class="stREPL">
scala&gt; PosZInt.from(x)
res3: Option[org.scalactic.anyvals.PosZInt] = Some(PosZInt(1))

scala&gt; val y = 0
y: Int = 0

scala&gt; PosZInt.from(y)
res4: Option[org.scalactic.anyvals.PosZInt] = None
</pre></p><p>The <code>PosZInt.apply</code> factory method is marked implicit, so that you can pass literal <code>Int</code>s
into methods that require <code>PosZInt</code>, and get the same compile-time checking you get when calling
<code>PosZInt.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosZInt): Int = Int.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosZInt)Int

scala&gt; invert(1)
res0: Int = 2147483646

scala&gt; invert(Int.MaxValue)
res1: Int = 0

scala&gt; invert(0)
&lt;console&gt;:15: error: PosZInt.apply can only be invoked on a non-negative (i >= 0) integer literal, like PosZInt(42).
              invert(0)
                     ^

scala&gt; invert(-1)
&lt;console&gt;:15: error: PosZInt.apply can only be invoked on a non-negative (i >= 0) integer literal, like PosZInt(42).
              invert(-1)
                      ^

</pre></p><p>This example also demonstrates that the <code>PosZInt</code> companion object also defines implicit widening conversions
when either no loss of precision will occur or a similar conversion is provided in Scala. (For example, the implicit
conversion from <code>Int</code> to </code>Float</code> in Scala can lose precision.) This makes it convenient to
use a <code>PosZInt</code> where an <code>Int</code> or wider type is needed. An example is the subtraction in the body
of the <code>invert</code> method defined above, <code>Int.MaxValue - pos</code>. Although <code>Int.MaxValue</code> is
an <code>Int</code>, which has no <code>-</code> method that takes a <code>PosZInt</code> (the type of <code>pos</code>),
you can still subtract <code>pos</code>, because the <code>PosZInt</code> will be implicitly widened to <code>Int</code>.</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.PosZLong" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="PosZLongextendsAnyVal" class="anchorToMember"></a><a id="PosZLong:PosZLong" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZLong.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="PosZLong.html" title="An AnyVal for non-negative Longs."><span class="name">PosZLong</span></a><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span><p class="shortcomment cmt">An <code>AnyVal</code> for non-negative <code>Long</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>An <code>AnyVal</code> for non-negative <code>Long</code>s.</p><p>Because <code>PosZLong</code> is an <code>AnyVal</code> it
will usually be as efficient as an <code>Long</code>, being
boxed only when an <code>Long</code> would have been boxed.</p><p>The <code>PosZLong.apply</code> factory method is implemented
in terms of a macro that checks literals for validity at
compile time. Calling <code>PosZLong.apply</code> with a
literal <code>Long</code> value will either produce a valid
<code>PosZLong</code> instance at run time or an error at
compile time. Here's an example:</p><p><pre class="stREPL">
scala&gt; import anyvals._
import anyvals._

scala&gt; PosZLong(42)
res0: org.scalactic.anyvals.PosZLong = PosZLong(42)

scala&gt; PosZLong(-1)
&lt;console&gt;:14: error: PosZLong.apply can only be invoked on a non-negative (i >= 0L) integer literal, like PosZLong(42).
              PosZLong(-1)
                     ^
</pre></p><p><code>PosZLong.apply</code> cannot be used if the value being
passed is a variable (<em>i.e.</em>, not a literal), because
the macro cannot determine the validity of variables at
compile time (just literals). If you try to pass a variable
to <code>PosZLong.apply</code>, you'll get a compiler error
that suggests you use a different factor method,
<code>PosZLong.from</code>, instead:</p><p><pre class="stREPL">
scala&gt; val x = 42L
x: Long = 42

scala&gt; PosZLong(x)
&lt;console&gt;:15: error: PosZLong.apply can only be invoked on an long literal, like PosZLong(42). Please use PosZLong.from instead.
              PosZLong(x)
                     ^
</pre></p><p>The <code>PosZLong.from</code> factory method will inspect the
value at runtime and return an
<code>Option[PosZLong]</code>. If the value is valid,
<code>PosZLong.from</code> will return a
<code>Some[PosZLong]</code>, else it will return a
<code>None</code>.  Here's an example:</p><p><pre class="stREPL">
scala&gt; PosZLong.from(x)
res3: Option[org.scalactic.anyvals.PosZLong] = Some(PosZLong(42))

scala&gt; val y = -1L
y: Long = -1

scala&gt; PosZLong.from(y)
res4: Option[org.scalactic.anyvals.PosZLong] = None
</pre></p><p>The <code>PosZLong.apply</code> factory method is marked
implicit, so that you can pass literal <code>Long</code>s
into methods that require <code>PosZLong</code>, and get the
same compile-time checking you get when calling
<code>PosZLong.apply</code> explicitly. Here's an example:</p><p><pre class="stREPL">
scala&gt; def invert(pos: PosZLong): Long = Long.MaxValue - pos
invert: (pos: org.scalactic.anyvals.PosZLong)Long

scala&gt; invert(1L)
res5: Long = 9223372036854775806

scala&gt; invert(Long.MaxValue)
res6: Long = 0

scala&gt; invert(-1L)
&lt;console&gt;:15: error: PosZLong.apply can only be invoked on a non-negative (i >= 0L) integer literal, like PosZLong(42L).
              invert(-1L)
                     ^

</pre></p><p>This example also demonstrates that the <code>PosZLong</code>
companion object also defines implicit widening conversions
when either no loss of precision will occur or a similar
conversion is provided in Scala. (For example, the implicit
conversion from <code>Long</code> to </code>Double</code> in
Scala can lose precision.) This makes it convenient to use a
<code>PosZLong</code> where a <code>Long</code> or wider type
is needed. An example is the subtraction in the body of the
<code>invert</code> method defined above, <code>Long.MaxValue
- pos</code>. Although <code>Long.MaxValue</code> is a
<code>Long</code>, which has no <code>-</code> method that
takes a <code>PosZLong</code> (the type of <code>pos</code>),
you can still subtract <code>pos</code>, because the
<code>PosZLong</code> will be implicitly widened to
<code>Long</code>.</p></div></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="org.scalactic.anyvals.CompileTimeAssertions" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="CompileTimeAssertions" class="anchorToMember"></a><a id="CompileTimeAssertions:CompileTimeAssertions" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/CompileTimeAssertions$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="CompileTimeAssertions$.html" title="Companion object that facilitates the importing of CompileTimeAssertions members as an alternative to mixing in the trait."><span class="name">CompileTimeAssertions</span></a><span class="result"> extends <a href="CompileTimeAssertions.html" name="org.scalactic.anyvals.CompileTimeAssertions" id="org.scalactic.anyvals.CompileTimeAssertions" class="extype">CompileTimeAssertions</a></span></span><p class="shortcomment cmt">Companion object that facilitates the importing of <code>CompileTimeAssertions</code> members as
an alternative to mixing in the trait.</p></li><li class="indented0 " name="org.scalactic.anyvals.End" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="End" class="anchorToMember"></a><a id="End:End" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/End$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="End$.html" title="Object that can be used as an endpoint for NonEmptyList construction expressions that use the cons (::) operator."><span class="name">End</span></a></span><p class="shortcomment cmt">Object that can be used as an endpoint for <code>NonEmptyList</code> construction expressions
that use the cons (<code>::</code>) operator.</p><div class="fullcomment"><div class="comment cmt"><p>Object that can be used as an endpoint for <code>NonEmptyList</code> construction expressions
that use the cons (<code>::</code>) operator.</p><p>Here's an example:</p><p><pre class="stREPL">
scala&gt; 1 :: 2 :: 3 :: End
res0: org.scalactic.NonEmptyList[Int] = NonEmptyList(1, 2, 3)
</pre></p><p>Note that unlike <code>Nil</code>, which is an instance of <code>List[Nothing]</code>,
<code>End</code> is not an instance of <code>NonEmptyList[Nothing]</code>, because there is
no empty <code>NonEmptyList</code>:</p><p><pre class="stREPL">
scala&gt; Nil.isInstanceOf[List[_]]
res0: Boolean = true

scala&gt; End.isInstanceOf[NonEmptyList[_]]
res1: Boolean = false
</pre>
</p></div></div></li><li class="indented0 " name="org.scalactic.anyvals.FiniteDouble" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="FiniteDouble" class="anchorToMember"></a><a id="FiniteDouble:FiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/FiniteDouble$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="FiniteDouble$.html" title="The companion object for FiniteDouble that offers factory methods that produce FiniteDoubles, implicit widening conversions from FiniteDouble to other numeric types, and maximum and minimum constant values for FiniteDouble."><span class="name">FiniteDouble</span></a></span><p class="shortcomment cmt">The companion object for <code>FiniteDouble</code> that offers
factory methods that produce <code>FiniteDouble</code>s,
implicit widening conversions from <code>FiniteDouble</code> to
other numeric types, and maximum and minimum constant values
for <code>FiniteDouble</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.FiniteFloat" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="FiniteFloat" class="anchorToMember"></a><a id="FiniteFloat:FiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/FiniteFloat$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="FiniteFloat$.html" title="The companion object for FiniteFloat that offers factory methods that produce FiniteFloats, implicit widening conversions from FiniteFloat to other numeric types, and maximum and minimum constant values for FiniteFloat."><span class="name">FiniteFloat</span></a></span><p class="shortcomment cmt">The companion object for <code>FiniteFloat</code> that offers
factory methods that produce <code>FiniteFloat</code>s,
implicit widening conversions from <code>FiniteFloat</code> to
other numeric types, and maximum and minimum constant values
for <code>FiniteFloat</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegDouble" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegDouble" class="anchorToMember"></a><a id="NegDouble:NegDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegDouble$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegDouble$.html" title="The companion object for NegDouble that offers factory methods that produce NegDoubles, implicit widening conversions from NegDouble to other numeric types, and maximum and minimum constant values for NegDouble."><span class="name">NegDouble</span></a></span><p class="shortcomment cmt">The companion object for <code>NegDouble</code> that offers
factory methods that produce <code>NegDouble</code>s,
implicit widening conversions from <code>NegDouble</code> to
other numeric types, and maximum and minimum constant values
for <code>NegDouble</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegFiniteDouble" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegFiniteDouble" class="anchorToMember"></a><a id="NegFiniteDouble:NegFiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegFiniteDouble$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegFiniteDouble$.html" title="The companion object for NegFiniteDouble that offers factory methods that produce NegFiniteDoubles, implicit widening conversions from NegFiniteDouble to other numeric types, and maximum and minimum constant values for NegFiniteDouble."><span class="name">NegFiniteDouble</span></a></span><p class="shortcomment cmt">The companion object for <code>NegFiniteDouble</code> that offers
factory methods that produce <code>NegFiniteDouble</code>s,
implicit widening conversions from <code>NegFiniteDouble</code> to
other numeric types, and maximum and minimum constant values
for <code>NegFiniteDouble</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegFiniteFloat" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegFiniteFloat" class="anchorToMember"></a><a id="NegFiniteFloat:NegFiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegFiniteFloat$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegFiniteFloat$.html" title="The companion object for NegFiniteFloat that offers factory methods that produce NegFiniteFloats, implicit widening conversions from NegFiniteFloat to other numeric types, and maximum and minimum constant values for NegFiniteFloat."><span class="name">NegFiniteFloat</span></a></span><p class="shortcomment cmt">The companion object for <code>NegFiniteFloat</code> that offers
factory methods that produce <code>NegFiniteFloat</code>s,
implicit widening conversions from <code>NegFiniteFloat</code> to
other numeric types, and maximum and minimum constant values
for <code>NegFiniteFloat</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegFloat" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegFloat" class="anchorToMember"></a><a id="NegFloat:NegFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegFloat$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegFloat$.html" title="The companion object for NegFloat that offers factory methods that produce NegFloats, implicit widening conversions from NegFloat to other numeric types, and maximum and minimum constant values for NegFloat."><span class="name">NegFloat</span></a></span><p class="shortcomment cmt">The companion object for <code>NegFloat</code> that offers
factory methods that produce <code>NegFloat</code>s,
implicit widening conversions from <code>NegFloat</code> to
other numeric types, and maximum and minimum constant values
for <code>NegFloat</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegInt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegInt" class="anchorToMember"></a><a id="NegInt:NegInt" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegInt$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegInt$.html" title="The companion object for NegInt that offers factory methods that produce NegInts, implicit widening conversions from NegInt to other numeric types, and maximum and minimum constant values for NegInt."><span class="name">NegInt</span></a></span><p class="shortcomment cmt">The companion object for <code>NegInt</code> that offers factory methods that
produce <code>NegInt</code>s, implicit widening conversions from <code>NegInt</code>
to other numeric types, and maximum and minimum constant values for <code>NegInt</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegLong" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegLong" class="anchorToMember"></a><a id="NegLong:NegLong" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegLong$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegLong$.html" title="The companion object for NegLong that offers factory methods that produce NegLongs, implicit widening conversions from NegLong to other numeric types, and maximum and minimum constant values for NegLong."><span class="name">NegLong</span></a></span><p class="shortcomment cmt">The companion object for <code>NegLong</code> that offers
factory methods that produce <code>NegLong</code>s, implicit
widening conversions from <code>NegLong</code> to other
numeric types, and maximum and minimum constant values for
<code>NegLong</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegZDouble" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegZDouble" class="anchorToMember"></a><a id="NegZDouble:NegZDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZDouble$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegZDouble$.html" title="The companion object for NegZDouble that offers factory methods that produce NegZDoubles, implicit widening conversions from NegZDouble to other numeric types, and maximum and minimum constant values for NegZDouble."><span class="name">NegZDouble</span></a></span><p class="shortcomment cmt">The companion object for <code>NegZDouble</code> that offers
factory methods that produce <code>NegZDouble</code>s,
implicit widening conversions from <code>NegZDouble</code> to
other numeric types, and maximum and minimum constant values
for <code>NegZDouble</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegZFiniteDouble" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegZFiniteDouble" class="anchorToMember"></a><a id="NegZFiniteDouble:NegZFiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZFiniteDouble$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegZFiniteDouble$.html" title="The companion object for NegZFiniteDouble that offers factory methods that produce NegZFiniteDoubles, implicit widening conversions from NegZFiniteDouble to other numeric types, and maximum and minimum constant values for NegZFiniteDouble."><span class="name">NegZFiniteDouble</span></a></span><p class="shortcomment cmt">The companion object for <code>NegZFiniteDouble</code> that offers
factory methods that produce <code>NegZFiniteDouble</code>s,
implicit widening conversions from <code>NegZFiniteDouble</code> to
other numeric types, and maximum and minimum constant values
for <code>NegZFiniteDouble</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegZFiniteFloat" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegZFiniteFloat" class="anchorToMember"></a><a id="NegZFiniteFloat:NegZFiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZFiniteFloat$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegZFiniteFloat$.html" title="The companion object for NegZFiniteFloat that offers factory methods that produce NegZFiniteFloats, implicit widening conversions from NegZFiniteFloat to other numeric types, and maximum and minimum constant values for NegZFiniteFloat."><span class="name">NegZFiniteFloat</span></a></span><p class="shortcomment cmt">The companion object for <code>NegZFiniteFloat</code> that offers
factory methods that produce <code>NegZFiniteFloat</code>s,
implicit widening conversions from <code>NegZFiniteFloat</code> to
other numeric types, and maximum and minimum constant values
for <code>NegZFiniteFloat</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegZFloat" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegZFloat" class="anchorToMember"></a><a id="NegZFloat:NegZFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZFloat$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegZFloat$.html" title="The companion object for NegZFloat that offers factory methods that produce NegZFloats, implicit widening conversions from NegZFloat to other numeric types, and maximum and minimum constant values for NegZFloat."><span class="name">NegZFloat</span></a></span><p class="shortcomment cmt">The companion object for <code>NegZFloat</code> that offers
factory methods that produce <code>NegZFloat</code>s,
implicit widening conversions from <code>NegZFloat</code> to
other numeric types, and maximum and minimum constant values
for <code>NegZFloat</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegZInt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegZInt" class="anchorToMember"></a><a id="NegZInt:NegZInt" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZInt$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegZInt$.html" title="The companion object for NegZInt that offers factory methods that produce NegZInts, implicit widening conversions from NegZInt to other numeric types, and maximum and minimum constant values for NegZInt."><span class="name">NegZInt</span></a></span><p class="shortcomment cmt">The companion object for <code>NegZInt</code> that offers factory methods that
produce <code>NegZInt</code>s, implicit widening conversions from <code>NegZInt</code>
to other numeric types, and maximum and minimum constant values for <code>NegZInt</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NegZLong" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NegZLong" class="anchorToMember"></a><a id="NegZLong:NegZLong" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NegZLong$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NegZLong$.html" title="The companion object for NegZLong that offers factory methods that produce NegZLongs, implicit widening conversions from NegZLong to other numeric types, and maximum and minimum constant values for NegZLong."><span class="name">NegZLong</span></a></span><p class="shortcomment cmt">The companion object for <code>NegZLong</code> that offers
factory methods that produce <code>NegZLong</code>s, implicit
widening conversions from <code>NegZLong</code> to other
numeric types, and maximum and minimum constant values for
<code>NegZLong</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptyArray" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonEmptyArray" class="anchorToMember"></a><a id="NonEmptyArray:NonEmptyArray" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptyArray$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonEmptyArray$.html" title="Companion object for class NonEmptyArray."><span class="name">NonEmptyArray</span></a></span><p class="shortcomment cmt">Companion object for class <code>NonEmptyArray</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptyList" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonEmptyList" class="anchorToMember"></a><a id="NonEmptyList:NonEmptyList" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptyList$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonEmptyList$.html" title="Companion object for class NonEmptyList."><span class="name">NonEmptyList</span></a></span><p class="shortcomment cmt">Companion object for class <code>NonEmptyList</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptyMap" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonEmptyMap" class="anchorToMember"></a><a id="NonEmptyMap:NonEmptyMap" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptyMap$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonEmptyMap$.html" title="Companion object for class NonEmptyMap."><span class="name">NonEmptyMap</span></a></span><p class="shortcomment cmt">Companion object for class <code>NonEmptyMap</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptySet" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonEmptySet" class="anchorToMember"></a><a id="NonEmptySet:NonEmptySet" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptySet$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonEmptySet$.html" title="Companion object for class NonEmptySet."><span class="name">NonEmptySet</span></a></span><p class="shortcomment cmt">Companion object for class <code>NonEmptySet</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptyString" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonEmptyString" class="anchorToMember"></a><a id="NonEmptyString:NonEmptyString" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptyString$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonEmptyString$.html" title="Companion object for class NonEmptyString."><span class="name">NonEmptyString</span></a></span><p class="shortcomment cmt">Companion object for class <code>NonEmptyString</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonEmptyVector" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonEmptyVector" class="anchorToMember"></a><a id="NonEmptyVector:NonEmptyVector" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonEmptyVector$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonEmptyVector$.html" title="Companion object for class NonEmptyVector."><span class="name">NonEmptyVector</span></a></span><p class="shortcomment cmt">Companion object for class <code>NonEmptyVector</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroDouble" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonZeroDouble" class="anchorToMember"></a><a id="NonZeroDouble:NonZeroDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroDouble$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonZeroDouble$.html" title="The companion object for NonZeroDouble that offers factory methods that produce NonZeroDoubles, implicit widening conversions from NonZeroDouble to other numeric types, and maximum and minimum constant values for NonZeroDouble."><span class="name">NonZeroDouble</span></a></span><p class="shortcomment cmt">The companion object for <code>NonZeroDouble</code> that offers
factory methods that produce <code>NonZeroDouble</code>s,
implicit widening conversions from <code>NonZeroDouble</code> to
other numeric types, and maximum and minimum constant values
for <code>NonZeroDouble</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroFiniteDouble" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonZeroFiniteDouble" class="anchorToMember"></a><a id="NonZeroFiniteDouble:NonZeroFiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroFiniteDouble$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonZeroFiniteDouble$.html" title="The companion object for NonZeroFiniteDouble that offers factory methods that produce NonZeroFiniteDoubles, implicit widening conversions from NonZeroFiniteDouble to other numeric types, and maximum and minimum constant values for NonZeroFiniteDouble."><span class="name">NonZeroFiniteDouble</span></a></span><p class="shortcomment cmt">The companion object for <code>NonZeroFiniteDouble</code> that offers
factory methods that produce <code>NonZeroFiniteDouble</code>s,
implicit widening conversions from <code>NonZeroFiniteDouble</code> to
other numeric types, and maximum and minimum constant values
for <code>NonZeroFiniteDouble</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroFiniteFloat" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonZeroFiniteFloat" class="anchorToMember"></a><a id="NonZeroFiniteFloat:NonZeroFiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroFiniteFloat$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonZeroFiniteFloat$.html" title="The companion object for NonZeroFiniteFloat that offers factory methods that produce NonZeroFiniteFloats, implicit widening conversions from NonZeroFiniteFloat to other numeric types, and maximum and minimum constant values for NonZeroFiniteFloat."><span class="name">NonZeroFiniteFloat</span></a></span><p class="shortcomment cmt">The companion object for <code>NonZeroFiniteFloat</code> that offers
factory methods that produce <code>NonZeroFiniteFloat</code>s,
implicit widening conversions from <code>NonZeroFiniteFloat</code> to
other numeric types, and maximum and minimum constant values
for <code>NonZeroFiniteFloat</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroFloat" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonZeroFloat" class="anchorToMember"></a><a id="NonZeroFloat:NonZeroFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroFloat$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonZeroFloat$.html" title="The companion object for NonZeroFloat that offers factory methods that produce NonZeroFloats, implicit widening conversions from NonZeroFloat to other numeric types, and maximum and minimum constant values for NonZeroFloat."><span class="name">NonZeroFloat</span></a></span><p class="shortcomment cmt">The companion object for <code>NonZeroFloat</code> that offers
factory methods that produce <code>NonZeroFloat</code>s,
implicit widening conversions from <code>NonZeroFloat</code> to
other numeric types, and maximum and minimum constant values
for <code>NonZeroFloat</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroInt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonZeroInt" class="anchorToMember"></a><a id="NonZeroInt:NonZeroInt" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroInt$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonZeroInt$.html" title="The companion object for NonZeroInt that offers factory methods that produce NonZeroInts, implicit widening conversions from NonZeroInt to other numeric types, and maximum and minimum constant values for NonZeroInt."><span class="name">NonZeroInt</span></a></span><p class="shortcomment cmt">The companion object for <code>NonZeroInt</code> that offers factory methods that
produce <code>NonZeroInt</code>s, implicit widening conversions from <code>NonZeroInt</code>
to other numeric types, and maximum and minimum constant values for <code>NonZeroInt</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NonZeroLong" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonZeroLong" class="anchorToMember"></a><a id="NonZeroLong:NonZeroLong" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NonZeroLong$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NonZeroLong$.html" title="The companion object for NonZeroLong that offers factory methods that produce NonZeroLongs, implicit widening conversions from NonZeroLong to other numeric types, and maximum and minimum constant values for NonZeroLong."><span class="name">NonZeroLong</span></a></span><p class="shortcomment cmt">The companion object for <code>NonZeroLong</code> that offers
factory methods that produce <code>NonZeroLong</code>s, implicit
widening conversions from <code>NonZeroLong</code> to other
numeric types, and maximum and minimum constant values for
<code>NonZeroLong</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NumericChar" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NumericChar" class="anchorToMember"></a><a id="NumericChar:NumericChar" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NumericChar$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NumericChar$.html" title="The companion object for NumericChar that offers factory methods that produce NumericChars and maximum and minimum constant values for NumericChar."><span class="name">NumericChar</span></a></span><p class="shortcomment cmt">The companion object for <code>NumericChar</code> that offers factory
methods that produce <code>NumericChar</code>s and maximum and minimum
constant values for <code>NumericChar</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.NumericString" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NumericString" class="anchorToMember"></a><a id="NumericString:NumericString" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/NumericString$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NumericString$.html" title="The companion object for NumericString that offers factory methods that produce NumericStrings."><span class="name">NumericString</span></a></span><p class="shortcomment cmt">The companion object for <code>NumericString</code> that offers factory
methods that produce <code>NumericString</code>s.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosDouble" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosDouble" class="anchorToMember"></a><a id="PosDouble:PosDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosDouble$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosDouble$.html" title="The companion object for PosDouble that offers factory methods that produce PosDoubles, implicit widening conversions from PosDouble to other numeric types, and maximum and minimum constant values for PosDouble."><span class="name">PosDouble</span></a></span><p class="shortcomment cmt">The companion object for <code>PosDouble</code> that offers
factory methods that produce <code>PosDouble</code>s,
implicit widening conversions from <code>PosDouble</code> to
other numeric types, and maximum and minimum constant values
for <code>PosDouble</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosFiniteDouble" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosFiniteDouble" class="anchorToMember"></a><a id="PosFiniteDouble:PosFiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosFiniteDouble$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosFiniteDouble$.html" title="The companion object for PosFiniteDouble that offers factory methods that produce PosFiniteDoubles, implicit widening conversions from PosFiniteDouble to other numeric types, and maximum and minimum constant values for PosFiniteDouble."><span class="name">PosFiniteDouble</span></a></span><p class="shortcomment cmt">The companion object for <code>PosFiniteDouble</code> that offers
factory methods that produce <code>PosFiniteDouble</code>s,
implicit widening conversions from <code>PosFiniteDouble</code> to
other numeric types, and maximum and minimum constant values
for <code>PosFiniteDouble</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosFiniteFloat" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosFiniteFloat" class="anchorToMember"></a><a id="PosFiniteFloat:PosFiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosFiniteFloat$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosFiniteFloat$.html" title="The companion object for PosFiniteFloat that offers factory methods that produce PosFiniteFloats, implicit widening conversions from PosFiniteFloat to other numeric types, and maximum and minimum constant values for PosFiniteFloat."><span class="name">PosFiniteFloat</span></a></span><p class="shortcomment cmt">The companion object for <code>PosFiniteFloat</code> that offers
factory methods that produce <code>PosFiniteFloat</code>s,
implicit widening conversions from <code>PosFiniteFloat</code> to
other numeric types, and maximum and minimum constant values
for <code>PosFiniteFloat</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosFloat" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosFloat" class="anchorToMember"></a><a id="PosFloat:PosFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosFloat$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosFloat$.html" title="The companion object for PosFloat that offers factory methods that produce PosFloats, implicit widening conversions from PosFloat to other numeric types, and maximum and minimum constant values for PosFloat."><span class="name">PosFloat</span></a></span><p class="shortcomment cmt">The companion object for <code>PosFloat</code> that offers
factory methods that produce <code>PosFloat</code>s,
implicit widening conversions from <code>PosFloat</code> to
other numeric types, and maximum and minimum constant values
for <code>PosFloat</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosInt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosInt" class="anchorToMember"></a><a id="PosInt:PosInt" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosInt$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosInt$.html" title="The companion object for PosInt that offers factory methods that produce PosInts, implicit widening conversions from PosInt to other numeric types, and maximum and minimum constant values for PosInt."><span class="name">PosInt</span></a></span><p class="shortcomment cmt">The companion object for <code>PosInt</code> that offers factory methods that
produce <code>PosInt</code>s, implicit widening conversions from <code>PosInt</code>
to other numeric types, and maximum and minimum constant values for <code>PosInt</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosLong" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosLong" class="anchorToMember"></a><a id="PosLong:PosLong" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosLong$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosLong$.html" title="The companion object for PosLong that offers factory methods that produce PosLongs, implicit widening conversions from PosLong to other numeric types, and maximum and minimum constant values for PosLong."><span class="name">PosLong</span></a></span><p class="shortcomment cmt">The companion object for <code>PosLong</code> that offers
factory methods that produce <code>PosLong</code>s, implicit
widening conversions from <code>PosLong</code> to other
numeric types, and maximum and minimum constant values for
<code>PosLong</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosZDouble" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosZDouble" class="anchorToMember"></a><a id="PosZDouble:PosZDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZDouble$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosZDouble$.html" title="The companion object for PosZDouble that offers factory methods that produce PosZDoubles, implicit widening conversions from PosZDouble to other numeric types, and maximum and minimum constant values for PosZDouble."><span class="name">PosZDouble</span></a></span><p class="shortcomment cmt">The companion object for <code>PosZDouble</code> that offers
factory methods that produce <code>PosZDouble</code>s,
implicit widening conversions from <code>PosZDouble</code> to
other numeric types, and maximum and minimum constant values
for <code>PosZDouble</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosZFiniteDouble" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosZFiniteDouble" class="anchorToMember"></a><a id="PosZFiniteDouble:PosZFiniteDouble" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZFiniteDouble$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosZFiniteDouble$.html" title="The companion object for PosZFiniteDouble that offers factory methods that produce PosZFiniteDoubles, implicit widening conversions from PosZFiniteDouble to other numeric types, and maximum and minimum constant values for PosZFiniteDouble."><span class="name">PosZFiniteDouble</span></a></span><p class="shortcomment cmt">The companion object for <code>PosZFiniteDouble</code> that offers
factory methods that produce <code>PosZFiniteDouble</code>s,
implicit widening conversions from <code>PosZFiniteDouble</code> to
other numeric types, and maximum and minimum constant values
for <code>PosZFiniteDouble</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosZFiniteFloat" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosZFiniteFloat" class="anchorToMember"></a><a id="PosZFiniteFloat:PosZFiniteFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZFiniteFloat$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosZFiniteFloat$.html" title="The companion object for PosZFiniteFloat that offers factory methods that produce PosZFiniteFloats, implicit widening conversions from PosZFiniteFloat to other numeric types, and maximum and minimum constant values for PosZFiniteFloat."><span class="name">PosZFiniteFloat</span></a></span><p class="shortcomment cmt">The companion object for <code>PosZFiniteFloat</code> that offers
factory methods that produce <code>PosZFiniteFloat</code>s,
implicit widening conversions from <code>PosZFiniteFloat</code> to
other numeric types, and maximum and minimum constant values
for <code>PosZFiniteFloat</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosZFloat" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosZFloat" class="anchorToMember"></a><a id="PosZFloat:PosZFloat" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZFloat$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosZFloat$.html" title="The companion object for PosZFloat that offers factory methods that produce PosZFloats, implicit widening conversions from PosZFloat to other numeric types, and maximum and minimum constant values for PosZFloat."><span class="name">PosZFloat</span></a></span><p class="shortcomment cmt">The companion object for <code>PosZFloat</code> that offers
factory methods that produce <code>PosZFloat</code>s,
implicit widening conversions from <code>PosZFloat</code> to
other numeric types, and maximum and minimum constant values
for <code>PosZFloat</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosZInt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosZInt" class="anchorToMember"></a><a id="PosZInt:PosZInt" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZInt$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosZInt$.html" title="The companion object for PosZInt that offers factory methods that produce PosZInts, implicit widening conversions from PosZInt to other numeric types, and maximum and minimum constant values for PosZInt."><span class="name">PosZInt</span></a></span><p class="shortcomment cmt">The companion object for <code>PosZInt</code> that offers factory methods that
produce <code>PosZInt</code>s, implicit widening conversions from <code>PosZInt</code>
to other numeric types, and maximum and minimum constant values for <code>PosZInt</code>.</p></li><li class="indented0 " name="org.scalactic.anyvals.PosZLong" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PosZLong" class="anchorToMember"></a><a id="PosZLong:PosZLong" class="anchorToMember"></a> <span class="permalink"><a href="../../../org/scalactic/anyvals/PosZLong$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PosZLong$.html" title="The companion object for PosZLong that offers factory methods that produce PosZLongs, implicit widening conversions from PosZLong to other numeric types, and maximum and minimum constant values for PosZLong."><span class="name">PosZLong</span></a></span><p class="shortcomment cmt">The companion object for <code>PosZLong</code> that offers
factory methods that produce <code>PosZLong</code>s, implicit
widening conversions from <code>PosZLong</code> to other
numeric types, and maximum and minimum constant values for
<code>PosZLong</code>.</p></li></ol></div></div><div id="inheritedMembers"></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
