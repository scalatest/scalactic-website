<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Scalactic 3.2.8  - org.scalactic.Or</title><meta content="Scalactic 3.2.8 - org.scalactic.Or" name="description"/><meta content="Scalactic 3.2.8 org.scalactic.Or" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title">Scalactic 3.2.8<span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.org" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="org" class="anchorToMember"></a><a id="org:org" class="anchorToMember"></a> <span class="permalink"><a href="../../org/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">org</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="org.scalactic" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scalactic" class="anchorToMember"></a><a id="scalactic:scalactic" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">scalactic</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="org" id="org" class="extype">org</a></dd></dl></div></li><li class="indented3 " name="org.scalactic.anyvals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="anyvals" class="anchorToMember"></a><a id="anyvals:anyvals" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/anyvals/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="anyvals/index.html" title=""><span class="name">anyvals</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="org.scalactic" id="org.scalactic" class="extype">scalactic</a></dd></dl></div></li><li class="indented3 " name="org.scalactic.exceptions" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="exceptions" class="anchorToMember"></a><a id="exceptions:exceptions" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/exceptions/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="exceptions/index.html" title=""><span class="name">exceptions</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="org.scalactic" id="org.scalactic" class="extype">scalactic</a></dd></dl></div></li><li class="indented3 " name="org.scalactic.source" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="source" class="anchorToMember"></a><a id="source:source" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/source/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="source/index.html" title=""><span class="name">source</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="org.scalactic" id="org.scalactic" class="extype">scalactic</a></dd></dl></div></li><li class="current-entities indented2"><span class="separator"></span> <a href="AbstractStringUniformity.html" title="Convenience base trait for string Uniformitys." class="trait"></a><a href="AbstractStringUniformity.html" title="Convenience base trait for string Uniformitys.">AbstractStringUniformity</a></li><li class="current-entities indented2"><a href="Accumulation$.html" title="Companion object to trait Accumulation that allows Accumulation's members to be imported rather than mixed in, and also contains nested traits used by implicit conversions declared in trait Accumulations." class="object"></a> <a href="Accumulation.html" title="Provides mechanisms that enable errors to be accumulated in &amp;ldquo;accumulating Ors,&amp;rdquo; Ors whose Bad type is an Every." class="trait"></a><a href="Accumulation.html" title="Provides mechanisms that enable errors to be accumulated in &amp;ldquo;accumulating Ors,&amp;rdquo; Ors whose Bad type is an Every.">Accumulation</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="AccumulationLowPriorityImplicits.html" title="" class="trait"></a><a href="AccumulationLowPriorityImplicits.html" title="">AccumulationLowPriorityImplicits</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Bad.html" title="Contains a &amp;ldquo;bad&amp;rdquo; value." class="class"></a><a href="Bad.html" title="Contains a &amp;ldquo;bad&amp;rdquo; value.">Bad</a></li><li class="current-entities indented2"><a href="Bool$.html" title="Bool companion object that provides factory methods to create different sub types of Bool" class="object"></a> <a href="Bool.html" title="A trait that represent a rich-featured boolean value, which includes the following members:" class="trait"></a><a href="Bool.html" title="A trait that represent a rich-featured boolean value, which includes the following members:">Bool</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="CanEqual.html" title="Abstract class used to enforce type constraints for equality checks." class="class"></a><a href="CanEqual.html" title="Abstract class used to enforce type constraints for equality checks.">CanEqual</a></li><li class="current-entities indented2"><a href="Catcher$.html" title="Companion object for Catcher that provides a factory method for creating Throwable extractors." class="object"></a> <a href="Catcher.html" title="Convenience class for extractors that match and return Throwables based on a type and Boolean condition." class="class"></a><a href="Catcher.html" title="Convenience class for extractors that match and return Throwables based on a type and Boolean condition.">Catcher</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="DefaultEquality$.html" title="" class="object"></a><a href="DefaultEquality$.html" title="">DefaultEquality</a></li><li class="current-entities indented2"><a href="Equality$.html" title="Companion object for trait Equality that provides factory methods for producing Equality instances." class="object"></a> <a href="Equality.html" title="Defines a custom way to determine equality for a type when compared with another value of type Any." class="trait"></a><a href="Equality.html" title="Defines a custom way to determine equality for a type when compared with another value of type Any.">Equality</a></li><li class="current-entities indented2"><a href="Equivalence$.html" title="Companion object for trait Equivalence that provides a factory method for producing default Equivalence instances." class="object"></a> <a href="Equivalence.html" title="Defines a custom way to determine equality for a type when compared with another value of the same type." class="trait"></a><a href="Equivalence.html" title="Defines a custom way to determine equality for a type when compared with another value of the same type.">Equivalence</a></li><li class="current-entities indented2"><a href="Every$.html" title="Companion object for abstract class Every." class="object"></a> <a href="Every.html" title="An ordered, immutable, non-empty collection of elements." class="class"></a><a href="Every.html" title="An ordered, immutable, non-empty collection of elements.">Every</a></li><li class="current-entities indented2"><a href="Explicitly$.html" title="Companion object for Explicitly, which enables the Scalactic explicitly DSL to be imported rather than mixed in, like this:" class="object"></a> <a href="Explicitly.html" title="Provides ScalaTest's &amp;ldquo;explicitly DSL,&amp;rdquo; which facilitates the explicit specification of an Equality[T] or a Uniformity[T] where Equality[T] is taken implicitly." class="trait"></a><a href="Explicitly.html" title="Provides ScalaTest's &amp;ldquo;explicitly DSL,&amp;rdquo; which facilitates the explicit specification of an Equality[T] or a Uniformity[T] where Equality[T] is taken implicitly.">Explicitly</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Fail.html" title="Indicates a validation failed, describing the failure with a contained error value." class="class"></a><a href="Fail.html" title="Indicates a validation failed, describing the failure with a contained error value.">Fail</a></li><li class="current-entities indented2"><a href="FutureSugar$.html" title="Companion object for FutureSugar enabling its members to be imported as an alternative to mixing them in." class="object"></a> <a href="FutureSugar.html" title="Trait providing an implicit class that adds a validating method to Future, which takes one or more validation functions and returns either the same Future if either the Future had already failed or its value passes all the functions, or ValidationFailedException containing an error message describing the first validation that failed." class="trait"></a><a href="FutureSugar.html" title="Trait providing an implicit class that adds a validating method to Future, which takes one or more validation functions and returns either the same Future if either the Future had already failed or its value passes all the functions, or ValidationFailedException containing an error message describing the first validation that failed.">FutureSugar</a></li><li class="current-entities indented2"><a href="Good$.html" title="Companion object for Good that offers, in addition to the standard factory method for Good that takes single &amp;ldquo;good&amp;rdquo; type, an parameterless apply used to narrow the Good type when creating a Bad." class="object"></a> <a href="Good.html" title="Contains a &amp;ldquo;good&amp;rdquo; value." class="class"></a><a href="Good.html" title="Contains a &amp;ldquo;good&amp;rdquo; value.">Good</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="LowPriorityTypeCheckedConstraint.html" title="Provides an implicit conversion that will be applied only if a higher-priority implicit conversion declared a subtrait is not applicable." class="trait"></a><a href="LowPriorityTypeCheckedConstraint.html" title="Provides an implicit conversion that will be applied only if a higher-priority implicit conversion declared a subtrait is not applicable.">LowPriorityTypeCheckedConstraint</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Many.html" title="An Every that contains two or more elements." class="class"></a><a href="Many.html" title="An Every that contains two or more elements.">Many</a></li><li class="current-entities indented2"><a href="MapEqualityConstraints$.html" title="Companion object that facilitates the importing of MapEqualityConstraints members as an alternative to mixing it in." class="object"></a> <a href="MapEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Maps to one that more closely matches Scala's approach to Map equality." class="trait"></a><a href="MapEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Maps to one that more closely matches Scala's approach to Map equality.">MapEqualityConstraints</a></li><li class="current-entities indented2"><a href="NormMethods$.html" title="Companion object for NormMethods enabling its members to be imported as an alternative to mixing them in." class="object"></a> <a href="NormMethods.html" title="Provides an implicit conversion that allows norm to be invoked on any value of type T for which an implicit Normalization[T] exists." class="trait"></a><a href="NormMethods.html" title="Provides an implicit conversion that allows norm to be invoked on any value of type T for which an implicit Normalization[T] exists.">NormMethods</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Normalization.html" title="Defines a custom way to normalize instances of a type." class="trait"></a><a href="Normalization.html" title="Defines a custom way to normalize instances of a type.">Normalization</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="NormalizingEquality.html" title="An Equality[A] implementation that determines the equality of two objects by normalizing one or both objects, then comparing the results using an &amp;ldquo;after normalization&amp;rdquo; equality referenced from the afterNormalizationEquality  member." class="trait"></a><a href="NormalizingEquality.html" title="An Equality[A] implementation that determines the equality of two objects by normalizing one or both objects, then comparing the results using an &amp;ldquo;after normalization&amp;rdquo; equality referenced from the afterNormalizationEquality  member.">NormalizingEquality</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="NormalizingEquivalence.html" title="An Equivalence[A] implementation that determines the equality of two objects by normalizing one or both objects, then comparing the results using an &amp;ldquo;after normalization&amp;rdquo; Equivalence referenced from the afterNormalizationEquivalence  member." class="trait"></a><a href="NormalizingEquivalence.html" title="An Equivalence[A] implementation that determines the equality of two objects by normalizing one or both objects, then comparing the results using an &amp;ldquo;after normalization&amp;rdquo; Equivalence referenced from the afterNormalizationEquivalence  member.">NormalizingEquivalence</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="One.html" title="An Every that contains exactly one element." class="class"></a><a href="One.html" title="An Every that contains exactly one element.">One</a></li><li class="current-entities indented2"><a href="OptionSugar$.html" title="Companion object for OptionSugar enabling its members to be imported as an alternative to mixing them in." class="object"></a> <a href="OptionSugar.html" title="Trait providing an implicit class that adds a toOr method to Option, which converts Some to Good, None to Bad." class="trait"></a><a href="OptionSugar.html" title="Trait providing an implicit class that adds a toOr method to Option, which converts Some to Good, None to Bad.">OptionSugar</a></li><li class="current-entities indented2"><a href="Or$.html" title="The companion object for Or providing factory methods for creating Ors from Eithers and Trys." class="object"></a> <a href="" title="Represents a value that is one of two possible types, with one type being &amp;ldquo;good&amp;rdquo; and the other &amp;ldquo;bad.&amp;rdquo;" class="class"></a><a href="" title="Represents a value that is one of two possible types, with one type being &amp;ldquo;good&amp;rdquo; and the other &amp;ldquo;bad.&amp;rdquo;">Or</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Pass$.html" title="Indicates a validation succeeded." class="object"></a><a href="Pass$.html" title="Indicates a validation succeeded.">Pass</a></li><li class="current-entities indented2"><a href="Prettifier$.html" title="Companion object for Prettifier that provides a default Prettifier implementation." class="object"></a> <a href="Prettifier.html" title="A function that given any object will produce a &amp;ldquo;pretty&amp;rdquo; string representation of that object, where &amp;ldquo;pretty&amp;rdquo; is in the eye of the implementer." class="trait"></a><a href="Prettifier.html" title="A function that given any object will produce a &amp;ldquo;pretty&amp;rdquo; string representation of that object, where &amp;ldquo;pretty&amp;rdquo; is in the eye of the implementer.">Prettifier</a></li><li class="current-entities indented2"><a href="PrettyMethods$.html" title="Companion object for trait PrettyMethods enabling its members to be imported as an alternative to mixing them in." class="object"></a> <a href="PrettyMethods.html" title="Provides an implicit conversion that enables pretty to be invoked on any object, to transform that object into a String representation." class="trait"></a><a href="PrettyMethods.html" title="Provides an implicit conversion that enables pretty to be invoked on any object, to transform that object into a String representation.">PrettyMethods</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="PrettyPair.html" title="" class="class"></a><a href="PrettyPair.html" title="">PrettyPair</a></li><li class="current-entities indented2"><a href="Requirements$.html" title="Companion object that facilitates the importing of Requirements members as an alternative to mixing it in." class="object"></a> <a href="Requirements.html" title="Trait that contains require, and requireState, and requireNonNull methods for checking pre-conditions that give descriptive error messages extracted via a macro." class="trait"></a><a href="Requirements.html" title="Trait that contains require, and requireState, and requireNonNull methods for checking pre-conditions that give descriptive error messages extracted via a macro.">Requirements</a></li><li class="current-entities indented2"><a href="SeqEqualityConstraints$.html" title="Companion object that facilitates the importing of SeqEqualityConstraints members as an alternative to mixing it in." class="object"></a> <a href="SeqEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Seqs to one that more closely matches Scala's approach to Seq equality." class="trait"></a><a href="SeqEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Seqs to one that more closely matches Scala's approach to Seq equality.">SeqEqualityConstraints</a></li><li class="current-entities indented2"><a href="SetEqualityConstraints$.html" title="Companion object that facilitates the importing of SetEqualityConstraints members as an alternative to mixing it in." class="object"></a> <a href="SetEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Sets to one that more closely matches Scala's approach to Set equality." class="trait"></a><a href="SetEqualityConstraints.html" title="Provides an implicit method that loosens the equality constraint defined by TypeCheckedTripleEquals or ConversionCheckedTripleEquals for Scala Sets to one that more closely matches Scala's approach to Set equality.">SetEqualityConstraints</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Snapshot.html" title="Case class that stores the name and value of a variable or expression." class="class"></a><a href="Snapshot.html" title="Case class that stores the name and value of a variable or expression.">Snapshot</a></li><li class="current-entities indented2"><a href="SnapshotSeq$.html" title="" class="object"></a> <a href="SnapshotSeq.html" title="An IndexedSeq[Snapshot] providing toString and lines methods that can be useful for debug and log messages about program state." class="class"></a><a href="SnapshotSeq.html" title="An IndexedSeq[Snapshot] providing toString and lines methods that can be useful for debug and log messages about program state.">SnapshotSeq</a></li><li class="current-entities indented2"><a href="Snapshots$.html" title="Companion object that facilitates the importing of Snapshots members as an alternative to mixing it in." class="object"></a> <a href="Snapshots.html" title="Trait that provides a snap method that takes one or more arguments and results in a SnapshotSeq, whose toString lists the names and values of each argument." class="trait"></a><a href="Snapshots.html" title="Trait that provides a snap method that takes one or more arguments and results in a SnapshotSeq, whose toString lists the names and values of each argument.">Snapshots</a></li><li class="current-entities indented2"><a href="StringNormalizations$.html" title="Companion object to trait StringNormalizations that provides an alternative to mixing it in." class="object"></a> <a href="StringNormalizations.html" title="Provides methods that produce Uniformity[String] instances for various ways to normalize strings for equality comparisons." class="trait"></a><a href="StringNormalizations.html" title="Provides methods that produce Uniformity[String] instances for various ways to normalize strings for equality comparisons.">StringNormalizations</a></li><li class="current-entities indented2"><a href="TimesOnInt$.html" title="Companion object that facilitates the importing of TimesOnInt members as an alternative to mixing it in." class="object"></a> <a href="TimesOnInt.html" title="Trait providing an implicit conversion that adds a times method to Ints that will repeat a given side-effecting operation multiple times." class="trait"></a><a href="TimesOnInt.html" title="Trait providing an implicit conversion that adds a times method to Ints that will repeat a given side-effecting operation multiple times.">TimesOnInt</a></li><li class="current-entities indented2"><a href="Tolerance$.html" title="Companion object to trait Tolerance that facilitates the importing of Tolerance members as an alternative to mixing it in." class="object"></a> <a href="Tolerance.html" title="Trait containing an implicit conversion that adds a +- method to Numeric types, which enables spreads to be expressed in terms of a pivot and tolerance." class="trait"></a><a href="Tolerance.html" title="Trait containing an implicit conversion that adds a +- method to Numeric types, which enables spreads to be expressed in terms of a pivot and tolerance.">Tolerance</a></li><li class="current-entities indented2"><a href="TolerantNumerics$.html" title="Companion object for TolerantNumerics that enables its members to be imported as an alternative to mixing them in." class="object"></a> <a href="TolerantNumerics.html" title="Provides Equality and Equivalence instances for Numeric types that compare for equality with a given tolerance." class="trait"></a><a href="TolerantNumerics.html" title="Provides Equality and Equivalence instances for Numeric types that compare for equality with a given tolerance.">TolerantNumerics</a></li><li class="current-entities indented2"><a href="TraversableEqualityConstraints$.html" title="Companion object that facilitates the importing of TraversableEqualityConstraints members as an alternative to mixing it in." class="object"></a> <a href="TraversableEqualityConstraints.html" title="Provides three implicit methods that loosen the equality constraint defined by TypeCheckedTripleEquals for Scala Traversables to one that more closely matches Scala's approach to Traversable equality." class="trait"></a><a href="TraversableEqualityConstraints.html" title="Provides three implicit methods that loosen the equality constraint defined by TypeCheckedTripleEquals for Scala Traversables to one that more closely matches Scala's approach to Traversable equality.">TraversableEqualityConstraints</a></li><li class="current-entities indented2"><a href="TripleEquals$.html" title="Companion object to trait TripleEquals that facilitates the importing of TripleEquals members as an alternative to mixing it in." class="object"></a> <a href="TripleEquals.html" title="Provides === and !== operators that return Boolean, delegate the equality determination to an Equality type class, and require no relationship between the types of the two values compared." class="trait"></a><a href="TripleEquals.html" title="Provides === and !== operators that return Boolean, delegate the equality determination to an Equality type class, and require no relationship between the types of the two values compared.">TripleEquals</a></li><li class="current-entities indented2"><a href="TripleEqualsSupport$.html" title="" class="object"></a> <a href="TripleEqualsSupport.html" title="Trait that defines abstract methods used to enforce compile-time type constraints for equality comparisons, and defines === and !== operators used by matchers." class="trait"></a><a href="TripleEqualsSupport.html" title="Trait that defines abstract methods used to enforce compile-time type constraints for equality comparisons, and defines === and !== operators used by matchers.">TripleEqualsSupport</a></li><li class="current-entities indented2"><a href="TrySugar$.html" title="Companion object for TrySugar enabling its members to be imported as an alternative to mixing them in." class="object"></a> <a href="TrySugar.html" title="Trait providing an implicit class that adds a toOr method to Try, which converts Success to Good, and Failure to Bad, as well as a validating method, which takes one or more validation functions and returns either the same Try if either the Try had already failed or its value passes all the functions, or ValidationFailedException containing an error message describing the first validation that failed." class="trait"></a><a href="TrySugar.html" title="Trait providing an implicit class that adds a toOr method to Try, which converts Success to Good, and Failure to Bad, as well as a validating method, which takes one or more validation functions and returns either the same Try if either the Try had already failed or its value passes all the functions, or ValidationFailedException containing an error message describing the first validation that failed.">TrySugar</a></li><li class="current-entities indented2"><a href="TypeCheckedTripleEquals$.html" title="Companion object to trait TypeCheckedTripleEquals that facilitates the importing of TypeCheckedTripleEquals members as an alternative to mixing it in." class="object"></a> <a href="TypeCheckedTripleEquals.html" title="Provides === and !== operators that return Boolean, delegate the equality determination to an Equality type class, and require the types of the two values compared to be in a subtype/supertype relationship." class="trait"></a><a href="TypeCheckedTripleEquals.html" title="Provides === and !== operators that return Boolean, delegate the equality determination to an Equality type class, and require the types of the two values compared to be in a subtype/supertype relationship.">TypeCheckedTripleEquals</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Uniformity.html" title="Defines a custom way to normalize instances of a type that can also handle normalization of that type when passed as Any." class="trait"></a><a href="Uniformity.html" title="Defines a custom way to normalize instances of a type that can also handle normalization of that type when passed as Any.">Uniformity</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Validation.html" title="Represents the result of a validation, either the object Pass if the validation succeeded, else an instance of Fail containing an error value describing the validation failure." class="trait"></a><a href="Validation.html" title="Represents the result of a validation, either the object Pass if the validation succeeded, else an instance of Fail containing an error value describing the validation failure.">Validation</a></li></ul></div></div><div id="content"><body class="class type">

<!-- Top of doc.scalactic.org [javascript] -->

<script type="text/javascript">

var rnd = window.rnd || Math.floor(Math.random()*10e6);

var pid204569 = window.pid204569 || rnd;

var plc204569 = window.plc204569 || 0;

var abkw = window.abkw || '';

var absrc = 'https://servedbyadbutler.com/adserve/;ID=167933;size=468x60;setID=204569;type=js;sw='+screen.width+';sh='+screen.height+';spr='+window.devicePixelRatio+';kw='+abkw+';pid='+pid204569+';place='+(plc204569++)+';rnd='+rnd+';click=CLICK_MACRO_PLACEHOLDER';

document.write('<scr'+'ipt src="'+absrc+'" type="text/javascript"></scr'+'ipt>');

</script>
<div id="definition"><a href="Or$.html" title="See companion object"><div class="big-circle class-companion-object">c</div></a><p id="owner"><a href="../index.html" name="org" id="org" class="extype">org</a>.<a href="index.html" name="org.scalactic" id="org.scalactic" class="extype">scalactic</a></p><h1><a href="Or$.html" title="See companion object">Or</a><span class="permalink"><a href="../../org/scalactic/Or.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"><div>Companion <a href="Or$.html" title="See companion object">object Or</a></div></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier">sealed abstract </span> <span class="kind">class</span></span> <span class="symbol"><span class="name">Or</span><span class="tparams">[<span name="G">+G</span>, <span name="B">+B</span>]</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Represents a value that is one of two possible types, with one type being &ldquo;good&rdquo; and
the other &ldquo;bad.&rdquo;</p><p>An <code>Or</code> will either be a &ldquo;good&rdquo; value wrapped in an instance of
<a href="Good.html"><code>Good</code></a> or a &ldquo;bad&rdquo; value wrapped in an instance
of <a href="Bad.html"><code>Bad</code></a>.</p><h4> The motivation for <code>Or</code> </h4><p><code>Or</code> differs from Scala's <code>Either</code> type in that
<code>Either</code> treats both its <code>Left</code> and <code>Right</code> alternatives in an identical manner, whereas
<code>Or</code> treats its two alternatives differently: it favors
<code>Good</code> over <code>Bad</code>.
Because of this, it is more convenient to work with <code>Or</code>s
when you prefer one alternative over the other; for example, if one alternative represents a valid result
and another represents an error.</p><p>To illustrate, imagine you want to create instances this <code>Person</code> class from user input strings:</p><p><pre class="stHighlighted">
<span class="stReserved">case</span> <span class="stReserved">class</span> <span class="stType">Person</span>(name: <span class="stType">String</span>, age: <span class="stType">Int</span>)
</pre></p><p>You might write a method that parses the name from user input string and returns an
<code>Option[String]</code>: <code>None</code> if the string is empty or blank, else the
trimmed string wrapped in a <code>Some</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">Option[String]</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Some</span>(trimmed) <span class="stReserved">else</span> <span class="stType">None</span>
}
</pre></p><p>You might also write a method that parses the age from user input string and returns an
<code>Option[Int]</code>: <code>None</code> if either the string is not a valid integer or
it is a negative integer, else the string converted to an integer wrapped in a <code>Some</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Option[Int]</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Some</span>(age) <span class="stReserved">else</span> <span class="stType">None</span>
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">None</span>
  }
}
</pre></p><p>With these building blocks you could write a method that parses name and age input
strings and returns either a <code>Person</code>, wrapped in a <code>Some</code>, or
<code>None</code> if either the name or age, or both, was invalid:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Option[Person]</span> =
  <span class="stReserved">for</span> {
    name &lt;- parseName(inputName)
    age &lt;- parseAge(inputAge)
  } <span class="stReserved">yield</span> <span class="stType">Person</span>(name, age)
</pre></p><p>Here are some examples of invoking <code>parsePerson</code>:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Some(Person(Bridget Jones,29))</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: None</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: None</span>
<br/>parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: None</span>
</pre></p><p>Now imagine you want to give an error message back if the user's input is invalid.
You might rewrite the parsing methods to return an <code>Either</code> instead. In this
case, the desired result is a valid name or age, which by convention should be placed
on the right of the <code>Either</code>. The left will be a <code>String</code> error
message. Here's the new <code>parseName</code> function, which returns an <code>Either[String, String]</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">Either[String, String]</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Right</span>(trimmed) <span class="stReserved">else</span> <span class="stType">Left</span>(s<span class="stQuotedString">""""${input}" is not a valid name"""</span>)
}
</pre></p><p>And here's the new <code>parseAge</code> function, which returns an <code>Either[String, Int]</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Either[String, Int]</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Right</span>(age) <span class="stReserved">else</span> <span class="stType">Left</span>(s<span class="stQuotedString">""""${age}" is not a valid age"""</span>)
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">Left</span>(s<span class="stQuotedString">""""${input}" is not a valid integer"""</span>)
  }
}
</pre></p><p>The new <code>parsePerson</code> method will return an <code>Either[String, Person]</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Either[String, Person]</span> =
  <span class="stReserved">for</span> {
    name &lt;- parseName(inputName).right
    age &lt;- parseAge(inputAge).right
  } <span class="stReserved">yield</span> <span class="stType">Person</span>(name, age)
</pre></p><p>Note that <code>Either</code> requires you to add <code>.right</code>
at the end of each generator in the <code>for</code> expression. Although the convention is to place the
valid result on the right, you must explicitly (and repetitively) indicate that you've done so by transforming
the <code>Either</code> to a <code>RightProjection</code> by invoking <code>.right</code> at each step.
Given this implementation, the <code>parsePerson</code> method will now short-circuit at the first sign
of trouble (as it did when we used an <code>Option</code>), but you now get the first error message returned
in a <code>Left</code>. Here are some examples:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Right(Person(Bridget Jones,29))</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Left("" is not a valid integer)</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: Left("-29" is not a valid age)</span>
<br/>parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Left("" is not a valid name)</span>
</pre></p><h4> An <code>Either</code> with &ldquo;attitude&rdquo; </h4><p>Because <code>Or</code> declares one alternative to be &ldquo;good&rdquo; and the other &ldquo;bad,&rdquo;
it is more convenient than <code>Either</code> in this kind of situation. One difference to note with
<code>Or</code> is that the <code>Good</code> alternative is on the left, <code>Bad</code> on the right.
The reason is that <code>Or</code> is designed to be written using infix notation, and placing the
&ldquo;happy path&rdquo; first is more readable. For example, instead of writing:</p><p><pre class="stHighlighted">
<span class="stType">Or[Int, ErrorMessage]</span>
</pre></p><p>You can write:</p><p><pre class="stHighlighted">
<span class="stType">Int</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span>
</pre></p><p>Here's how the <code>parseName</code> method might be written using an <code>Or</code>, where
<code>ErrorMessage</code> is a type alias for <code>String</code> declared in the <code>org.scalactic</code>
package object:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalactic._
<br/><span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">String</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Good</span>(trimmed) <span class="stReserved">else</span> <span class="stType">Bad</span>(s<span class="stQuotedString">""""${input}" is not a valid name"""</span>)
}
</pre></p><p>You can think of the <code>String</code> <code>Or</code> <code>ErrorMessage</code> result
type like this:</p><p><blockquote>
<em>The <code>parseName</code> method will return a name <code>String</code> or, if the input string
is not a valid name, an <code>ErrorMessage</code>.</em>
</blockquote></p><p>Here's how the <code>parseAge</code> method might be written:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Int</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Good</span>(age) <span class="stReserved">else</span> <span class="stType">Bad</span>(s<span class="stQuotedString">""""${age}" is not a valid age"""</span>)
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">Bad</span>(s<span class="stQuotedString">""""${input}" is not a valid integer"""</span>)
  }
}
</pre></p><p>Given these implementations, here's how you'd write the <code>parsePerson</code> method:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Person</span> <span class="stType">Or</span> <span class="stType">ErrorMessage</span> =
  <span class="stReserved">for</span> {
    name &lt;- parseName(inputName)
    age &lt;- parseAge(inputAge)
  } <span class="stReserved">yield</span> <span class="stType">Person</span>(name, age)
</pre></p><p>Because of <code>Or</code>'s attitude, you need not write <code>.good</code> at the end of
each generator. <code>Or</code> will keep going so long as each step produces a <code>Good</code>,
short circuiting at the first sign of a <code>Bad</code>. Here are a few invocations of this
<code>parsePerson</code> method:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Good(Person(Bridget Jones,29))</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad("" is not a valid integer)</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: Bad("-29" is not a valid age)</span>
<br/>parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad("" is not a valid name)</span>
</pre></p><p><a name="accumulatingErrors"></a></p><h4> Accumulating errors with <code>Or</code> </h4><p>Another difference between <code>Or</code> and <code>Either</code> is that <code>Or</code> enables
you to accumulate errors if the <code>Bad</code> type is an <a href="Every.html"><code>Every</code></a>.
An <code>Every</code> is similar to a <code>Seq</code> in that it contains ordered elements, but
different from <code>Seq</code> in that it cannot be empty. An <code>Every</code> is
either a <a href="One.html"><code>One</code></a>,
which contains one and only one element, or a <a href="Many.html"><code>Many</code></a>, which contains two or
more elements.</p><p><em>Note: an <code>Or</code> whose <code>Bad</code> type is an <code>Every</code>, or one of its subtypes,
is called an &ldquo;accumulating <code>Or</code>.&rdquo;</em></p><p>To rewrite the previous example so that errors can be accumulated, you need first to return an <code>Every</code>
as the <code>Bad</code> type. Here's how you'd change the <code>parseName</code> method:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseName(input: <span class="stType">String</span>): <span class="stType">String</span> <span class="stType">Or</span> <span class="stType">One[ErrorMessage]</span> = {
  <span class="stReserved">val</span> trimmed = input.trim
  <span class="stReserved">if</span> (!trimmed.isEmpty) <span class="stType">Good</span>(trimmed) <span class="stReserved">else</span> <span class="stType">Bad</span>(<span class="stType">One</span>(s<span class="stQuotedString">""""${input}" is not a valid name"""</span>))
}
</pre></p><p>Because <code>parseName</code> will either return a valid name <code>String</code> wrapped in a
<code>Good</code>, or <em>one</em> error message, wrapped in a <code>Bad</code>, you would write the
<code>Bad</code> type as <code>One[ErrorMessage]</code>. The same is true for <code>parseAge</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> parseAge(input: <span class="stType">String</span>): <span class="stType">Int</span> <span class="stType">Or</span> <span class="stType">One[ErrorMessage]</span> = {
  <span class="stReserved">try</span> {
    <span class="stReserved">val</span> age = input.trim.toInt
    <span class="stReserved">if</span> (age &gt;= <span class="stLiteral">0</span>) <span class="stType">Good</span>(age) <span class="stReserved">else</span> <span class="stType">Bad</span>(<span class="stType">One</span>(s<span class="stQuotedString">""""${age}" is not a valid age"""</span>))
  }
  <span class="stReserved">catch</span> {
    <span class="stReserved">case</span> _: <span class="stType">NumberFormatException</span> =&gt; <span class="stType">Bad</span>(<span class="stType">One</span>(s<span class="stQuotedString">""""${input}" is not a valid integer"""</span>))
  }
}
</pre></p><p>Because a <code>for</code> expression short-circuits on the first <code>Bad</code> encountered, you'll
need to use a different approach to write the <code>parsePerson</code> method. In this example, the
<code>withGood</code> method from trait <a href="Accumulation.html"><code>Accumulation</code></a>
will do the trick:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> Accumulation._
<br/><span class="stReserved">def</span> parsePerson(inputName: <span class="stType">String</span>, inputAge: <span class="stType">String</span>): <span class="stType">Person</span> <span class="stType">Or</span> <span class="stType">Every[ErrorMessage]</span> = {
  <span class="stReserved">val</span> name = parseName(inputName)
  <span class="stReserved">val</span> age = parseAge(inputAge)
  withGood(name, age) { <span class="stType">Person</span>(_, _) }
}
</pre></p><p>Trait <code>Accumulation</code> offers overloaded <code>withGood</code> methods that take 1 to
22 accumulating <code>Or</code>s, plus a function taking the same number of corresponding
<code>Good</code> values.  In this example, if both <code>name</code> and <code>age</code> are
<code>Good</code>s, the <code>withGood</code> method will pass the good name <code>String</code>
and age <code>Int</code> to the <code>Person(_, _)</code> function, and return the resulting <code>Person</code>
object wrapped in a <code>Good</code>. If either <code>name</code> and <code>age</code>, or both,
are <code>Bad</code>, <code>withGood</code> will return the accumulated errors in a <code>Bad</code>.</p><p>The result of <code>parsePerson</code>, if <code>Bad</code>, will therefore contain either one or two
error messages, <em>i.e.</em>, the result will either be a <code>One</code> or a <code>Many</code>.
As a result, the result type of <code>parsePerson</code> must be <code>Person</code> <code>Or</code>
<code>Every[ErrorMessage]</code>. Regardless of whether a <code>Bad</code> result contains one
or two error messages, it will contain <em>every</em> error message. Here's some invocations of
this accumulating version of <code>parsePerson</code>:</p><p><pre class="stHighlighted">
parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"29"</span>)
<span class="stLineComment">// Result: Good(Person(Bridget Jones,29))</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad(One("" is not a valid integer))</span>
<br/>parsePerson(<span class="stQuotedString">"Bridget Jones"</span>, <span class="stQuotedString">"-29"</span>)
<span class="stLineComment">// Result: Bad(One("-29" is not a valid age))</span>
<br/>parsePerson(<span class="stQuotedString">""</span>, <span class="stQuotedString">""</span>)
<span class="stLineComment">// Result: Bad(Many("" is not a valid name, "" is not a valid integer))</span>
</pre></p><p>Note that in the last example, the <code>Bad</code> contains an error message for both name and age.</p><h4> Other ways to accumulate errors </h4><p>The <code>Accumlation</code> trait also enables other ways of accumulating errors.</p><p><a name="usingCombined"></a></p><h5> Using <code>combined</code> </h5><p>If you have a collection of
accumulating <code>Or</code>s, for example, you can <em>combine</em> them into one <code>Or</code> using <code>combined</code>, like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(parseAge(<span class="stQuotedString">"29"</span>), parseAge(<span class="stQuotedString">"30"</span>), parseAge(<span class="stQuotedString">"31"</span>)).combined
<span class="stLineComment">// Result: Good(List(29, 30, 31))</span>
<br/><span class="stType">List</span>(parseAge(<span class="stQuotedString">"29"</span>), parseAge(<span class="stQuotedString">"-30"</span>), parseAge(<span class="stQuotedString">"31"</span>)).combined
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>
<br/><span class="stType">List</span>(parseAge(<span class="stQuotedString">"29"</span>), parseAge(<span class="stQuotedString">"-30"</span>), parseAge(<span class="stQuotedString">"-31"</span>)).combined
<span class="stLineComment">// Result: Bad(Many("-30" is not a valid age, "-31" is not a valid age))</span>
</pre></p><p><a name="usingValidatedBy"></a></p><h5> Using <code>validatedBy</code> </h5><p>Or if you have a collection of values and a function that transforms that type of value into an accumulating
<code>Or</code>s, you can validate the values using the function using <code>validatedBy</code>, like this:</p><p><pre class="stHighlighted">
<span class="stType">List</span>(<span class="stQuotedString">"29"</span>, <span class="stQuotedString">"30"</span>, <span class="stQuotedString">"31"</span>).validatedBy(parseAge)
<span class="stLineComment">// Result: Good(List(29, 30, 31))</span>
<br/><span class="stType">List</span>(<span class="stQuotedString">"29"</span>, <span class="stQuotedString">"-30"</span>, <span class="stQuotedString">"31"</span>).validatedBy(parseAge)
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>
<br/><span class="stType">List</span>(<span class="stQuotedString">"29"</span>, <span class="stQuotedString">"-30"</span>, <span class="stQuotedString">"-31"</span>).validatedBy(parseAge)
<span class="stLineComment">// Result: Bad(Many("-30" is not a valid age, "-31" is not a valid age))</span>
</pre></p><p><a name="usingZip"></a></p><h5> Using <code>zip</code> </h5><p>You can also zip two accumulating <code>Or</code>s together. If both are <code>Good</code>, you'll get a
<code>Good</code> tuple containin both original <code>Good</code> values. Otherwise, you'll get a <code>Bad</code>
containing every error message. Here are some examples:</p><p><pre class="stHighlighted">
parseName(<span class="stQuotedString">"Dude"</span>) zip parseAge(<span class="stQuotedString">"21"</span>)
<span class="stLineComment">// Result: Good((Dude,21))</span>
<br/>parseName(<span class="stQuotedString">"Dude"</span>) zip parseAge(<span class="stQuotedString">"-21"</span>)
<span class="stLineComment">// Result: Bad(One("-21" is not a valid age))</span>
<br/>parseName(<span class="stQuotedString">""</span>) zip parseAge(<span class="stQuotedString">"-21"</span>)
<span class="stLineComment">// Result: Bad(Many("" is not a valid name, "-21" is not a valid age))</span>
</pre></p><p><a name="usingWhen"></a></p><h5> Using <code>when</code> </h5><p>In addition, given an accumlating <code>Or</code>, you can pass one or more <em>validation functions</em> to <code>when</code> on the <code>Or</code>
to submit that <code>Or</code> to further scrutiny. A validation function accepts a <code>Good</code> type and returns a <code>Validation[E]</code>,
where <code>E</code> is the type in the <code>Every</code> in the <code>Bad</code> type. For an <code>Int</code> <code>Or</code> <code>One[ErrorMessage]</code>, for example
the validation function type would be <code>Int</code> <code>=&gt;</code> <code>Validation[ErrorMessage]</code>. Here are a few examples:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> isRound(i: <span class="stType">Int</span>): <span class="stType">Validation[ErrorMessage]</span> =
  <span class="stReserved">if</span> (i % <span class="stLiteral">10</span> == <span class="stLiteral">0</span>) <span class="stType">Pass</span> <span class="stReserved">else</span> <span class="stType">Fail</span>(i + <span class="stQuotedString">" was not a round number"</span>)
<br/><span class="stReserved">def</span> isDivBy3(i: <span class="stType">Int</span>): <span class="stType">Validation[ErrorMessage]</span> =
  <span class="stReserved">if</span> (i % <span class="stLiteral">3</span> == <span class="stLiteral">0</span>) <span class="stType">Pass</span> <span class="stReserved">else</span> <span class="stType">Fail</span>(i + <span class="stQuotedString">" was not divisible by 3"</span>)
</pre></p><p>If the <code>Or</code> on which you call <code>when</code> is already <code>Bad</code>, you get the same (<code>Bad</code>) <code>Or</code> back, because
no <code>Good</code> value exists to pass to the valiation functions:</p><p><pre class="stHighlighted">
parseAge(<span class="stQuotedString">"-30"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>
</pre></p><p>If the <code>Or</code> on which you call <code>when</code> is <code>Good</code>, and also passes all the validation functions (<em>i.e.</em>, the
all return <code>None</code>), you again get the same <code>Or</code> back, but this time, a <code>Good</code> one:</p><p><pre class="stHighlighted">
parseAge(<span class="stQuotedString">"30"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Good(30)</span>
</pre></p><p>If one or more of the validation functions fails, however, you'll get a <code>Bad</code> back contining every error. Here are some examples:</p><p><pre class="stHighlighted">
parseAge(<span class="stQuotedString">"33"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(One(33 was not a round number))</span>
<br/>parseAge(<span class="stQuotedString">"20"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(One(20 was not divisible by 3))</span>
<br/>parseAge(<span class="stQuotedString">"31"</span>).when(isRound, isDivBy3)
<span class="stLineComment">// Result: Bad(Many(31 was not a round number, 31 was not divisible by 3))</span>
</pre></p><p>Note that you can use <code>when</code> to accumulate errors in a <code>for</code> expression involving an accumulating <code>Or</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"-30"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(One("-30" is not a valid age))</span>
<br/><span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"30"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Good(30)</span>
<br/><span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"33"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(One(33 was not a round number))</span>
<br/><span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"20"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(One(20 was not divisible by 3))</span>
<br/><span class="stReserved">for</span> (age &lt;- parseAge(<span class="stQuotedString">"31"</span>) when (isRound, isDivBy3)) <span class="stReserved">yield</span> age
<span class="stLineComment">// Result: Bad(Many(31 was not a round number, 31 was not divisible by 3))</span>
</pre></p><h4> Much ado about <code>Nothing</code> </h4><p>Because <code>Or</code> has two types, but each of its two subtypes only takes a value of one or the other type, the Scala compiler will
infer <code>Nothing</code> for the unspecified type:</p><p><pre class="stREPL">
scala&gt; Good(3)
res0: org.scalactic.Good[Int,Nothing] = Good(3)

scala&gt; Bad("oops")
res1: org.scalactic.Bad[Nothing,String] = Bad(oops)
</pre></p><p>Often <code>Nothing</code> will work fine, as it will be widened as soon as the compiler encounters a more specific type.
Sometimes, however, you may need to specify it. In such situations you can use this syntax:</p><p><pre class="stREPL">
scala&gt; Good(3).orBad[String]
res2: org.scalactic.Good[Int,String] = Good(3)

scala&gt; Good[Int].orBad("oops")
res3: org.scalactic.Bad[Int,String] = Bad(oops)
</pre></p><p>If you want to specify both types, because you don't like the inferred type, you can do so like this:</p><p><pre class="stREPL">
scala&gt; Good[AnyVal, String](3)
res4: org.scalactic.Good[AnyVal,String] = Good(3)

scala&gt; Bad[Int, ErrorMessage]("oops")
res5: org.scalactic.Bad[Int,org.scalactic.ErrorMessage] = Bad(oops)
</pre></p><p>But you may find the code is clearer if you instead use a type ascription, like this:</p><p><pre class="stREPL">
scala&gt; Good(3): AnyVal Or String
res6: org.scalactic.Or[AnyVal,String] = Good(3)

scala&gt; Bad("oops"): Int Or ErrorMessage
res7: org.scalactic.Or[Int,org.scalactic.ErrorMessage] = Bad(oops)
</pre></p><p><em>Note: The <code>Or</code> hierarchy was inspired in part by the disjoint union (<code>\/</code>) and <code>Validation</code> types of
<a href="http://code.google.com/p/scalaz/" target="_blank"><code>scalaz</code></a>, the <code>ProcessResult</code> type of
<a href="https://github.com/typesafehub/activator/">Typesafe Activator</a>, and the <code>Result</code> type of
<a href="https://github.com/vpatryshev/ScalaKittens">ScalaKittens</a>.</em></p></div><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/scalatest/releases-source/blob/main/scalactic/3.2.8/src/main/scala/org/scalactic/Or.scala" target="_blank">Or.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a>, <span name="scala.Product" class="extype">Product</span>, <span name="scala.Equals" class="extype">Equals</span>, <span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div><div class="toggleContainer"><div class="toggle block"><span>Known Subclasses</span><div class="subClasses hiddenContent"><a href="Bad.html" name="org.scalactic.Bad" id="org.scalactic.Bad" class="extype">Bad</a>, <a href="Good.html" name="org.scalactic.Good" id="org.scalactic.Good" class="extype">Good</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="org.scalactic.Or"><span>Or</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.Product"><span>Product</span></li><li class="in" name="scala.Equals"><span>Equals</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div class="values members"><h3>Abstract Value Members</h3><ol><li class="indented0 " name="org.scalactic.Or#accumulating" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="accumulating:org.scalactic.Or[G,org.scalactic.One[B]]" class="anchorToMember"></a><a id="accumulating:Or[G,One[B]]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#accumulating:org.scalactic.Or[G,org.scalactic.One[B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">accumulating</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.G" class="extype">G</span>, <a href="One.html" name="org.scalactic.One" id="org.scalactic.One" class="extype">One</a>[<span name="org.scalactic.Or.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">Converts this <code>Or</code> to an <code>Or</code> with the same <code>Good</code> type and a <code>Bad</code> type consisting of
<a href="One.html"><code>One</code></a> parameterized by this <code>Or</code>'s <code>Bad</code> type.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this <code>Or</code> to an <code>Or</code> with the same <code>Good</code> type and a <code>Bad</code> type consisting of
<a href="One.html"><code>One</code></a> parameterized by this <code>Or</code>'s <code>Bad</code> type.</p><p>For example, invoking the <code>accumulating</code> method on an <code>Int Or ErrorMessage</code> would convert it to an
<code>Int Or One[ErrorMessage]</code>. This result type, because the <code>Bad</code> type is an <code>Every</code>, can be used
with the mechanisms provided in trait <a href="Accumulation.html"><code>Accumulation</code></a> to accumulate errors.</p><p>Note that if this <code>Or</code> is already an accumulating <code>Or</code>, the behavior of this <code>accumulating</code> method does not change.
For example, if you invoke <code>accumulating</code> on an <code>Int Or One[ErrorMessage]</code> you will be rewarded with an
<code>Int Or One[One[ErrorMessage]]</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>this <code>Good</code>, if this <code>Or</code> is a <code>Good</code>; or this <code>Bad</code> value wrapped in a <code>One</code> if
    this <code>Or</code> is a <code>Bad</code>.</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#badMap" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="badMap[C](f:B=&gt;C):org.scalactic.Or[G,C]" class="anchorToMember"></a><a id="badMap[C]((B)=&gt;C):Or[G,C]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#badMap[C](f:B=&gt;C):org.scalactic.Or[G,C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">badMap</span><span class="tparams">[<span name="C">C</span>]</span><span class="params">(<span name="f">f: (<span name="org.scalactic.Or.B" class="extype">B</span>) =&gt; <span name="org.scalactic.Or.badMap.C" class="extype">C</span></span>)</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.G" class="extype">G</span>, <span name="org.scalactic.Or.badMap.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code> or returns <code>this</code> if it is a <code>Good</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code> or returns <code>this</code> if it is a <code>Good</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>if this is a <code>Bad</code>, the result of applying the given function to the contained value wrapped in a <code>Bad</code>,
        else this <code>Good</code> is returned</p></dd></dl></div></li><li class="indented0 " name="scala.Equals#canEqual" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="canEqual(that:Any):Boolean" class="anchorToMember"></a><a id="canEqual(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#canEqual(that:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">canEqual</span><span class="params">(<span name="that">that: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Equals</dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#exists" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="exists(p:G=&gt;Boolean):Boolean" class="anchorToMember"></a><a id="exists((G)=&gt;Boolean):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#exists(p:G=&gt;Boolean):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">exists</span><span class="params">(<span name="p">p: (<span name="org.scalactic.Or.G" class="extype">G</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">Returns <code>true</code> if this <code>Or</code> is a <code>Good</code> and the predicate <code>p</code> returns true when applied to this <code>Good</code>'s value.</p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>true</code> if this <code>Or</code> is a <code>Good</code> and the predicate <code>p</code> returns true when applied to this <code>Good</code>'s value.</p><p>Note: The <code>exists</code> method will return the same result as <code>forall</code> if this <code>Or</code> is a <code>Good</code>, but the opposite
result if this <code>Or</code> is a <code>Bad</code>.</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the predicate to apply to the <code>Good</code> value, if this is a <code>Good</code></p></dd><dt>returns</dt><dd class="cmt"><p>the result of applying the passed predicate <code>p</code> to the <code>Good</code> value, if this is a <code>Good</code>, else <code>false</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#filter" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="filter[C&gt;:B](f:G=&gt;org.scalactic.Validation[C]):org.scalactic.Or[G,C]" class="anchorToMember"></a><a id="filter[C&gt;:B]((G)=&gt;Validation[C]):Or[G,C]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#filter[C&gt;:B](f:G=&gt;org.scalactic.Validation[C]):org.scalactic.Or[G,C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">filter</span><span class="tparams">[<span name="C">C &gt;: <span name="org.scalactic.Or.B" class="extype">B</span></span>]</span><span class="params">(<span name="f">f: (<span name="org.scalactic.Or.G" class="extype">G</span>) =&gt; <a href="Validation.html" name="org.scalactic.Validation" id="org.scalactic.Validation" class="extype">Validation</a>[<span name="org.scalactic.Or.filter.C" class="extype">C</span>]</span>)</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.G" class="extype">G</span>, <span name="org.scalactic.Or.filter.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">Returns this <code>Or</code> if either 1) it is a <code>Bad</code> or 2) it is a <code>Good</code> and applying the validation function <code>f</code> to this
<code>Good</code>'s value returns <code>Pass</code>; otherwise,
returns a new <code>Bad</code> containing the error value contained in the <code>Fail</code> resulting from applying the validation
function <code>f</code> to this <code>Good</code>'s value.</p><div class="fullcomment"><div class="comment cmt"><p>Returns this <code>Or</code> if either 1) it is a <code>Bad</code> or 2) it is a <code>Good</code> and applying the validation function <code>f</code> to this
<code>Good</code>'s value returns <code>Pass</code>; otherwise,
returns a new <code>Bad</code> containing the error value contained in the <code>Fail</code> resulting from applying the validation
function <code>f</code> to this <code>Good</code>'s value.</p><p>For examples of <code>filter</code> used in <code>for</code> expressions, see the main documentation for trait
<a href="Validation.html"><code>Validation</code></a>.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the validation function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>a <code>Good</code> if this <code>Or</code> is a <code>Good</code> that passes the validation function, else a <code>Bad</code>.</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#flatMap" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="flatMap[H,C&gt;:B](f:G=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" class="anchorToMember"></a><a id="flatMap[H,C&gt;:B]((G)=&gt;Or[H,C]):Or[H,C]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#flatMap[H,C&gt;:B](f:G=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMap</span><span class="tparams">[<span name="H">H</span>, <span name="C">C &gt;: <span name="org.scalactic.Or.B" class="extype">B</span></span>]</span><span class="params">(<span name="f">f: (<span name="org.scalactic.Or.G" class="extype">G</span>) =&gt; <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.flatMap.H" class="extype">H</span>, <span name="org.scalactic.Or.flatMap.C" class="extype">C</span>]</span>)</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.flatMap.H" class="extype">H</span>, <span name="org.scalactic.Or.flatMap.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">Returns the given function applied to the value contained in this <code>Or</code> if it is a <code>Good</code>,
or returns <code>this</code> if it is a <code>Bad</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the given function applied to the value contained in this <code>Or</code> if it is a <code>Good</code>,
or returns <code>this</code> if it is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>if this is a <code>Good</code>, the result of applying the given function to the contained value wrapped in a <code>Good</code>,
        else this <code>Bad</code> is returned</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#fold" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="fold[V](gf:G=&gt;V,bf:B=&gt;V):V" class="anchorToMember"></a><a id="fold[V]((G)=&gt;V,(B)=&gt;V):V" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#fold[V](gf:G=&gt;V,bf:B=&gt;V):V" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fold</span><span class="tparams">[<span name="V">V</span>]</span><span class="params">(<span name="gf">gf: (<span name="org.scalactic.Or.G" class="extype">G</span>) =&gt; <span name="org.scalactic.Or.fold.V" class="extype">V</span></span>, <span name="bf">bf: (<span name="org.scalactic.Or.B" class="extype">B</span>) =&gt; <span name="org.scalactic.Or.fold.V" class="extype">V</span></span>)</span><span class="result">: <span name="org.scalactic.Or.fold.V" class="extype">V</span></span></span><p class="shortcomment cmt">Folds this <code>Or</code> into a value of type <code>V</code> by applying the given <code>gf</code> function if this is
a <code>Good</code> else the given <code>bf</code> function if this is a <code>Bad</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Folds this <code>Or</code> into a value of type <code>V</code> by applying the given <code>gf</code> function if this is
a <code>Good</code> else the given <code>bf</code> function if this is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt class="param">gf</dt><dd class="cmt"><p>the function to apply to this <code>Or</code>'s <code>Good</code> value, if it is a <code>Good</code></p></dd><dt class="param">bf</dt><dd class="cmt"><p>the function to apply to this <code>Or</code>'s <code>Bad</code> value, if it is a <code>Bad</code></p></dd><dt>returns</dt><dd class="cmt"><p>the result of applying the appropriate one of the two passed functions, <code>gf</code> or </code>bf</code>, to this <code>Or</code>'s value</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#forall" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="forall(f:G=&gt;Boolean):Boolean" class="anchorToMember"></a><a id="forall((G)=&gt;Boolean):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#forall(f:G=&gt;Boolean):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forall</span><span class="params">(<span name="f">f: (<span name="org.scalactic.Or.G" class="extype">G</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">Returns <code>true</code> if either this <code>Or</code> is a <code>Bad</code> or if the predicate <code>p</code> returns <code>true</code> when applied
to this <code>Good</code>'s value.</p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>true</code> if either this <code>Or</code> is a <code>Bad</code> or if the predicate <code>p</code> returns <code>true</code> when applied
to this <code>Good</code>'s value.</p><p>Note: The <code>forall</code> method will return the same result as <code>exists</code> if this <code>Or</code> is a <code>Good</code>, but the opposite
result if this <code>Or</code> is a <code>Bad</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the result of applying the passed predicate <code>p</code> to the <code>Good</code> value, if this is a <code>Good</code>, else <code>true</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#foreach" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="foreach(f:G=&gt;Unit):Unit" class="anchorToMember"></a><a id="foreach((G)=&gt;Unit):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#foreach(f:G=&gt;Unit):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foreach</span><span class="params">(<span name="f">f: (<span name="org.scalactic.Or.G" class="extype">G</span>) =&gt; <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Applies the given function f to the contained value if this <code>Or</code> is a <code>Good</code>; does nothing if this <code>Or</code>
is a <code>Bad</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the given function f to the contained value if this <code>Or</code> is a <code>Good</code>; does nothing if this <code>Or</code>
is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#get" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="get:G" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#get:G" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">get</span><span class="result">: <span name="org.scalactic.Or.G" class="extype">G</span></span></span><p class="shortcomment cmt">Returns the <code>Or</code>'s value if it is a <code>Good</code> or throws <code>NoSuchElementException</code> if it is a <code>Bad</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the <code>Or</code>'s value if it is a <code>Good</code> or throws <code>NoSuchElementException</code> if it is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the contained value if this is a <code>Good</code></p></dd></dl><dl class="attributes block"><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="NoSuchElementException" class="extype"><code>NoSuchElementException</code></span> if this is a <code>Bad</code></p></span></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#getOrElse" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="getOrElse[H&gt;:G](default:=&gt;H):H" class="anchorToMember"></a><a id="getOrElse[H&gt;:G](=&gt;H):H" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#getOrElse[H&gt;:G](default:=&gt;H):H" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getOrElse</span><span class="tparams">[<span name="H">H &gt;: <span name="org.scalactic.Or.G" class="extype">G</span></span>]</span><span class="params">(<span name="default">default: =&gt; <span name="org.scalactic.Or.getOrElse.H" class="extype">H</span></span>)</span><span class="result">: <span name="org.scalactic.Or.getOrElse.H" class="extype">H</span></span></span><p class="shortcomment cmt">Returns, if this <code>Or</code> is <code>Good</code>, this <code>Good</code>'s value; otherwise returns the result of evaluating <code>default</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns, if this <code>Or</code> is <code>Good</code>, this <code>Good</code>'s value; otherwise returns the result of evaluating <code>default</code>.
</p></div><dl class="paramcmts block"><dt class="param">default</dt><dd class="cmt"><p>the default expression to evaluate if this <code>Or</code> is a <code>Bad</code></p></dd><dt>returns</dt><dd class="cmt"><p>the contained value, if this <code>Or</code> is a <code>Good</code>, else the result of evaluating the given <code>default</code></p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#map" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="map[H](f:G=&gt;H):org.scalactic.Or[H,B]" class="anchorToMember"></a><a id="map[H]((G)=&gt;H):Or[H,B]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#map[H](f:G=&gt;H):org.scalactic.Or[H,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map</span><span class="tparams">[<span name="H">H</span>]</span><span class="params">(<span name="f">f: (<span name="org.scalactic.Or.G" class="extype">G</span>) =&gt; <span name="org.scalactic.Or.map.H" class="extype">H</span></span>)</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.map.H" class="extype">H</span>, <span name="org.scalactic.Or.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Maps the given function to this <code>Or</code>'s value if it is a <code>Good</code> or returns <code>this</code> if it is a <code>Bad</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Maps the given function to this <code>Or</code>'s value if it is a <code>Good</code> or returns <code>this</code> if it is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>if this is a <code>Good</code>, the result of applying the given function to the contained value wrapped in a <code>Good</code>,
        else this <code>Bad</code> is returned</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#orElse" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="orElse[H&gt;:G,C&gt;:B](alternative:=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" class="anchorToMember"></a><a id="orElse[H&gt;:G,C&gt;:B](=&gt;Or[H,C]):Or[H,C]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#orElse[H&gt;:G,C&gt;:B](alternative:=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">orElse</span><span class="tparams">[<span name="H">H &gt;: <span name="org.scalactic.Or.G" class="extype">G</span></span>, <span name="C">C &gt;: <span name="org.scalactic.Or.B" class="extype">B</span></span>]</span><span class="params">(<span name="alternative">alternative: =&gt; <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.orElse.H" class="extype">H</span>, <span name="org.scalactic.Or.orElse.C" class="extype">C</span>]</span>)</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.orElse.H" class="extype">H</span>, <span name="org.scalactic.Or.orElse.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">Returns this <code>Or</code> if it is a <code>Good</code>, otherwise returns the result of evaluating the passed <code>alternative</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns this <code>Or</code> if it is a <code>Good</code>, otherwise returns the result of evaluating the passed <code>alternative</code>.
</p></div><dl class="paramcmts block"><dt class="param">alternative</dt><dd class="cmt"><p>the alternative by-name to evaluate if this <code>Or</code> is a <code>Bad</code></p></dd><dt>returns</dt><dd class="cmt"><p>this <code>Or</code>, if it is a <code>Good</code>, else the result of evaluating <code>alternative</code></p></dd></dl></div></li><li class="indented0 " name="scala.Product#productArity" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="productArity:Int" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#productArity:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">productArity</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Product</dd></dl></div></li><li class="indented0 " name="scala.Product#productElement" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="productElement(n:Int):Any" class="anchorToMember"></a><a id="productElement(Int):Any" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#productElement(n:Int):Any" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">productElement</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Any" class="extype">Any</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Product</dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#recover" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="recover[H&gt;:G](f:B=&gt;H):org.scalactic.Or[H,B]" class="anchorToMember"></a><a id="recover[H&gt;:G]((B)=&gt;H):Or[H,B]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#recover[H&gt;:G](f:B=&gt;H):org.scalactic.Or[H,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">recover</span><span class="tparams">[<span name="H">H &gt;: <span name="org.scalactic.Or.G" class="extype">G</span></span>]</span><span class="params">(<span name="f">f: (<span name="org.scalactic.Or.B" class="extype">B</span>) =&gt; <span name="org.scalactic.Or.recover.H" class="extype">H</span></span>)</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.recover.H" class="extype">H</span>, <span name="org.scalactic.Or.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code>, transforming it into a <code>Good</code>, or returns
<code>this</code> if it is already a <code>Good</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code>, transforming it into a <code>Good</code>, or returns
<code>this</code> if it is already a <code>Good</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>if this is a <code>Bad</code>, the result of applying the given function to the contained value wrapped in a <code>Good</code>,
        else this <code>Good</code> is returned</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#recoverWith" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="recoverWith[H&gt;:G,C](f:B=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" class="anchorToMember"></a><a id="recoverWith[H&gt;:G,C]((B)=&gt;Or[H,C]):Or[H,C]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#recoverWith[H&gt;:G,C](f:B=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">recoverWith</span><span class="tparams">[<span name="H">H &gt;: <span name="org.scalactic.Or.G" class="extype">G</span></span>, <span name="C">C</span>]</span><span class="params">(<span name="f">f: (<span name="org.scalactic.Or.B" class="extype">B</span>) =&gt; <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.recoverWith.H" class="extype">H</span>, <span name="org.scalactic.Or.recoverWith.C" class="extype">C</span>]</span>)</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.recoverWith.H" class="extype">H</span>, <span name="org.scalactic.Or.recoverWith.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code>, returning the result, or returns
<code>this</code> if it is already a <code>Good</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Maps the given function to this <code>Or</code>'s value if it is a <code>Bad</code>, returning the result, or returns
<code>this</code> if it is already a <code>Good</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to apply</p></dd><dt>returns</dt><dd class="cmt"><p>if this is a <code>Bad</code>, the result of applying the given function to the contained value,
        else this <code>Good</code> is returned</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#swap" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="swap:org.scalactic.Or[B,G]" class="anchorToMember"></a><a id="swap:Or[B,G]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#swap:org.scalactic.Or[B,G]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">swap</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.B" class="extype">B</span>, <span name="org.scalactic.Or.G" class="extype">G</span>]</span></span><p class="shortcomment cmt">Returns an <code>Or</code> with the <code>Good</code> and <code>Bad</code> types swapped: <code>Bad</code> becomes <code>Good</code> and <code>Good</code>
becomes <code>Bad</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Or</code> with the <code>Good</code> and <code>Bad</code> types swapped: <code>Bad</code> becomes <code>Good</code> and <code>Good</code>
becomes <code>Bad</code>.</p><p>Here's an example:</p><p><pre class="stREPL">
scala&gt; val lyrics = Bad("Hey Jude, don't make it bad. Take a sad song and make it better.")
lyrics: org.scalactic.Bad[Nothing,String] =
    Bad(Hey Jude, don't make it bad. Take a sad song and make it better.)

scala&gt; lyrics.swap
res12: org.scalactic.Or[String,Nothing] =
    Good(Hey Jude, don't make it bad. Take a sad song and make it better.)
</pre></p><p>Now that song will be rolling around in your head all afternoon. But at least it is a good song (thanks to <code>swap</code>).</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>if this <code>Or</code> is a <code>Good</code>, its <code>Good</code> value wrapped in a <code>Bad</code>; if this <code>Or</code> is
    a <code>Bad</code>, its <code>Bad</code> value wrapped in a <code>Good</code>.</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#toEither" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="toEither:Either[B,G]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#toEither:Either[B,G]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toEither</span><span class="result">: <span name="scala.Either" class="extype">Either</span>[<span name="org.scalactic.Or.B" class="extype">B</span>, <span name="org.scalactic.Or.G" class="extype">G</span>]</span></span><p class="shortcomment cmt">Returns an <code>Either</code>: a <code>Right</code> containing the <code>Good</code> value, if this is a <code>Good</code>; a <code>Left</code>
containing the <code>Bad</code> value, if this is a <code>Bad</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Either</code>: a <code>Right</code> containing the <code>Good</code> value, if this is a <code>Good</code>; a <code>Left</code>
containing the <code>Bad</code> value, if this is a <code>Bad</code>.</p><p>Note that values effectively &ldquo;switch sides&rdquo; when convering an <code>Or</code> to an <code>Either</code>. If the type of the
<code>Or</code> on which you invoke <code>toEither</code> is <code>Or[Int, ErrorMessage]</code> for example, the result will be an
<code>Either[ErrorMessage, Int]</code>. The reason is that the convention for <code>Either</code> is that <code>Left</code> is used for &ldquo;bad&rdquo;
values and <code>Right</code> is used for &ldquo;good&rdquo; ones.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>this <code>Good</code> value, wrapped in a <code>Right</code>, or this <code>Bad</code> value, wrapped in a <code>Left</code>.</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#toOption" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="toOption:Option[G]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#toOption:Option[G]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toOption</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="org.scalactic.Or.G" class="extype">G</span>]</span></span><p class="shortcomment cmt">Returns a <code>Some</code> containing the <code>Good</code> value, if this <code>Or</code> is a <code>Good</code>, else <code>None</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Some</code> containing the <code>Good</code> value, if this <code>Or</code> is a <code>Good</code>, else <code>None</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the contained &ldquo;good&rdquo; value wrapped in a <code>Some</code>, if this <code>Or</code> is a <code>Good</code>; <code>None</code>
    if this <code>Or</code> is a <code>Bad</code>.</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#toSeq" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="toSeq:IndexedSeq[G]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#toSeq:IndexedSeq[G]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toSeq</span><span class="result">: <span name="scala.collection.immutable.IndexedSeq" class="extype">IndexedSeq</span>[<span name="org.scalactic.Or.G" class="extype">G</span>]</span></span><p class="shortcomment cmt">Returns an immutable <code>IndexedSeq</code> containing the <code>Good</code> value, if this <code>Or</code> is a <code>Good</code>, else an empty
immutable <code>IndexedSeq</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an immutable <code>IndexedSeq</code> containing the <code>Good</code> value, if this <code>Or</code> is a <code>Good</code>, else an empty
immutable <code>IndexedSeq</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the contained &ldquo;good&rdquo; value in a lone-element <code>Seq</code> if this <code>Or</code> is a <code>Good</code>; an empty <code>Seq</code> if
    this <code>Or</code> is a <code>Bad</code>.</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#toTry" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="toTry(implicitev:B&lt;:&lt;Throwable):scala.util.Try[G]" class="anchorToMember"></a><a id="toTry(&lt;:&lt;[B,Throwable]):Try[G]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#toTry(implicitev:B&lt;:&lt;Throwable):scala.util.Try[G]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toTry</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.&lt;:&lt;" class="extype">&lt;:&lt;</span>[<span name="org.scalactic.Or.B" class="extype">B</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span>)</span><span class="result">: <span name="scala.util.Try" class="extype">Try</span>[<span name="org.scalactic.Or.G" class="extype">G</span>]</span></span><p class="shortcomment cmt">Returns a <code>Try</code>: a <code>Success</code> containing the
<code>Good</code> value, if this is a <code>Good</code>; a <code>Failure</code>
containing the <code>Bad</code> value, if this is a <code>Bad</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Try</code>: a <code>Success</code> containing the
<code>Good</code> value, if this is a <code>Good</code>; a <code>Failure</code>
containing the <code>Bad</code> value, if this is a <code>Bad</code>.</p><p>Note: This method can only be called if the <code>Bad</code> type of this <code>Or</code> is a subclass
of <code>Throwable</code> (or <code>Throwable</code> itself).</p><p>Note that values effectively &ldquo;switch sides&rdquo; when converting an <code>Or</code> to an <code>Either</code>. If the type of the
<code>Or</code> on which you invoke <code>toEither</code> is <code>Or[Int, ErrorMessage]</code> for example, the result will be an
<code>Either[ErrorMessage, Int]</code>. The reason is that the convention for <code>Either</code> is that <code>Left</code> is used for &ldquo;bad&rdquo;
values and <code>Right</code> is used for &ldquo;good&rdquo; ones.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>this <code>Good</code> value, wrapped in a <code>Right</code>, or this <code>Bad</code> value, wrapped in a <code>Left</code>.</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#transform" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="transform[H,C](gf:G=&gt;org.scalactic.Or[H,C],bf:B=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" class="anchorToMember"></a><a id="transform[H,C]((G)=&gt;Or[H,C],(B)=&gt;Or[H,C]):Or[H,C]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#transform[H,C](gf:G=&gt;org.scalactic.Or[H,C],bf:B=&gt;org.scalactic.Or[H,C]):org.scalactic.Or[H,C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">transform</span><span class="tparams">[<span name="H">H</span>, <span name="C">C</span>]</span><span class="params">(<span name="gf">gf: (<span name="org.scalactic.Or.G" class="extype">G</span>) =&gt; <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.transform.H" class="extype">H</span>, <span name="org.scalactic.Or.transform.C" class="extype">C</span>]</span>, <span name="bf">bf: (<span name="org.scalactic.Or.B" class="extype">B</span>) =&gt; <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.transform.H" class="extype">H</span>, <span name="org.scalactic.Or.transform.C" class="extype">C</span>]</span>)</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.transform.H" class="extype">H</span>, <span name="org.scalactic.Or.transform.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">Transforms this <code>Or</code> by applying the function <code>gf</code> to this <code>Or</code>'s <code>Good</code> value if it is a <code>Good</code>,
or by applying <code>bf</code> to this <code>Or</code>'s <code>Bad</code> value if it is a <code>Bad</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Transforms this <code>Or</code> by applying the function <code>gf</code> to this <code>Or</code>'s <code>Good</code> value if it is a <code>Good</code>,
or by applying <code>bf</code> to this <code>Or</code>'s <code>Bad</code> value if it is a <code>Bad</code>.
</p></div><dl class="paramcmts block"><dt class="param">gf</dt><dd class="cmt"><p>the function to apply to this <code>Or</code>'s <code>Good</code> value, if it is a <code>Good</code></p></dd><dt class="param">bf</dt><dd class="cmt"><p>the function to apply to this <code>Or</code>'s <code>Bad</code> value, if it is a <code>Bad</code></p></dd><dt>returns</dt><dd class="cmt"><p>the result of applying the appropriate one of the two passed functions, <code>gf</code> or </code>bf</code>, to this <code>Or</code>'s value</p></dd></dl></div></li></ol></div><div class="values members"><h3>Concrete Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean" class="anchorToMember"></a><a id="!=(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean" class="anchorToMember"></a><a id="==(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object" class="anchorToMember"></a><a id="clone():AnyRef" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="eq(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean" class="anchorToMember"></a><a id="equals(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]" class="anchorToMember"></a><a id="getClass():Class[_&lt;:AnyRef]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <span name="scala.AnyRef" class="extype">AnyRef</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#isBad" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isBad:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#isBad:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">isBad</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">Indicates whether this <code>Or</code> is a <code>Bad</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Indicates whether this <code>Or</code> is a <code>Bad</code>
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if this <code>Or</code> is a <code>Bad</code>, <code>false</code> if it is a <code>Good</code>.</p></dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#isGood" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isGood:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#isGood:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">isGood</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">Indicates whether this <code>Or</code> is a <code>Good</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Indicates whether this <code>Or</code> is a <code>Good</code>
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if this <code>Or</code> is a <code>Good</code>, <code>false</code> if it is a <code>Bad</code>.</p></dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="ne(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.Product#productElementName" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="productElementName(n:Int):String" class="anchorToMember"></a><a id="productElementName(Int):String" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#productElementName(n:Int):String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">productElementName</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Product</dd></dl></div></li><li class="indented0 " name="scala.Product#productElementNames" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="productElementNames:Iterator[String]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#productElementNames:Iterator[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">productElementNames</span><span class="result">: <span name="scala.Iterator" class="extype">Iterator</span>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Product</dd></dl></div></li><li class="indented0 " name="scala.Product#productIterator" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="productIterator:Iterator[Any]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#productIterator:Iterator[Any]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">productIterator</span><span class="result">: <span name="scala.Iterator" class="extype">Iterator</span>[<span name="scala.Any" class="extype">Any</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Product</dd></dl></div></li><li class="indented0 " name="scala.Product#productPrefix" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="productPrefix:String" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#productPrefix:String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">productPrefix</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Product</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0" class="anchorToMember"></a><a id="synchronized[T0](=&gt;T0):T0" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit" class="anchorToMember"></a><a id="wait(Long,Int):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit" class="anchorToMember"></a><a id="wait(Long):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="org.scalactic.Or#withFilter" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="withFilter[C&gt;:B](f:G=&gt;org.scalactic.Validation[C]):org.scalactic.Or[G,C]" class="anchorToMember"></a><a id="withFilter[C&gt;:B]((G)=&gt;Validation[C]):Or[G,C]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#withFilter[C&gt;:B](f:G=&gt;org.scalactic.Validation[C]):org.scalactic.Or[G,C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withFilter</span><span class="tparams">[<span name="C">C &gt;: <span name="org.scalactic.Or.B" class="extype">B</span></span>]</span><span class="params">(<span name="f">f: (<span name="org.scalactic.Or.G" class="extype">G</span>) =&gt; <a href="Validation.html" name="org.scalactic.Validation" id="org.scalactic.Validation" class="extype">Validation</a>[<span name="org.scalactic.Or.withFilter.C" class="extype">C</span>]</span>)</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.G" class="extype">G</span>, <span name="org.scalactic.Or.withFilter.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">Currently just forwards to </code>filter</code>, and therefore, returns the same result.</p></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="org.scalactic.Or#asOr" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asOr:org.scalactic.Or[G,B]" class="anchorToMember"></a><a id="asOr:Or[G,B]" class="anchorToMember"></a> <span class="permalink"><a href="../../org/scalactic/Or.html#asOr:org.scalactic.Or[G,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: The asOr is no longer needed because Good(value).orBad[Type] and Good[Type].orBad(value) now return Or. You can delete invocations of asOr in those cases, otherwise, please use a type annotation to widen the type, like (Good(3): Int Or ErrorMessage).">asOr</span><span class="result">: <a href="" name="org.scalactic.Or" id="org.scalactic.Or" class="extype">Or</a>[<span name="org.scalactic.Or.G" class="extype">G</span>, <span name="org.scalactic.Or.B" class="extype">B</span>]</span></span><p class="shortcomment cmt"><strong>The <code>asOr</code> method has been deprecated and will be removed in a future version of Scalactic.
Please remove invocations of <code>asOr</code> in expressions of type <code>Good(value).orBad[Type]</code> and
<code>Good[Type].orBad(value)</code> (which now return a type already widened to <code>Or</code>), otherwise please
use a type annotation to widen the type, such as: <code>(Good(3): Int Or ErrorMessage)</code>.</strong>
</p><div class="fullcomment"><div class="comment cmt"><p><strong>The <code>asOr</code> method has been deprecated and will be removed in a future version of Scalactic.
Please remove invocations of <code>asOr</code> in expressions of type <code>Good(value).orBad[Type]</code> and
<code>Good[Type].orBad(value)</code> (which now return a type already widened to <code>Or</code>), otherwise please
use a type annotation to widen the type, such as: <code>(Good(3): Int Or ErrorMessage)</code>.</strong>
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p>The asOr is no longer needed because Good(value).orBad[Type] and Good[Type].orBad(value) now return Or. You can delete invocations of asOr in those cases, otherwise, please use a type annotation to widen the type, like (Good(3): Int Or ErrorMessage).</p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="java.io.Serializable" class="parent"><h3>Inherited from <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></h3></div><div name="scala.Product" class="parent"><h3>Inherited from <span name="scala.Product" class="extype">Product</span></h3></div><div name="scala.Equals" class="parent"><h3>Inherited from <span name="scala.Equals" class="extype">Equals</span></h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
